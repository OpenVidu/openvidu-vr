/* eslint-disable no-param-reassign */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports)
		: typeof define === 'function' && define.amd ? define(['exports'], factory)
			: (factory((global.THREE = {})));
}(this, ((exports) => {
	// Polyfills

	if (Number.EPSILON === undefined) {
		Number.EPSILON = Math.pow(2, -52);
	}

	if (Number.isInteger === undefined) {
		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

		Number.isInteger = function (value) {
			return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
		};
	}

	//

	if (Math.sign === undefined) {
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

		Math.sign = function (x) {
			return (x < 0) ? -1 : (x > 0) ? 1 : +x;
		};
	}

	if ('name' in Function.prototype === false) {
		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

		Object.defineProperty(Function.prototype, 'name', {

			get() {
				return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
			},

		});
	}

	if (Object.assign === undefined) {
		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

		(function () {
			Object.assign = function (target) {
				if (target === undefined || target === null) {
					throw new TypeError('Cannot convert undefined or null to object');
				}

				const output = Object(target);

				for (let index = 1; index < arguments.length; index++) {
					const source = arguments[index];

					if (source !== undefined && source !== null) {
						for (const nextKey in source) {
							if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
								output[nextKey] = source[nextKey];
							}
						}
					}
				}

				return output;
			};
		}());
	}

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	function EventDispatcher() {}

	Object.assign(EventDispatcher.prototype, {

		addEventListener(type, listener) {
			if (this._listeners === undefined) this._listeners = {};

			const listeners = this._listeners;

			if (listeners[type] === undefined) {
				listeners[type] = [];
			}

			if (listeners[type].indexOf(listener) === -1) {
				listeners[type].push(listener);
			}
		},

		hasEventListener(type, listener) {
			if (this._listeners === undefined) return false;

			const listeners = this._listeners;

			return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
		},

		removeEventListener(type, listener) {
			if (this._listeners === undefined) return;

			const listeners = this._listeners;
			const listenerArray = listeners[type];

			if (listenerArray !== undefined) {
				const index = listenerArray.indexOf(listener);

				if (index !== -1) {
					listenerArray.splice(index, 1);
				}
			}
		},

		dispatchEvent(event) {
			if (this._listeners === undefined) return;

			const listeners = this._listeners;
			const listenerArray = listeners[event.type];

			if (listenerArray !== undefined) {
				event.target = this;

				const array = listenerArray.slice(0);

				for (let i = 0, l = array.length; i < l; i++) {
					array[i].call(this, event);
				}
			}
		},

	});

	const REVISION = '100';
	const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
	const CullFaceNone = 0;
	const CullFaceBack = 1;
	const CullFaceFront = 2;
	const CullFaceFrontBack = 3;
	const FrontFaceDirectionCW = 0;
	const FrontFaceDirectionCCW = 1;
	const BasicShadowMap = 0;
	const PCFShadowMap = 1;
	const PCFSoftShadowMap = 2;
	const FrontSide = 0;
	const BackSide = 1;
	const DoubleSide = 2;
	const FlatShading = 1;
	const SmoothShading = 2;
	const NoColors = 0;
	const FaceColors = 1;
	const VertexColors = 2;
	const NoBlending = 0;
	const NormalBlending = 1;
	const AdditiveBlending = 2;
	const SubtractiveBlending = 3;
	const MultiplyBlending = 4;
	const CustomBlending = 5;
	const AddEquation = 100;
	const SubtractEquation = 101;
	const ReverseSubtractEquation = 102;
	const MinEquation = 103;
	const MaxEquation = 104;
	const ZeroFactor = 200;
	const OneFactor = 201;
	const SrcColorFactor = 202;
	const OneMinusSrcColorFactor = 203;
	const SrcAlphaFactor = 204;
	const OneMinusSrcAlphaFactor = 205;
	const DstAlphaFactor = 206;
	const OneMinusDstAlphaFactor = 207;
	const DstColorFactor = 208;
	const OneMinusDstColorFactor = 209;
	const SrcAlphaSaturateFactor = 210;
	const NeverDepth = 0;
	const AlwaysDepth = 1;
	const LessDepth = 2;
	const LessEqualDepth = 3;
	const EqualDepth = 4;
	const GreaterEqualDepth = 5;
	const GreaterDepth = 6;
	const NotEqualDepth = 7;
	const MultiplyOperation = 0;
	const MixOperation = 1;
	const AddOperation = 2;
	const NoToneMapping = 0;
	const LinearToneMapping = 1;
	const ReinhardToneMapping = 2;
	const Uncharted2ToneMapping = 3;
	const CineonToneMapping = 4;
	const ACESFilmicToneMapping = 5;

	const UVMapping = 300;
	const CubeReflectionMapping = 301;
	const CubeRefractionMapping = 302;
	const EquirectangularReflectionMapping = 303;
	const EquirectangularRefractionMapping = 304;
	const SphericalReflectionMapping = 305;
	const CubeUVReflectionMapping = 306;
	const CubeUVRefractionMapping = 307;
	const RepeatWrapping = 1000;
	const ClampToEdgeWrapping = 1001;
	const MirroredRepeatWrapping = 1002;
	const NearestFilter = 1003;
	const NearestMipMapNearestFilter = 1004;
	const NearestMipMapLinearFilter = 1005;
	const LinearFilter = 1006;
	const LinearMipMapNearestFilter = 1007;
	const LinearMipMapLinearFilter = 1008;
	const UnsignedByteType = 1009;
	const ByteType = 1010;
	const ShortType = 1011;
	const UnsignedShortType = 1012;
	const IntType = 1013;
	const UnsignedIntType = 1014;
	const FloatType = 1015;
	const HalfFloatType = 1016;
	const UnsignedShort4444Type = 1017;
	const UnsignedShort5551Type = 1018;
	const UnsignedShort565Type = 1019;
	const UnsignedInt248Type = 1020;
	const AlphaFormat = 1021;
	const RGBFormat = 1022;
	const RGBAFormat = 1023;
	const LuminanceFormat = 1024;
	const LuminanceAlphaFormat = 1025;
	const RGBEFormat = RGBAFormat;
	const DepthFormat = 1026;
	const DepthStencilFormat = 1027;
	const RedFormat = 1028;
	const RGB_S3TC_DXT1_Format = 33776;
	const RGBA_S3TC_DXT1_Format = 33777;
	const RGBA_S3TC_DXT3_Format = 33778;
	const RGBA_S3TC_DXT5_Format = 33779;
	const RGB_PVRTC_4BPPV1_Format = 35840;
	const RGB_PVRTC_2BPPV1_Format = 35841;
	const RGBA_PVRTC_4BPPV1_Format = 35842;
	const RGBA_PVRTC_2BPPV1_Format = 35843;
	const RGB_ETC1_Format = 36196;
	const RGBA_ASTC_4x4_Format = 37808;
	const RGBA_ASTC_5x4_Format = 37809;
	const RGBA_ASTC_5x5_Format = 37810;
	const RGBA_ASTC_6x5_Format = 37811;
	const RGBA_ASTC_6x6_Format = 37812;
	const RGBA_ASTC_8x5_Format = 37813;
	const RGBA_ASTC_8x6_Format = 37814;
	const RGBA_ASTC_8x8_Format = 37815;
	const RGBA_ASTC_10x5_Format = 37816;
	const RGBA_ASTC_10x6_Format = 37817;
	const RGBA_ASTC_10x8_Format = 37818;
	const RGBA_ASTC_10x10_Format = 37819;
	const RGBA_ASTC_12x10_Format = 37820;
	const RGBA_ASTC_12x12_Format = 37821;
	const LoopOnce = 2200;
	const LoopRepeat = 2201;
	const LoopPingPong = 2202;
	const InterpolateDiscrete = 2300;
	const InterpolateLinear = 2301;
	const InterpolateSmooth = 2302;
	const ZeroCurvatureEnding = 2400;
	const ZeroSlopeEnding = 2401;
	const WrapAroundEnding = 2402;
	const TrianglesDrawMode = 0;
	const TriangleStripDrawMode = 1;
	const TriangleFanDrawMode = 2;
	const LinearEncoding = 3000;
	const sRGBEncoding = 3001;
	const GammaEncoding = 3007;
	const RGBEEncoding = 3002;
	const LogLuvEncoding = 3003;
	const RGBM7Encoding = 3004;
	const RGBM16Encoding = 3005;
	const RGBDEncoding = 3006;
	const BasicDepthPacking = 3200;
	const RGBADepthPacking = 3201;
	const TangentSpaceNormalMap = 0;
	const ObjectSpaceNormalMap = 1;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	var _Math = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,

		generateUUID: (function () {
			// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

			const lut = [];

			for (let i = 0; i < 256; i++) {
				lut[i] = (i < 16 ? '0' : '') + (i).toString(16);
			}

			return function generateUUID() {
				const d0 = Math.random() * 0xffffffff | 0;
				const d1 = Math.random() * 0xffffffff | 0;
				const d2 = Math.random() * 0xffffffff | 0;
				const d3 = Math.random() * 0xffffffff | 0;
				const uuid = `${lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff]}-${
					lut[d1 & 0xff]}${lut[d1 >> 8 & 0xff]}-${lut[d1 >> 16 & 0x0f | 0x40]}${lut[d1 >> 24 & 0xff]}-${
					lut[d2 & 0x3f | 0x80]}${lut[d2 >> 8 & 0xff]}-${lut[d2 >> 16 & 0xff]}${lut[d2 >> 24 & 0xff]
				}${lut[d3 & 0xff]}${lut[d3 >> 8 & 0xff]}${lut[d3 >> 16 & 0xff]}${lut[d3 >> 24 & 0xff]}`;

				// .toUpperCase() here flattens concatenated strings to save heap memory space.
				return uuid.toUpperCase();
			};
		}()),

		clamp(value, min, max) {
			return Math.max(min, Math.min(max, value));
		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo(n, m) {
			return ((n % m) + m) % m;
		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear(x, a1, a2, b1, b2) {
			return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
		},

		// https://en.wikipedia.org/wiki/Linear_interpolation

		lerp(x, y, t) {
			return (1 - t) * x + t * y;
		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep(x, min, max) {
			if (x <= min) return 0;
			if (x >= max) return 1;

			x = (x - min) / (max - min);

			return x * x * (3 - 2 * x);
		},

		smootherstep(x, min, max) {
			if (x <= min) return 0;
			if (x >= max) return 1;

			x = (x - min) / (max - min);

			return x * x * x * (x * (x * 6 - 15) + 10);
		},

		// Random integer from <low, high> interval

		randInt(low, high) {
			return low + Math.floor(Math.random() * (high - low + 1));
		},

		// Random float from <low, high> interval

		randFloat(low, high) {
			return low + Math.random() * (high - low);
		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread(range) {
			return range * (0.5 - Math.random());
		},

		degToRad(degrees) {
			return degrees * _Math.DEG2RAD;
		},

		radToDeg(radians) {
			return radians * _Math.RAD2DEG;
		},

		isPowerOfTwo(value) {
			return (value & (value - 1)) === 0 && value !== 0;
		},

		ceilPowerOfTwo(value) {
			return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
		},

		floorPowerOfTwo(value) {
			return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
		},

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	function Vector2(x, y) {
		this.x = x || 0;
		this.y = y || 0;
	}

	Object.defineProperties(Vector2.prototype, {

		width: {

			get() {
				return this.x;
			},

			set(value) {
				this.x = value;
			},

		},

		height: {

			get() {
				return this.y;
			},

			set(value) {
				this.y = value;
			},

		},

	});

	Object.assign(Vector2.prototype, {

		isVector2: true,

		set(x, y) {
			this.x = x;
			this.y = y;

			return this;
		},

		setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;

			return this;
		},

		setX(x) {
			this.x = x;

			return this;
		},

		setY(y) {
			this.y = y;

			return this;
		},

		setComponent(index, value) {
			switch (index) {
			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error(`index is out of range: ${index}`);
			}

			return this;
		},

		getComponent(index) {
			switch (index) {
			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error(`index is out of range: ${index}`);
			}
		},

		clone() {
			return new this.constructor(this.x, this.y);
		},

		copy(v) {
			this.x = v.x;
			this.y = v.y;

			return this;
		},

		add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;

			return this;
		},

		addScalar(s) {
			this.x += s;
			this.y += s;

			return this;
		},

		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;
		},

		addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;

			return this;
		},

		sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;

			return this;
		},

		subScalar(s) {
			this.x -= s;
			this.y -= s;

			return this;
		},

		subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;
		},

		multiply(v) {
			this.x *= v.x;
			this.y *= v.y;

			return this;
		},

		multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;

			return this;
		},

		divide(v) {
			this.x /= v.x;
			this.y /= v.y;

			return this;
		},

		divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		},

		applyMatrix3(m) {
			const { x } = this;
			const { y } = this;
			const e = m.elements;

			this.x = e[0] * x + e[3] * y + e[6];
			this.y = e[1] * x + e[4] * y + e[7];

			return this;
		},

		min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);

			return this;
		},

		max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);

			return this;
		},

		clamp(min, max) {
			// assumes min < max, componentwise

			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));

			return this;
		},

		clampScalar: (function () {
			const min = new Vector2();
			const max = new Vector2();

			return function clampScalar(minVal, maxVal) {
				min.set(minVal, minVal);
				max.set(maxVal, maxVal);

				return this.clamp(min, max);
			};
		}()),

		clampLength(min, max) {
			const length = this.length();

			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		},

		floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);

			return this;
		},

		ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);

			return this;
		},

		round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);

			return this;
		},

		roundToZero() {
			this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);

			return this;
		},

		negate() {
			this.x = -this.x;
			this.y = -this.y;

			return this;
		},

		dot(v) {
			return this.x * v.x + this.y * v.y;
		},

		cross(v) {
			return this.x * v.y - this.y * v.x;
		},

		lengthSq() {
			return this.x * this.x + this.y * this.y;
		},

		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		},

		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y);
		},

		normalize() {
			return this.divideScalar(this.length() || 1);
		},

		angle() {
			// computes the angle in radians with respect to the positive x-axis

			let angle = Math.atan2(this.y, this.x);

			if (angle < 0) angle += 2 * Math.PI;

			return angle;
		},

		distanceTo(v) {
			return Math.sqrt(this.distanceToSquared(v));
		},

		distanceToSquared(v) {
			const dx = this.x - v.x; const
				dy = this.y - v.y;
			return dx * dx + dy * dy;
		},

		manhattanDistanceTo(v) {
			return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
		},

		setLength(length) {
			return this.normalize().multiplyScalar(length);
		},

		lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;

			return this;
		},

		lerpVectors(v1, v2, alpha) {
			return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
		},

		equals(v) {
			return ((v.x === this.x) && (v.y === this.y));
		},

		fromArray(array, offset) {
			if (offset === undefined) offset = 0;

			this.x = array[offset];
			this.y = array[offset + 1];

			return this;
		},

		toArray(array, offset) {
			if (array === undefined) array = [];
			if (offset === undefined) offset = 0;

			array[offset] = this.x;
			array[offset + 1] = this.y;

			return array;
		},

		fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);

			return this;
		},

		rotateAround(center, angle) {
			const c = Math.cos(angle); const
				s = Math.sin(angle);

			const x = this.x - center.x;
			const y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Matrix4() {
		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1,

		];

		if (arguments.length > 0) {
			console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
		}
	}

	Object.assign(Matrix4.prototype, {

		isMatrix4: true,

		set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
			const te = this.elements;

			te[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;
			te[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;
			te[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;
			te[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;

			return this;
		},

		identity() {
			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1,

			);

			return this;
		},

		clone() {
			return new Matrix4().fromArray(this.elements);
		},

		copy(m) {
			const te = this.elements;
			const me = m.elements;

			te[0] = me[0]; te[1] = me[1]; te[2] = me[2]; te[3] = me[3];
			te[4] = me[4]; te[5] = me[5]; te[6] = me[6]; te[7] = me[7];
			te[8] = me[8]; te[9] = me[9]; te[10] = me[10]; te[11] = me[11];
			te[12] = me[12]; te[13] = me[13]; te[14] = me[14]; te[15] = me[15];

			return this;
		},

		copyPosition(m) {
			const te = this.elements; const
				me = m.elements;

			te[12] = me[12];
			te[13] = me[13];
			te[14] = me[14];

			return this;
		},

		extractBasis(xAxis, yAxis, zAxis) {
			xAxis.setFromMatrixColumn(this, 0);
			yAxis.setFromMatrixColumn(this, 1);
			zAxis.setFromMatrixColumn(this, 2);

			return this;
		},

		makeBasis(xAxis, yAxis, zAxis) {
			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1,
			);

			return this;
		},

		extractRotation: (function () {
			const v1 = new Vector3();

			return function extractRotation(m) {
				// this method does not support reflection matrices

				const te = this.elements;
				const me = m.elements;

				const scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
				const scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
				const scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();

				te[0] = me[0] * scaleX;
				te[1] = me[1] * scaleX;
				te[2] = me[2] * scaleX;
				te[3] = 0;

				te[4] = me[4] * scaleY;
				te[5] = me[5] * scaleY;
				te[6] = me[6] * scaleY;
				te[7] = 0;

				te[8] = me[8] * scaleZ;
				te[9] = me[9] * scaleZ;
				te[10] = me[10] * scaleZ;
				te[11] = 0;

				te[12] = 0;
				te[13] = 0;
				te[14] = 0;
				te[15] = 1;

				return this;
			};
		}()),

		makeRotationFromEuler(euler) {
			if (!(euler && euler.isEuler)) {
				console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
			}

			const te = this.elements;

			const { x } = euler;
			const { y } = euler;
			const { z } = euler;
			const a = Math.cos(x); const
				b = Math.sin(x);
			const c = Math.cos(y); const
				d = Math.sin(y);
			const e = Math.cos(z); const
				f = Math.sin(z);

			if (euler.order === 'XYZ') {
				var ae = a * e; var af = a * f; var be = b * e; var
					bf = b * f;

				te[0] = c * e;
				te[4] = -c * f;
				te[8] = d;

				te[1] = af + be * d;
				te[5] = ae - bf * d;
				te[9] = -b * c;

				te[2] = bf - ae * d;
				te[6] = be + af * d;
				te[10] = a * c;
			} else if (euler.order === 'YXZ') {
				var ce = c * e; var cf = c * f; var de = d * e; var
					df = d * f;

				te[0] = ce + df * b;
				te[4] = de * b - cf;
				te[8] = a * d;

				te[1] = a * f;
				te[5] = a * e;
				te[9] = -b;

				te[2] = cf * b - de;
				te[6] = df + ce * b;
				te[10] = a * c;
			} else if (euler.order === 'ZXY') {
				var ce = c * e; var cf = c * f; var de = d * e; var
					df = d * f;

				te[0] = ce - df * b;
				te[4] = -a * f;
				te[8] = de + cf * b;

				te[1] = cf + de * b;
				te[5] = a * e;
				te[9] = df - ce * b;

				te[2] = -a * d;
				te[6] = b;
				te[10] = a * c;
			} else if (euler.order === 'ZYX') {
				var ae = a * e; var af = a * f; var be = b * e; var
					bf = b * f;

				te[0] = c * e;
				te[4] = be * d - af;
				te[8] = ae * d + bf;

				te[1] = c * f;
				te[5] = bf * d + ae;
				te[9] = af * d - be;

				te[2] = -d;
				te[6] = b * c;
				te[10] = a * c;
			} else if (euler.order === 'YZX') {
				var ac = a * c; var ad = a * d; var bc = b * c; var
					bd = b * d;

				te[0] = c * e;
				te[4] = bd - ac * f;
				te[8] = bc * f + ad;

				te[1] = f;
				te[5] = a * e;
				te[9] = -b * e;

				te[2] = -d * e;
				te[6] = ad * f + bc;
				te[10] = ac - bd * f;
			} else if (euler.order === 'XZY') {
				var ac = a * c; var ad = a * d; var bc = b * c; var
					bd = b * d;

				te[0] = c * e;
				te[4] = -f;
				te[8] = d * e;

				te[1] = ac * f + bd;
				te[5] = a * e;
				te[9] = ad * f - bc;

				te[2] = bc * f - ad;
				te[6] = b * e;
				te[10] = bd * f + ac;
			}

			// bottom row
			te[3] = 0;
			te[7] = 0;
			te[11] = 0;

			// last column
			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;

			return this;
		},

		makeRotationFromQuaternion: (function () {
			const zero = new Vector3(0, 0, 0);
			const one = new Vector3(1, 1, 1);

			return function makeRotationFromQuaternion(q) {
				return this.compose(zero, q, one);
			};
		}()),

		lookAt: (function () {
			const x = new Vector3();
			const y = new Vector3();
			const z = new Vector3();

			return function lookAt(eye, target, up) {
				const te = this.elements;

				z.subVectors(eye, target);

				if (z.lengthSq() === 0) {
					// eye and target are in the same position

					z.z = 1;
				}

				z.normalize();
				x.crossVectors(up, z);

				if (x.lengthSq() === 0) {
					// up and z are parallel

					if (Math.abs(up.z) === 1) {
						z.x += 0.0001;
					} else {
						z.z += 0.0001;
					}

					z.normalize();
					x.crossVectors(up, z);
				}

				x.normalize();
				y.crossVectors(z, x);

				te[0] = x.x; te[4] = y.x; te[8] = z.x;
				te[1] = x.y; te[5] = y.y; te[9] = z.y;
				te[2] = x.z; te[6] = y.z; te[10] = z.z;

				return this;
			};
		}()),

		multiply(m, n) {
			if (n !== undefined) {
				console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
				return this.multiplyMatrices(m, n);
			}

			return this.multiplyMatrices(this, m);
		},

		premultiply(m) {
			return this.multiplyMatrices(m, this);
		},

		multiplyMatrices(a, b) {
			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;

			const a11 = ae[0]; const a12 = ae[4]; const a13 = ae[8]; const
				a14 = ae[12];
			const a21 = ae[1]; const a22 = ae[5]; const a23 = ae[9]; const
				a24 = ae[13];
			const a31 = ae[2]; const a32 = ae[6]; const a33 = ae[10]; const
				a34 = ae[14];
			const a41 = ae[3]; const a42 = ae[7]; const a43 = ae[11]; const
				a44 = ae[15];

			const b11 = be[0]; const b12 = be[4]; const b13 = be[8]; const
				b14 = be[12];
			const b21 = be[1]; const b22 = be[5]; const b23 = be[9]; const
				b24 = be[13];
			const b31 = be[2]; const b32 = be[6]; const b33 = be[10]; const
				b34 = be[14];
			const b41 = be[3]; const b42 = be[7]; const b43 = be[11]; const
				b44 = be[15];

			te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;
		},

		multiplyScalar(s) {
			const te = this.elements;

			te[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;
			te[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;
			te[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;
			te[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;

			return this;
		},

		applyToBufferAttribute: (function () {
			const v1 = new Vector3();

			return function applyToBufferAttribute(attribute) {
				for (let i = 0, l = attribute.count; i < l; i++) {
					v1.x = attribute.getX(i);
					v1.y = attribute.getY(i);
					v1.z = attribute.getZ(i);

					v1.applyMatrix4(this);

					attribute.setXYZ(i, v1.x, v1.y, v1.z);
				}

				return attribute;
			};
		}()),

		determinant() {
			const te = this.elements;

			const n11 = te[0]; const n12 = te[4]; const n13 = te[8]; const
				n14 = te[12];
			const n21 = te[1]; const n22 = te[5]; const n23 = te[9]; const
				n24 = te[13];
			const n31 = te[2]; const n32 = te[6]; const n33 = te[10]; const
				n34 = te[14];
			const n41 = te[3]; const n42 = te[7]; const n43 = te[11]; const
				n44 = te[15];

			// TODO: make this more efficient
			// ( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				)
				+ n42 * (
					+n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				)
				+ n43 * (
					+n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				)
				+ n44 * (
					-n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);
		},

		transpose() {
			const te = this.elements;
			let tmp;

			tmp = te[1]; te[1] = te[4]; te[4] = tmp;
			tmp = te[2]; te[2] = te[8]; te[8] = tmp;
			tmp = te[6]; te[6] = te[9]; te[9] = tmp;

			tmp = te[3]; te[3] = te[12]; te[12] = tmp;
			tmp = te[7]; te[7] = te[13]; te[13] = tmp;
			tmp = te[11]; te[11] = te[14]; te[14] = tmp;

			return this;
		},

		setPosition(v) {
			const te = this.elements;

			te[12] = v.x;
			te[13] = v.y;
			te[14] = v.z;

			return this;
		},

		getInverse(m, throwOnDegenerate) {
			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			const te = this.elements;
			const me = m.elements;

			const n11 = me[0]; const n21 = me[1]; const n31 = me[2]; const n41 = me[3];
			const n12 = me[4]; const n22 = me[5]; const n32 = me[6]; const n42 = me[7];
			const n13 = me[8]; const n23 = me[9]; const n33 = me[10]; const n43 = me[11];
			const n14 = me[12]; const n24 = me[13]; const n34 = me[14]; const n44 = me[15];

			const t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
			const t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
			const t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
			const t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if (det === 0) {
				const msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

				if (throwOnDegenerate === true) {
					throw new Error(msg);
				} else {
					console.warn(msg);
				}

				return this.identity();
			}

			const detInv = 1 / det;

			te[0] = t11 * detInv;
			te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
			te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
			te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;

			te[4] = t12 * detInv;
			te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
			te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
			te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;

			te[8] = t13 * detInv;
			te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
			te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
			te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;

			te[12] = t14 * detInv;
			te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
			te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
			te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;

			return this;
		},

		scale(v) {
			const te = this.elements;
			const { x } = v;
			const { y } = v;
			const { z } = v;

			te[0] *= x; te[4] *= y; te[8] *= z;
			te[1] *= x; te[5] *= y; te[9] *= z;
			te[2] *= x; te[6] *= y; te[10] *= z;
			te[3] *= x; te[7] *= y; te[11] *= z;

			return this;
		},

		getMaxScaleOnAxis() {
			const te = this.elements;

			const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
			const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
			const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];

			return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
		},

		makeTranslation(x, y, z) {
			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1,

			);

			return this;
		},

		makeRotationX(theta) {
			const c = Math.cos(theta); const
				s = Math.sin(theta);

			this.set(

				1, 0, 0, 0,
				0, c, -s, 0,
				0, s, c, 0,
				0, 0, 0, 1,

			);

			return this;
		},

		makeRotationY(theta) {
			const c = Math.cos(theta); const
				s = Math.sin(theta);

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				-s, 0, c, 0,
				 0, 0, 0, 1,

			);

			return this;
		},

		makeRotationZ(theta) {
			const c = Math.cos(theta); const
				s = Math.sin(theta);

			this.set(

				c, -s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1,

			);

			return this;
		},

		makeRotationAxis(axis, angle) {
			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			const c = Math.cos(angle);
			const s = Math.sin(angle);
			const t = 1 - c;
			const { x } = axis;
			const { y } = axis;
			const { z } = axis;
			const tx = t * x; const
				ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1,

			);

			 return this;
		},

		makeScale(x, y, z) {
			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1,

			);

			return this;
		},

		makeShear(x, y, z) {
			this.set(

				1, y, z, 0,
				x, 1, z, 0,
				x, y, 1, 0,
				0, 0, 0, 1,

			);

			return this;
		},

		compose(position, quaternion, scale) {
			const te = this.elements;

			const x = quaternion._x; const y = quaternion._y; const z = quaternion._z; const
				w = quaternion._w;
			const x2 = x + x; const	y2 = y + y; const
				z2 = z + z;
			const xx = x * x2; const xy = x * y2; const
				xz = x * z2;
			const yy = y * y2; const yz = y * z2; const
				zz = z * z2;
			const wx = w * x2; const wy = w * y2; const
				wz = w * z2;

			const sx = scale.x; const sy = scale.y; const
				sz = scale.z;

		        te[0] = (1 - (yy + zz)) * sx;
		        te[1] = (xy + wz) * sx;
		        te[2] = (xz - wy) * sx;
		        te[3] = 0;

		        te[4] = (xy - wz) * sy;
		        te[5] = (1 - (xx + zz)) * sy;
		        te[6] = (yz + wx) * sy;
		        te[7] = 0;

		        te[8] = (xz + wy) * sz;
		        te[9] = (yz - wx) * sz;
		        te[10] = (1 - (xx + yy)) * sz;
		        te[11] = 0;

		        te[12] = position.x;
		        te[13] = position.y;
		        te[14] = position.z;
		        te[15] = 1;

		        return this;
		},

		decompose: (function () {
			const vector = new Vector3();
			const matrix = new Matrix4();

			return function decompose(position, quaternion, scale) {
				const te = this.elements;

				let sx = vector.set(te[0], te[1], te[2]).length();
				const sy = vector.set(te[4], te[5], te[6]).length();
				const sz = vector.set(te[8], te[9], te[10]).length();

				// if determine is negative, we need to invert one scale
				const det = this.determinant();
				if (det < 0) sx = -sx;

				position.x = te[12];
				position.y = te[13];
				position.z = te[14];

				// scale the rotation part
				matrix.copy(this);

				const invSX = 1 / sx;
				const invSY = 1 / sy;
				const invSZ = 1 / sz;

				matrix.elements[0] *= invSX;
				matrix.elements[1] *= invSX;
				matrix.elements[2] *= invSX;

				matrix.elements[4] *= invSY;
				matrix.elements[5] *= invSY;
				matrix.elements[6] *= invSY;

				matrix.elements[8] *= invSZ;
				matrix.elements[9] *= invSZ;
				matrix.elements[10] *= invSZ;

				quaternion.setFromRotationMatrix(matrix);

				scale.x = sx;
				scale.y = sy;
				scale.z = sz;

				return this;
			};
		}()),

		makePerspective(left, right, top, bottom, near, far) {
			if (far === undefined) {
				console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
			}

			const te = this.elements;
			const x = 2 * near / (right - left);
			const y = 2 * near / (top - bottom);

			const a = (right + left) / (right - left);
			const b = (top + bottom) / (top - bottom);
			const c = -(far + near) / (far - near);
			const d = -2 * far * near / (far - near);

			te[0] = x;	te[4] = 0;	te[8] = a;	te[12] = 0;
			te[1] = 0;	te[5] = y;	te[9] = b;	te[13] = 0;
			te[2] = 0;	te[6] = 0;	te[10] = c;	te[14] = d;
			te[3] = 0;	te[7] = 0;	te[11] = -1;	te[15] = 0;

			return this;
		},

		makeOrthographic(left, right, top, bottom, near, far) {
			const te = this.elements;
			const w = 1.0 / (right - left);
			const h = 1.0 / (top - bottom);
			const p = 1.0 / (far - near);

			const x = (right + left) * w;
			const y = (top + bottom) * h;
			const z = (far + near) * p;

			te[0] = 2 * w;	te[4] = 0;	te[8] = 0;	te[12] = -x;
			te[1] = 0;	te[5] = 2 * h;	te[9] = 0;	te[13] = -y;
			te[2] = 0;	te[6] = 0;	te[10] = -2 * p;	te[14] = -z;
			te[3] = 0;	te[7] = 0;	te[11] = 0;	te[15] = 1;

			return this;
		},

		equals(matrix) {
			const te = this.elements;
			const me = matrix.elements;

			for (let i = 0; i < 16; i++) {
				if (te[i] !== me[i]) return false;
			}

			return true;
		},

		fromArray(array, offset) {
			if (offset === undefined) offset = 0;

			for (let i = 0; i < 16; i++) {
				this.elements[i] = array[i + offset];
			}

			return this;
		},

		toArray(array, offset) {
			if (array === undefined) array = [];
			if (offset === undefined) offset = 0;

			const te = this.elements;

			array[offset] = te[0];
			array[offset + 1] = te[1];
			array[offset + 2] = te[2];
			array[offset + 3] = te[3];

			array[offset + 4] = te[4];
			array[offset + 5] = te[5];
			array[offset + 6] = te[6];
			array[offset + 7] = te[7];

			array[offset + 8] = te[8];
			array[offset + 9] = te[9];
			array[offset + 10] = te[10];
			array[offset + 11] = te[11];

			array[offset + 12] = te[12];
			array[offset + 13] = te[13];
			array[offset + 14] = te[14];
			array[offset + 15] = te[15];

			return array;
		},

	});

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	function Quaternion(x, y, z, w) {
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = (w !== undefined) ? w : 1;
	}

	Object.assign(Quaternion, {

		slerp(qa, qb, qm, t) {
			return qm.copy(qa).slerp(qb, t);
		},

		slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
			// fuzz-free, array-based Quaternion SLERP operation

			let x0 = src0[srcOffset0 + 0];
			let y0 = src0[srcOffset0 + 1];
			let z0 = src0[srcOffset0 + 2];
			let w0 = src0[srcOffset0 + 3];

			const x1 = src1[srcOffset1 + 0];
			const y1 = src1[srcOffset1 + 1];
			const z1 = src1[srcOffset1 + 2];
			const w1 = src1[srcOffset1 + 3];

			if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
				let s = 1 - t;

				const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1;

				const dir = (cos >= 0 ? 1 : -1);
				const sqrSin = 1 - cos * cos;

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if (sqrSin > Number.EPSILON) {
					const sin = Math.sqrt(sqrSin);
					const len = Math.atan2(sin, cos * dir);

					s = Math.sin(s * len) / sin;
					t = Math.sin(t * len) / sin;
				}

				const tDir = t * dir;

				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;

				// Normalize in case we just did a lerp:
				if (s === 1 - t) {
					const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;
				}
			}

			dst[dstOffset] = x0;
			dst[dstOffset + 1] = y0;
			dst[dstOffset + 2] = z0;
			dst[dstOffset + 3] = w0;
		},

	});

	Object.defineProperties(Quaternion.prototype, {

		x: {

			get() {
				return this._x;
			},

			set(value) {
				this._x = value;
				this.onChangeCallback();
			},

		},

		y: {

			get() {
				return this._y;
			},

			set(value) {
				this._y = value;
				this.onChangeCallback();
			},

		},

		z: {

			get() {
				return this._z;
			},

			set(value) {
				this._z = value;
				this.onChangeCallback();
			},

		},

		w: {

			get() {
				return this._w;
			},

			set(value) {
				this._w = value;
				this.onChangeCallback();
			},

		},

	});

	Object.assign(Quaternion.prototype, {

		isQuaternion: true,

		set(x, y, z, w) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this.onChangeCallback();

			return this;
		},

		clone() {
			return new this.constructor(this._x, this._y, this._z, this._w);
		},

		copy(quaternion) {
			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this.onChangeCallback();

			return this;
		},

		setFromEuler(euler, update) {
			if (!(euler && euler.isEuler)) {
				throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
			}

			const x = euler._x; const y = euler._y; const z = euler._z; const
				{ order } = euler;

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			const { cos } = Math;
			const { sin } = Math;

			const c1 = cos(x / 2);
			const c2 = cos(y / 2);
			const c3 = cos(z / 2);

			const s1 = sin(x / 2);
			const s2 = sin(y / 2);
			const s3 = sin(z / 2);

			if (order === 'XYZ') {
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
			} else if (order === 'YXZ') {
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
			} else if (order === 'ZXY') {
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
			} else if (order === 'ZYX') {
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
			} else if (order === 'YZX') {
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
			} else if (order === 'XZY') {
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
			}

			if (update !== false) this.onChangeCallback();

			return this;
		},

		setFromAxisAngle(axis, angle) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			const halfAngle = angle / 2; const
				s = Math.sin(halfAngle);

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos(halfAngle);

			this.onChangeCallback();

			return this;
		},

		setFromRotationMatrix(m) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			const te = m.elements;

			const m11 = te[0]; const m12 = te[4]; const m13 = te[8];
			const m21 = te[1]; const m22 = te[5]; const m23 = te[9];
			const m31 = te[2]; const m32 = te[6]; const m33 = te[10];

			const trace = m11 + m22 + m33;
			let s;

			if (trace > 0) {
				s = 0.5 / Math.sqrt(trace + 1.0);

				this._w = 0.25 / s;
				this._x = (m32 - m23) * s;
				this._y = (m13 - m31) * s;
				this._z = (m21 - m12) * s;
			} else if (m11 > m22 && m11 > m33) {
				s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);

				this._w = (m32 - m23) / s;
				this._x = 0.25 * s;
				this._y = (m12 + m21) / s;
				this._z = (m13 + m31) / s;
			} else if (m22 > m33) {
				s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);

				this._w = (m13 - m31) / s;
				this._x = (m12 + m21) / s;
				this._y = 0.25 * s;
				this._z = (m23 + m32) / s;
			} else {
				s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);

				this._w = (m21 - m12) / s;
				this._x = (m13 + m31) / s;
				this._y = (m23 + m32) / s;
				this._z = 0.25 * s;
			}

			this.onChangeCallback();

			return this;
		},

		setFromUnitVectors: (function () {
			// assumes direction vectors vFrom and vTo are normalized

			let v1 = new Vector3();
			let r;

			const EPS = 0.000001;

			return function setFromUnitVectors(vFrom, vTo) {
				if (v1 === undefined) v1 = new Vector3();

				r = vFrom.dot(vTo) + 1;

				if (r < EPS) {
					r = 0;

					if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
						v1.set(-vFrom.y, vFrom.x, 0);
					} else {
						v1.set(0, -vFrom.z, vFrom.y);
					}
				} else {
					v1.crossVectors(vFrom, vTo);
				}

				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;

				return this.normalize();
			};
		}()),

		angleTo(q) {
			return 2 * Math.acos(Math.abs(_Math.clamp(this.dot(q), -1, 1)));
		},

		rotateTowards(q, step) {
			const angle = this.angleTo(q);

			if (angle === 0) return this;

			const t = Math.min(1, step / angle);

			this.slerp(q, t);

			return this;
		},

		inverse() {
			// quaternion is assumed to have unit length

			return this.conjugate();
		},

		conjugate() {
			this._x *= -1;
			this._y *= -1;
			this._z *= -1;

			this.onChangeCallback();

			return this;
		},

		dot(v) {
			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
		},

		lengthSq() {
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
		},

		length() {
			return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
		},

		normalize() {
			let l = this.length();

			if (l === 0) {
				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;
			} else {
				l = 1 / l;

				this._x *= l;
				this._y *= l;
				this._z *= l;
				this._w *= l;
			}

			this.onChangeCallback();

			return this;
		},

		multiply(q, p) {
			if (p !== undefined) {
				console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
				return this.multiplyQuaternions(q, p);
			}

			return this.multiplyQuaternions(this, q);
		},

		premultiply(q) {
			return this.multiplyQuaternions(q, this);
		},

		multiplyQuaternions(a, b) {
			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			const qax = a._x; const qay = a._y; const qaz = a._z; const
				qaw = a._w;
			const qbx = b._x; const qby = b._y; const qbz = b._z; const
				qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this.onChangeCallback();

			return this;
		},

		slerp(qb, t) {
			if (t === 0) return this;
			if (t === 1) return this.copy(qb);

			const x = this._x; const y = this._y; const z = this._z; const
				w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if (cosHalfTheta < 0) {
				this._w = -qb._w;
				this._x = -qb._x;
				this._y = -qb._y;
				this._z = -qb._z;

				cosHalfTheta = -cosHalfTheta;
			} else {
				this.copy(qb);
			}

			if (cosHalfTheta >= 1.0) {
				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;
			}

			const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if (sqrSinHalfTheta <= Number.EPSILON) {
				const s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;

				return this.normalize();
			}

			const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
			const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
			const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
			const ratioB = Math.sin(t * halfTheta) / sinHalfTheta;

			this._w = (w * ratioA + this._w * ratioB);
			this._x = (x * ratioA + this._x * ratioB);
			this._y = (y * ratioA + this._y * ratioB);
			this._z = (z * ratioA + this._z * ratioB);

			this.onChangeCallback();

			return this;
		},

		equals(quaternion) {
			return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);
		},

		fromArray(array, offset) {
			if (offset === undefined) offset = 0;

			this._x = array[offset];
			this._y = array[offset + 1];
			this._z = array[offset + 2];
			this._w = array[offset + 3];

			this.onChangeCallback();

			return this;
		},

		toArray(array, offset) {
			if (array === undefined) array = [];
			if (offset === undefined) offset = 0;

			array[offset] = this._x;
			array[offset + 1] = this._y;
			array[offset + 2] = this._z;
			array[offset + 3] = this._w;

			return array;
		},

		onChange(callback) {
			this.onChangeCallback = callback;

			return this;
		},

		onChangeCallback() {},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Vector3(x, y, z) {
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
	}

	Object.assign(Vector3.prototype, {

		isVector3: true,

		set(x, y, z) {
			this.x = x;
			this.y = y;
			this.z = z;

			return this;
		},

		setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;
		},

		setX(x) {
			this.x = x;

			return this;
		},

		setY(y) {
			this.y = y;

			return this;
		},

		setZ(z) {
			this.z = z;

			return this;
		},

		setComponent(index, value) {
			switch (index) {
			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error(`index is out of range: ${index}`);
			}

			return this;
		},

		getComponent(index) {
			switch (index) {
			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error(`index is out of range: ${index}`);
			}
		},

		clone() {
			return new this.constructor(this.x, this.y, this.z);
		},

		copy(v) {
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;
		},

		add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;
		},

		addScalar(s) {
			this.x += s;
			this.y += s;
			this.z += s;

			return this;
		},

		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;
		},

		addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;
		},

		sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;
		},

		subScalar(s) {
			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;
		},

		subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;
		},

		multiply(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
				return this.multiplyVectors(v, w);
			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;
		},

		multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;
		},

		multiplyVectors(a, b) {
			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;
		},

		applyEuler: (function () {
			const quaternion = new Quaternion();

			return function applyEuler(euler) {
				if (!(euler && euler.isEuler)) {
					console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
				}

				return this.applyQuaternion(quaternion.setFromEuler(euler));
			};
		}()),

		applyAxisAngle: (function () {
			const quaternion = new Quaternion();

			return function applyAxisAngle(axis, angle) {
				return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
			};
		}()),

		applyMatrix3(m) {
			const { x } = this;
			const { y } = this;
			const { z } = this;
			const e = m.elements;

			this.x = e[0] * x + e[3] * y + e[6] * z;
			this.y = e[1] * x + e[4] * y + e[7] * z;
			this.z = e[2] * x + e[5] * y + e[8] * z;

			return this;
		},

		applyMatrix4(m) {
			const { x } = this;
			const { y } = this;
			const { z } = this;
			const e = m.elements;

			const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);

			this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
			this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
			this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;

			return this;
		},

		applyQuaternion(q) {
			const { x } = this;
			const { y } = this;
			const { z } = this;
			const qx = q.x; const qy = q.y; const qz = q.z; const
				qw = q.w;

			// calculate quat * vector

			const ix = qw * x + qy * z - qz * y;
			const iy = qw * y + qz * x - qx * z;
			const iz = qw * z + qx * y - qy * x;
			const iw = -qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
			this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
			this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

			return this;
		},

		project(camera) {
			return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
		},

		unproject: (function () {
			const matrix = new Matrix4();

			return function unproject(camera) {
				return this.applyMatrix4(matrix.getInverse(camera.projectionMatrix)).applyMatrix4(camera.matrixWorld);
			};
		}()),

		transformDirection(m) {
			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			const { x } = this;
			const { y } = this;
			const { z } = this;
			const e = m.elements;

			this.x = e[0] * x + e[4] * y + e[8] * z;
			this.y = e[1] * x + e[5] * y + e[9] * z;
			this.z = e[2] * x + e[6] * y + e[10] * z;

			return this.normalize();
		},

		divide(v) {
			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;
		},

		divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		},

		min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			this.z = Math.min(this.z, v.z);

			return this;
		},

		max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			this.z = Math.max(this.z, v.z);

			return this;
		},

		clamp(min, max) {
			// assumes min < max, componentwise

			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			this.z = Math.max(min.z, Math.min(max.z, this.z));

			return this;
		},

		clampScalar: (function () {
			const min = new Vector3();
			const max = new Vector3();

			return function clampScalar(minVal, maxVal) {
				min.set(minVal, minVal, minVal);
				max.set(maxVal, maxVal, maxVal);

				return this.clamp(min, max);
			};
		}()),

		clampLength(min, max) {
			const length = this.length();

			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		},

		floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);

			return this;
		},

		ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);

			return this;
		},

		round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);

			return this;
		},

		roundToZero() {
			this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);

			return this;
		},

		negate() {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;

			return this;
		},

		dot(v) {
			return this.x * v.x + this.y * v.y + this.z * v.z;
		},

		// TODO lengthSquared?

		lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z;
		},

		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		},

		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
		},

		normalize() {
			return this.divideScalar(this.length() || 1);
		},

		setLength(length) {
			return this.normalize().multiplyScalar(length);
		},

		lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			this.z += (v.z - this.z) * alpha;

			return this;
		},

		lerpVectors(v1, v2, alpha) {
			return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
		},

		cross(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
				return this.crossVectors(v, w);
			}

			return this.crossVectors(this, v);
		},

		crossVectors(a, b) {
			const ax = a.x; const ay = a.y; const
				az = a.z;
			const bx = b.x; const by = b.y; const
				bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;
		},

		projectOnVector(vector) {
			const scalar = vector.dot(this) / vector.lengthSq();

			return this.copy(vector).multiplyScalar(scalar);
		},

		projectOnPlane: (function () {
			const v1 = new Vector3();

			return function projectOnPlane(planeNormal) {
				v1.copy(this).projectOnVector(planeNormal);

				return this.sub(v1);
			};
		}()),

		reflect: (function () {
			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			const v1 = new Vector3();

			return function reflect(normal) {
				return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
			};
		}()),

		angleTo(v) {
			const theta = this.dot(v) / (Math.sqrt(this.lengthSq() * v.lengthSq()));

			// clamp, to handle numerical problems

			return Math.acos(_Math.clamp(theta, -1, 1));
		},

		distanceTo(v) {
			return Math.sqrt(this.distanceToSquared(v));
		},

		distanceToSquared(v) {
			const dx = this.x - v.x; const dy = this.y - v.y; const
				dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;
		},

		manhattanDistanceTo(v) {
			return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
		},

		setFromSpherical(s) {
			return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
		},

		setFromSphericalCoords(radius, phi, theta) {
			const sinPhiRadius = Math.sin(phi) * radius;

			this.x = sinPhiRadius * Math.sin(theta);
			this.y = Math.cos(phi) * radius;
			this.z = sinPhiRadius * Math.cos(theta);

			return this;
		},

		setFromCylindrical(c) {
			return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
		},

		setFromCylindricalCoords(radius, theta, y) {
			this.x = radius * Math.sin(theta);
			this.y = y;
			this.z = radius * Math.cos(theta);

			return this;
		},

		setFromMatrixPosition(m) {
			const e = m.elements;

			this.x = e[12];
			this.y = e[13];
			this.z = e[14];

			return this;
		},

		setFromMatrixScale(m) {
			const sx = this.setFromMatrixColumn(m, 0).length();
			const sy = this.setFromMatrixColumn(m, 1).length();
			const sz = this.setFromMatrixColumn(m, 2).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;
		},

		setFromMatrixColumn(m, index) {
			return this.fromArray(m.elements, index * 4);
		},

		equals(v) {
			return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));
		},

		fromArray(array, offset) {
			if (offset === undefined) offset = 0;

			this.x = array[offset];
			this.y = array[offset + 1];
			this.z = array[offset + 2];

			return this;
		},

		toArray(array, offset) {
			if (array === undefined) array = [];
			if (offset === undefined) offset = 0;

			array[offset] = this.x;
			array[offset + 1] = this.y;
			array[offset + 2] = this.z;

			return array;
		},

		fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			this.z = attribute.getZ(index);

			return this;
		},

	});

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 * @author tschw
	 */

	function Matrix3() {
		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1,

		];

		if (arguments.length > 0) {
			console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
		}
	}

	Object.assign(Matrix3.prototype, {

		isMatrix3: true,

		set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
			const te = this.elements;

			te[0] = n11; te[1] = n21; te[2] = n31;
			te[3] = n12; te[4] = n22; te[5] = n32;
			te[6] = n13; te[7] = n23; te[8] = n33;

			return this;
		},

		identity() {
			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1,

			);

			return this;
		},

		clone() {
			return new this.constructor().fromArray(this.elements);
		},

		copy(m) {
			const te = this.elements;
			const me = m.elements;

			te[0] = me[0]; te[1] = me[1]; te[2] = me[2];
			te[3] = me[3]; te[4] = me[4]; te[5] = me[5];
			te[6] = me[6]; te[7] = me[7]; te[8] = me[8];

			return this;
		},

		setFromMatrix4(m) {
			const me = m.elements;

			this.set(

				me[0], me[4], me[8],
				me[1], me[5], me[9],
				me[2], me[6], me[10],

			);

			return this;
		},

		applyToBufferAttribute: (function () {
			const v1 = new Vector3();

			return function applyToBufferAttribute(attribute) {
				for (let i = 0, l = attribute.count; i < l; i++) {
					v1.x = attribute.getX(i);
					v1.y = attribute.getY(i);
					v1.z = attribute.getZ(i);

					v1.applyMatrix3(this);

					attribute.setXYZ(i, v1.x, v1.y, v1.z);
				}

				return attribute;
			};
		}()),

		multiply(m) {
			return this.multiplyMatrices(this, m);
		},

		premultiply(m) {
			return this.multiplyMatrices(m, this);
		},

		multiplyMatrices(a, b) {
			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;

			const a11 = ae[0]; const a12 = ae[3]; const
				a13 = ae[6];
			const a21 = ae[1]; const a22 = ae[4]; const
				a23 = ae[7];
			const a31 = ae[2]; const a32 = ae[5]; const
				a33 = ae[8];

			const b11 = be[0]; const b12 = be[3]; const
				b13 = be[6];
			const b21 = be[1]; const b22 = be[4]; const
				b23 = be[7];
			const b31 = be[2]; const b32 = be[5]; const
				b33 = be[8];

			te[0] = a11 * b11 + a12 * b21 + a13 * b31;
			te[3] = a11 * b12 + a12 * b22 + a13 * b32;
			te[6] = a11 * b13 + a12 * b23 + a13 * b33;

			te[1] = a21 * b11 + a22 * b21 + a23 * b31;
			te[4] = a21 * b12 + a22 * b22 + a23 * b32;
			te[7] = a21 * b13 + a22 * b23 + a23 * b33;

			te[2] = a31 * b11 + a32 * b21 + a33 * b31;
			te[5] = a31 * b12 + a32 * b22 + a33 * b32;
			te[8] = a31 * b13 + a32 * b23 + a33 * b33;

			return this;
		},

		multiplyScalar(s) {
			const te = this.elements;

			te[0] *= s; te[3] *= s; te[6] *= s;
			te[1] *= s; te[4] *= s; te[7] *= s;
			te[2] *= s; te[5] *= s; te[8] *= s;

			return this;
		},

		determinant() {
			const te = this.elements;

			const a = te[0]; const b = te[1]; const c = te[2];
			const d = te[3]; const e = te[4]; const f = te[5];
			const g = te[6]; const h = te[7]; const
				i = te[8];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
		},

		getInverse(matrix, throwOnDegenerate) {
			if (matrix && matrix.isMatrix4) {
				console.error('THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.');
			}

			const me = matrix.elements;
			const te = this.elements;

			const n11 = me[0]; const n21 = me[1]; const n31 = me[2];
			const n12 = me[3]; const n22 = me[4]; const n32 = me[5];
			const n13 = me[6]; const n23 = me[7]; const n33 = me[8];

			const t11 = n33 * n22 - n32 * n23;
			const t12 = n32 * n13 - n33 * n12;
			const t13 = n23 * n12 - n22 * n13;

			const det = n11 * t11 + n21 * t12 + n31 * t13;

			if (det === 0) {
				const msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

				if (throwOnDegenerate === true) {
					throw new Error(msg);
				} else {
					console.warn(msg);
				}

				return this.identity();
			}

			const detInv = 1 / det;

			te[0] = t11 * detInv;
			te[1] = (n31 * n23 - n33 * n21) * detInv;
			te[2] = (n32 * n21 - n31 * n22) * detInv;

			te[3] = t12 * detInv;
			te[4] = (n33 * n11 - n31 * n13) * detInv;
			te[5] = (n31 * n12 - n32 * n11) * detInv;

			te[6] = t13 * detInv;
			te[7] = (n21 * n13 - n23 * n11) * detInv;
			te[8] = (n22 * n11 - n21 * n12) * detInv;

			return this;
		},

		transpose() {
			let tmp; const
				m = this.elements;

			tmp = m[1]; m[1] = m[3]; m[3] = tmp;
			tmp = m[2]; m[2] = m[6]; m[6] = tmp;
			tmp = m[5]; m[5] = m[7]; m[7] = tmp;

			return this;
		},

		getNormalMatrix(matrix4) {
			return this.setFromMatrix4(matrix4).getInverse(this).transpose();
		},

		transposeIntoArray(r) {
			const m = this.elements;

			r[0] = m[0];
			r[1] = m[3];
			r[2] = m[6];
			r[3] = m[1];
			r[4] = m[4];
			r[5] = m[7];
			r[6] = m[2];
			r[7] = m[5];
			r[8] = m[8];

			return this;
		},

		setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
			const c = Math.cos(rotation);
			const s = Math.sin(rotation);

			this.set(
				sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx,
				-sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty,
				0, 0, 1,
			);
		},

		scale(sx, sy) {
			const te = this.elements;

			te[0] *= sx; te[3] *= sx; te[6] *= sx;
			te[1] *= sy; te[4] *= sy; te[7] *= sy;

			return this;
		},

		rotate(theta) {
			const c = Math.cos(theta);
			const s = Math.sin(theta);

			const te = this.elements;

			const a11 = te[0]; const a12 = te[3]; const
				a13 = te[6];
			const a21 = te[1]; const a22 = te[4]; const
				a23 = te[7];

			te[0] = c * a11 + s * a21;
			te[3] = c * a12 + s * a22;
			te[6] = c * a13 + s * a23;

			te[1] = -s * a11 + c * a21;
			te[4] = -s * a12 + c * a22;
			te[7] = -s * a13 + c * a23;

			return this;
		},

		translate(tx, ty) {
			const te = this.elements;

			te[0] += tx * te[2]; te[3] += tx * te[5]; te[6] += tx * te[8];
			te[1] += ty * te[2]; te[4] += ty * te[5]; te[7] += ty * te[8];

			return this;
		},

		equals(matrix) {
			const te = this.elements;
			const me = matrix.elements;

			for (let i = 0; i < 9; i++) {
				if (te[i] !== me[i]) return false;
			}

			return true;
		},

		fromArray(array, offset) {
			if (offset === undefined) offset = 0;

			for (let i = 0; i < 9; i++) {
				this.elements[i] = array[i + offset];
			}

			return this;
		},

		toArray(array, offset) {
			if (array === undefined) array = [];
			if (offset === undefined) offset = 0;

			const te = this.elements;

			array[offset] = te[0];
			array[offset + 1] = te[1];
			array[offset + 2] = te[2];

			array[offset + 3] = te[3];
			array[offset + 4] = te[4];
			array[offset + 5] = te[5];

			array[offset + 6] = te[6];
			array[offset + 7] = te[7];
			array[offset + 8] = te[8];

			return array;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	let _canvas;

	const ImageUtils = {

		getDataURL(image) {
			let canvas;

			if (typeof HTMLCanvasElement === 'undefined') {
				return image.src;
			} if (image instanceof HTMLCanvasElement) {
				canvas = image;
			} else {
				if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');

				_canvas.width = image.width;
				_canvas.height = image.height;

				const context = _canvas.getContext('2d');

				if (image instanceof ImageData) {
					context.putImageData(image, 0, 0);
				} else {
					context.drawImage(image, 0, 0, image.width, image.height);
				}

				canvas = _canvas;
			}

			if (canvas.width > 2048 || canvas.height > 2048) {
				return canvas.toDataURL('image/jpeg', 0.6);
			}
			return canvas.toDataURL('image/png');
		},

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	let textureId = 0;

	function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
		Object.defineProperty(this, 'id', { value: textureId++ });

		this.uuid = _Math.generateUUID();

		this.name = '';

		this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
		this.mipmaps = [];

		this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

		this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

		this.format = format !== undefined ? format : RGBAFormat;
		this.type = type !== undefined ? type : UnsignedByteType;

		this.offset = new Vector2(0, 0);
		this.repeat = new Vector2(1, 1);
		this.center = new Vector2(0, 0);
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding !== undefined ? encoding : LinearEncoding;

		this.version = 0;
		this.onUpdate = null;
	}

	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;

	Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {

		constructor: Texture,

		isTexture: true,

		updateMatrix() {
			this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
		},

		clone() {
			return new this.constructor().copy(this);
		},

		copy(source) {
			this.name = source.name;

			this.image = source.image;
			this.mipmaps = source.mipmaps.slice(0);

			this.mapping = source.mapping;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.type = source.type;

			this.offset.copy(source.offset);
			this.repeat.copy(source.repeat);
			this.center.copy(source.center);
			this.rotation = source.rotation;

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy(source.matrix);

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;

			return this;
		},

		toJSON(meta) {
			const isRootObject = (meta === undefined || typeof meta === 'string');

			if (!isRootObject && meta.textures[this.uuid] !== undefined) {
				return meta.textures[this.uuid];
			}

			const output = {

				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON',
				},

				uuid: this.uuid,
				name: this.name,

				mapping: this.mapping,

				repeat: [this.repeat.x, this.repeat.y],
				offset: [this.offset.x, this.offset.y],
				center: [this.center.x, this.center.y],
				rotation: this.rotation,

				wrap: [this.wrapS, this.wrapT],

				format: this.format,
				type: this.type,
				encoding: this.encoding,

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,

				flipY: this.flipY,

				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment,

			};

			if (this.image !== undefined) {
				// TODO: Move to THREE.Image

				const { image } = this;

				if (image.uuid === undefined) {
					image.uuid = _Math.generateUUID(); // UGH
				}

				if (!isRootObject && meta.images[image.uuid] === undefined) {
					let url;

					if (Array.isArray(image)) {
						// process array of images e.g. CubeTexture

						url = [];

						for (let i = 0, l = image.length; i < l; i++) {
							url.push(ImageUtils.getDataURL(image[i]));
						}
					} else {
						// process single image

						url = ImageUtils.getDataURL(image);
					}

					meta.images[image.uuid] = {
						uuid: image.uuid,
						url,
					};
				}

				output.image = image.uuid;
			}

			if (!isRootObject) {
				meta.textures[this.uuid] = output;
			}

			return output;
		},

		dispose() {
			this.dispatchEvent({ type: 'dispose' });
		},

		transformUv(uv) {
			if (this.mapping !== UVMapping) return uv;

			uv.applyMatrix3(this.matrix);

			if (uv.x < 0 || uv.x > 1) {
				switch (this.wrapS) {
				case RepeatWrapping:

					uv.x -= Math.floor(uv.x);
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if (Math.abs(Math.floor(uv.x) % 2) === 1) {
						uv.x = Math.ceil(uv.x) - uv.x;
					} else {
						uv.x -= Math.floor(uv.x);
					}
					break;
				}
			}

			if (uv.y < 0 || uv.y > 1) {
				switch (this.wrapT) {
				case RepeatWrapping:

					uv.y -= Math.floor(uv.y);
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if (Math.abs(Math.floor(uv.y) % 2) === 1) {
						uv.y = Math.ceil(uv.y) - uv.y;
					} else {
						uv.y -= Math.floor(uv.y);
					}
					break;
				}
			}

			if (this.flipY) {
				uv.y = 1 - uv.y;
			}

			return uv;
		},

	});

	Object.defineProperty(Texture.prototype, 'needsUpdate', {

		set(value) {
			if (value === true) this.version++;
		},

	});

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Vector4(x, y, z, w) {
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = (w !== undefined) ? w : 1;
	}

	Object.assign(Vector4.prototype, {

		isVector4: true,

		set(x, y, z, w) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;
		},

		setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;
		},

		setX(x) {
			this.x = x;

			return this;
		},

		setY(y) {
			this.y = y;

			return this;
		},

		setZ(z) {
			this.z = z;

			return this;
		},

		setW(w) {
			this.w = w;

			return this;
		},

		setComponent(index, value) {
			switch (index) {
			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error(`index is out of range: ${index}`);
			}

			return this;
		},

		getComponent(index) {
			switch (index) {
			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error(`index is out of range: ${index}`);
			}
		},

		clone() {
			return new this.constructor(this.x, this.y, this.z, this.w);
		},

		copy(v) {
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = (v.w !== undefined) ? v.w : 1;

			return this;
		},

		add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;
		},

		addScalar(s) {
			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;
		},

		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;
		},

		addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;
		},

		sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;
		},

		subScalar(s) {
			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;
		},

		subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;
		},

		multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;
		},

		applyMatrix4(m) {
			const { x } = this;
			const { y } = this;
			const { z } = this;
			const { w } = this;
			const e = m.elements;

			this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
			this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
			this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
			this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;

			return this;
		},

		divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		},

		setAxisAngleFromQuaternion(q) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos(q.w);

			const s = Math.sqrt(1 - q.w * q.w);

			if (s < 0.0001) {
				this.x = 1;
				this.y = 0;
				this.z = 0;
			} else {
				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;
			}

			return this;
		},

		setAxisAngleFromRotationMatrix(m) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			let angle; let x; let y; let z;		// variables for result
			const epsilon = 0.01;		// margin to allow for rounding errors
			const epsilon2 = 0.1;		// margin to distinguish between 0 and 180 degrees

			const te = m.elements;

			const m11 = te[0]; const m12 = te[4]; const m13 = te[8];
			const m21 = te[1]; const m22 = te[5]; const m23 = te[9];
			const m31 = te[2]; const m32 = te[6]; const
				m33 = te[10];

			if ((Math.abs(m12 - m21) < epsilon)
			     && (Math.abs(m13 - m31) < epsilon)
			     && (Math.abs(m23 - m32) < epsilon)) {
				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ((Math.abs(m12 + m21) < epsilon2)
				     && (Math.abs(m13 + m31) < epsilon2)
				     && (Math.abs(m23 + m32) < epsilon2)
				     && (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {
					// this singularity is identity matrix so angle = 0

					this.set(1, 0, 0, 0);

					return this; // zero angle, arbitrary axis
				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				const xx = (m11 + 1) / 2;
				const yy = (m22 + 1) / 2;
				const zz = (m33 + 1) / 2;
				const xy = (m12 + m21) / 4;
				const xz = (m13 + m31) / 4;
				const yz = (m23 + m32) / 4;

				if ((xx > yy) && (xx > zz)) {
					// m11 is the largest diagonal term

					if (xx < epsilon) {
						x = 0;
						y = 0.707106781;
						z = 0.707106781;
					} else {
						x = Math.sqrt(xx);
						y = xy / x;
						z = xz / x;
					}
				} else if (yy > zz) {
					// m22 is the largest diagonal term

					if (yy < epsilon) {
						x = 0.707106781;
						y = 0;
						z = 0.707106781;
					} else {
						y = Math.sqrt(yy);
						x = xy / y;
						z = yz / y;
					}
				} else {
					// m33 is the largest diagonal term so base result on this

					if (zz < epsilon) {
						x = 0.707106781;
						y = 0.707106781;
						z = 0;
					} else {
						z = Math.sqrt(zz);
						x = xz / z;
						y = yz / z;
					}
				}

				this.set(x, y, z, angle);

				return this; // return 180 deg rotation
			}

			// as we have reached here there are no singularities so we can handle normally

			let s = Math.sqrt((m32 - m23) * (m32 - m23)
			                   + (m13 - m31) * (m13 - m31)
			                   + (m21 - m12) * (m21 - m12)); // used to normalize

			if (Math.abs(s) < 0.001) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = (m32 - m23) / s;
			this.y = (m13 - m31) / s;
			this.z = (m21 - m12) / s;
			this.w = Math.acos((m11 + m22 + m33 - 1) / 2);

			return this;
		},

		min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			this.z = Math.min(this.z, v.z);
			this.w = Math.min(this.w, v.w);

			return this;
		},

		max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			this.z = Math.max(this.z, v.z);
			this.w = Math.max(this.w, v.w);

			return this;
		},

		clamp(min, max) {
			// assumes min < max, componentwise

			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			this.z = Math.max(min.z, Math.min(max.z, this.z));
			this.w = Math.max(min.w, Math.min(max.w, this.w));

			return this;
		},

		clampScalar: (function () {
			let min; let
				max;

			return function clampScalar(minVal, maxVal) {
				if (min === undefined) {
					min = new Vector4();
					max = new Vector4();
				}

				min.set(minVal, minVal, minVal, minVal);
				max.set(maxVal, maxVal, maxVal, maxVal);

				return this.clamp(min, max);
			};
		}()),

		clampLength(min, max) {
			const length = this.length();

			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		},

		floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			this.w = Math.floor(this.w);

			return this;
		},

		ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			this.w = Math.ceil(this.w);

			return this;
		},

		round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			this.w = Math.round(this.w);

			return this;
		},

		roundToZero() {
			this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
			this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);

			return this;
		},

		negate() {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;
			this.w = -this.w;

			return this;
		},

		dot(v) {
			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
		},

		lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		},

		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		},

		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
		},

		normalize() {
			return this.divideScalar(this.length() || 1);
		},

		setLength(length) {
			return this.normalize().multiplyScalar(length);
		},

		lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			this.z += (v.z - this.z) * alpha;
			this.w += (v.w - this.w) * alpha;

			return this;
		},

		lerpVectors(v1, v2, alpha) {
			return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
		},

		equals(v) {
			return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));
		},

		fromArray(array, offset) {
			if (offset === undefined) offset = 0;

			this.x = array[offset];
			this.y = array[offset + 1];
			this.z = array[offset + 2];
			this.w = array[offset + 3];

			return this;
		},

		toArray(array, offset) {
			if (array === undefined) array = [];
			if (offset === undefined) offset = 0;

			array[offset] = this.x;
			array[offset + 1] = this.y;
			array[offset + 2] = this.z;
			array[offset + 3] = this.w;

			return array;
		},

		fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			this.z = attribute.getZ(index);
			this.w = attribute.getW(index);

			return this;
		},

	});

	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 * @author Marius Kintel / https://github.com/kintel
	 */

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	function WebGLRenderTarget(width, height, options) {
		this.width = width;
		this.height = height;

		this.scissor = new Vector4(0, 0, width, height);
		this.scissorTest = false;

		this.viewport = new Vector4(0, 0, width, height);

		options = options || {};

		this.texture = new Texture(undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
	}

	WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {

		constructor: WebGLRenderTarget,

		isWebGLRenderTarget: true,

		setSize(width, height) {
			if (this.width !== width || this.height !== height) {
				this.width = width;
				this.height = height;

				this.dispose();
			}

			this.viewport.set(0, 0, width, height);
			this.scissor.set(0, 0, width, height);
		},

		clone() {
			return new this.constructor().copy(this);
		},

		copy(source) {
			this.width = source.width;
			this.height = source.height;

			this.viewport.copy(source.viewport);

			this.texture = source.texture.clone();

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;

			return this;
		},

		dispose() {
			this.dispatchEvent({ type: 'dispose' });
		},

	});

	/**
	 * @author alteredq / http://alteredqualia.com
	 */

	function WebGLRenderTargetCube(width, height, options) {
		WebGLRenderTarget.call(this, width, height, options);

		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
		this.activeMipMapLevel = 0;
	}

	WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype);
	WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

	WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
		Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

		this.image = { data, width, height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;
	}

	DataTexture.prototype = Object.create(Texture.prototype);
	DataTexture.prototype.constructor = DataTexture;

	DataTexture.prototype.isDataTexture = true;

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Box3(min, max) {
		this.min = (min !== undefined) ? min : new Vector3(+Infinity, +Infinity, +Infinity);
		this.max = (max !== undefined) ? max : new Vector3(-Infinity, -Infinity, -Infinity);
	}

	Object.assign(Box3.prototype, {

		isBox3: true,

		set(min, max) {
			this.min.copy(min);
			this.max.copy(max);

			return this;
		},

		setFromArray(array) {
			let minX = +Infinity;
			let minY = +Infinity;
			let minZ = +Infinity;

			let maxX = -Infinity;
			let maxY = -Infinity;
			let maxZ = -Infinity;

			for (let i = 0, l = array.length; i < l; i += 3) {
				const x = array[i];
				const y = array[i + 1];
				const z = array[i + 2];

				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (z < minZ) minZ = z;

				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
				if (z > maxZ) maxZ = z;
			}

			this.min.set(minX, minY, minZ);
			this.max.set(maxX, maxY, maxZ);

			return this;
		},

		setFromBufferAttribute(attribute) {
			let minX = +Infinity;
			let minY = +Infinity;
			let minZ = +Infinity;

			let maxX = -Infinity;
			let maxY = -Infinity;
			let maxZ = -Infinity;

			for (let i = 0, l = attribute.count; i < l; i++) {
				const x = attribute.getX(i);
				const y = attribute.getY(i);
				const z = attribute.getZ(i);

				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (z < minZ) minZ = z;

				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
				if (z > maxZ) maxZ = z;
			}

			this.min.set(minX, minY, minZ);
			this.max.set(maxX, maxY, maxZ);

			return this;
		},

		setFromPoints(points) {
			this.makeEmpty();

			for (let i = 0, il = points.length; i < il; i++) {
				this.expandByPoint(points[i]);
			}

			return this;
		},

		setFromCenterAndSize: (function () {
			const v1 = new Vector3();

			return function setFromCenterAndSize(center, size) {
				const halfSize = v1.copy(size).multiplyScalar(0.5);

				this.min.copy(center).sub(halfSize);
				this.max.copy(center).add(halfSize);

				return this;
			};
		}()),

		setFromObject(object) {
			this.makeEmpty();

			return this.expandByObject(object);
		},

		clone() {
			return new this.constructor().copy(this);
		},

		copy(box) {
			this.min.copy(box.min);
			this.max.copy(box.max);

			return this;
		},

		makeEmpty() {
			this.min.x = this.min.y = this.min.z = +Infinity;
			this.max.x = this.max.y = this.max.z = -Infinity;

			return this;
		},

		isEmpty() {
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);
		},

		getCenter(target) {
			if (target === undefined) {
				console.warn('THREE.Box3: .getCenter() target is now required');
				target = new Vector3();
			}

			return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
		},

		getSize(target) {
			if (target === undefined) {
				console.warn('THREE.Box3: .getSize() target is now required');
				target = new Vector3();
			}

			return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
		},

		expandByPoint(point) {
			this.min.min(point);
			this.max.max(point);

			return this;
		},

		expandByVector(vector) {
			this.min.sub(vector);
			this.max.add(vector);

			return this;
		},

		expandByScalar(scalar) {
			this.min.addScalar(-scalar);
			this.max.addScalar(scalar);

			return this;
		},

		expandByObject: (function () {
			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			let scope; let i; let
				l;

			const v1 = new Vector3();

			function traverse(node) {
				const { geometry } = node;

				if (geometry !== undefined) {
					if (geometry.isGeometry) {
						const { vertices } = geometry;

						for (i = 0, l = vertices.length; i < l; i++) {
							v1.copy(vertices[i]);
							v1.applyMatrix4(node.matrixWorld);

							scope.expandByPoint(v1);
						}
					} else if (geometry.isBufferGeometry) {
						const attribute = geometry.attributes.position;

						if (attribute !== undefined) {
							for (i = 0, l = attribute.count; i < l; i++) {
								v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);

								scope.expandByPoint(v1);
							}
						}
					}
				}
			}

			return function expandByObject(object) {
				scope = this;

				object.updateMatrixWorld(true);

				object.traverse(traverse);

				return this;
			};
		}()),

		containsPoint(point) {
			return !(point.x < this.min.x || point.x > this.max.x
				|| point.y < this.min.y || point.y > this.max.y
				|| point.z < this.min.z || point.z > this.max.z);
		},

		containsBox(box) {
			return this.min.x <= box.min.x && box.max.x <= this.max.x
				&& this.min.y <= box.min.y && box.max.y <= this.max.y
				&& this.min.z <= box.min.z && box.max.z <= this.max.z;
		},

		getParameter(point, target) {
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			if (target === undefined) {
				console.warn('THREE.Box3: .getParameter() target is now required');
				target = new Vector3();
			}

			return target.set(
				(point.x - this.min.x) / (this.max.x - this.min.x),
				(point.y - this.min.y) / (this.max.y - this.min.y),
				(point.z - this.min.z) / (this.max.z - this.min.z),
			);
		},

		intersectsBox(box) {
			// using 6 splitting planes to rule out intersections.
			return !(box.max.x < this.min.x || box.min.x > this.max.x
				|| box.max.y < this.min.y || box.min.y > this.max.y
				|| box.max.z < this.min.z || box.min.z > this.max.z);
		},

		intersectsSphere: (function () {
			const closestPoint = new Vector3();

			return function intersectsSphere(sphere) {
				// Find the point on the AABB closest to the sphere center.
				this.clampPoint(sphere.center, closestPoint);

				// If that point is inside the sphere, the AABB and sphere intersect.
				return closestPoint.distanceToSquared(sphere.center) <= (sphere.radius * sphere.radius);
			};
		}()),

		intersectsPlane(plane) {
			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.

			let min; let
				max;

			if (plane.normal.x > 0) {
				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;
			} else {
				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;
			}

			if (plane.normal.y > 0) {
				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;
			} else {
				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;
			}

			if (plane.normal.z > 0) {
				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;
			} else {
				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;
			}

			return (min <= -plane.constant && max >= -plane.constant);
		},

		intersectsTriangle: (function () {
			// triangle centered vertices
			const v0 = new Vector3();
			const v1 = new Vector3();
			const v2 = new Vector3();

			// triangle edge vectors
			const f0 = new Vector3();
			const f1 = new Vector3();
			const f2 = new Vector3();

			const testAxis = new Vector3();

			const center = new Vector3();
			const extents = new Vector3();

			const triangleNormal = new Vector3();

			function satForAxes(axes) {
				let i; let
					j;

				for (i = 0, j = axes.length - 3; i <= j; i += 3) {
					testAxis.fromArray(axes, i);
					// project the aabb onto the seperating axis
					const r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z);
					// project all 3 vertices of the triangle onto the seperating axis
					const p0 = v0.dot(testAxis);
					const p1 = v1.dot(testAxis);
					const p2 = v2.dot(testAxis);
					// actual test, basically see if either of the most extreme of the triangle points intersects r
					if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
						// points of the projected triangle are outside the projected half-length of the aabb
						// the axis is seperating and we can exit
						return false;
					}
				}

				return true;
			}

			return function intersectsTriangle(triangle) {
				if (this.isEmpty()) {
					return false;
				}

				// compute box center and extents
				this.getCenter(center);
				extents.subVectors(this.max, center);

				// translate triangle to aabb origin
				v0.subVectors(triangle.a, center);
				v1.subVectors(triangle.b, center);
				v2.subVectors(triangle.c, center);

				// compute edge vectors for triangle
				f0.subVectors(v1, v0);
				f1.subVectors(v2, v1);
				f2.subVectors(v0, v2);

				// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
				// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
				// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
				let axes = [
					0, -f0.z, f0.y, 0, -f1.z, f1.y, 0, -f2.z, f2.y,
					f0.z, 0, -f0.x, f1.z, 0, -f1.x, f2.z, 0, -f2.x,
					-f0.y, f0.x, 0, -f1.y, f1.x, 0, -f2.y, f2.x, 0,
				];
				if (!satForAxes(axes)) {
					return false;
				}

				// test 3 face normals from the aabb
				axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
				if (!satForAxes(axes)) {
					return false;
				}

				// finally testing the face normal of the triangle
				// use already existing triangle edge vectors here
				triangleNormal.crossVectors(f0, f1);
				axes = [triangleNormal.x, triangleNormal.y, triangleNormal.z];
				return satForAxes(axes);
			};
		}()),

		clampPoint(point, target) {
			if (target === undefined) {
				console.warn('THREE.Box3: .clampPoint() target is now required');
				target = new Vector3();
			}

			return target.copy(point).clamp(this.min, this.max);
		},

		distanceToPoint: (function () {
			const v1 = new Vector3();

			return function distanceToPoint(point) {
				const clampedPoint = v1.copy(point).clamp(this.min, this.max);
				return clampedPoint.sub(point).length();
			};
		}()),

		getBoundingSphere: (function () {
			const v1 = new Vector3();

			return function getBoundingSphere(target) {
				if (target === undefined) {
					console.warn('THREE.Box3: .getBoundingSphere() target is now required');
					target = new Sphere();
				}

				this.getCenter(target.center);

				target.radius = this.getSize(v1).length() * 0.5;

				return target;
			};
		}()),

		intersect(box) {
			this.min.max(box.min);
			this.max.min(box.max);

			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if (this.isEmpty()) this.makeEmpty();

			return this;
		},

		union(box) {
			this.min.min(box.min);
			this.max.max(box.max);

			return this;
		},

		applyMatrix4: (function () {
			const points = [
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
			];

			return function applyMatrix4(matrix) {
				// transform of empty box is an empty box.
				if (this.isEmpty()) return this;

				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
				points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
				points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
				points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
				points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
				points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
				points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
				points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111

				this.setFromPoints(points);

				return this;
			};
		}()),

		translate(offset) {
			this.min.add(offset);
			this.max.add(offset);

			return this;
		},

		equals(box) {
			return box.min.equals(this.min) && box.max.equals(this.max);
		},

	});

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Sphere(center, radius) {
		this.center = (center !== undefined) ? center : new Vector3();
		this.radius = (radius !== undefined) ? radius : 0;
	}

	Object.assign(Sphere.prototype, {

		set(center, radius) {
			this.center.copy(center);
			this.radius = radius;

			return this;
		},

		setFromPoints: (function () {
			const box = new Box3();

			return function setFromPoints(points, optionalCenter) {
				const { center } = this;

				if (optionalCenter !== undefined) {
					center.copy(optionalCenter);
				} else {
					box.setFromPoints(points).getCenter(center);
				}

				let maxRadiusSq = 0;

				for (let i = 0, il = points.length; i < il; i++) {
					maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
				}

				this.radius = Math.sqrt(maxRadiusSq);

				return this;
			};
		}()),

		clone() {
			return new this.constructor().copy(this);
		},

		copy(sphere) {
			this.center.copy(sphere.center);
			this.radius = sphere.radius;

			return this;
		},

		empty() {
			return (this.radius <= 0);
		},

		containsPoint(point) {
			return (point.distanceToSquared(this.center) <= (this.radius * this.radius));
		},

		distanceToPoint(point) {
			return (point.distanceTo(this.center) - this.radius);
		},

		intersectsSphere(sphere) {
			const radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);
		},

		intersectsBox(box) {
			return box.intersectsSphere(this);
		},

		intersectsPlane(plane) {
			return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
		},

		clampPoint(point, target) {
			const deltaLengthSq = this.center.distanceToSquared(point);

			if (target === undefined) {
				console.warn('THREE.Sphere: .clampPoint() target is now required');
				target = new Vector3();
			}

			target.copy(point);

			if (deltaLengthSq > (this.radius * this.radius)) {
				target.sub(this.center).normalize();
				target.multiplyScalar(this.radius).add(this.center);
			}

			return target;
		},

		getBoundingBox(target) {
			if (target === undefined) {
				console.warn('THREE.Sphere: .getBoundingBox() target is now required');
				target = new Box3();
			}

			target.set(this.center, this.center);
			target.expandByScalar(this.radius);

			return target;
		},

		applyMatrix4(matrix) {
			this.center.applyMatrix4(matrix);
			this.radius *= matrix.getMaxScaleOnAxis();

			return this;
		},

		translate(offset) {
			this.center.add(offset);

			return this;
		},

		equals(sphere) {
			return sphere.center.equals(this.center) && (sphere.radius === this.radius);
		},

	});

	/**
	 * @author bhouston / http://clara.io
	 */

	function Plane(normal, constant) {
		// normal is assumed to be normalized

		this.normal = (normal !== undefined) ? normal : new Vector3(1, 0, 0);
		this.constant = (constant !== undefined) ? constant : 0;
	}

	Object.assign(Plane.prototype, {

		set(normal, constant) {
			this.normal.copy(normal);
			this.constant = constant;

			return this;
		},

		setComponents(x, y, z, w) {
			this.normal.set(x, y, z);
			this.constant = w;

			return this;
		},

		setFromNormalAndCoplanarPoint(normal, point) {
			this.normal.copy(normal);
			this.constant = -point.dot(this.normal);

			return this;
		},

		setFromCoplanarPoints: (function () {
			const v1 = new Vector3();
			const v2 = new Vector3();

			return function setFromCoplanarPoints(a, b, c) {
				const normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();

				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

				this.setFromNormalAndCoplanarPoint(normal, a);

				return this;
			};
		}()),

		clone() {
			return new this.constructor().copy(this);
		},

		copy(plane) {
			this.normal.copy(plane.normal);
			this.constant = plane.constant;

			return this;
		},

		normalize() {
			// Note: will lead to a divide by zero if the plane is invalid.

			const inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar(inverseNormalLength);
			this.constant *= inverseNormalLength;

			return this;
		},

		negate() {
			this.constant *= -1;
			this.normal.negate();

			return this;
		},

		distanceToPoint(point) {
			return this.normal.dot(point) + this.constant;
		},

		distanceToSphere(sphere) {
			return this.distanceToPoint(sphere.center) - sphere.radius;
		},

		projectPoint(point, target) {
			if (target === undefined) {
				console.warn('THREE.Plane: .projectPoint() target is now required');
				target = new Vector3();
			}

			return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
		},

		intersectLine: (function () {
			const v1 = new Vector3();

			return function intersectLine(line, target) {
				if (target === undefined) {
					console.warn('THREE.Plane: .intersectLine() target is now required');
					target = new Vector3();
				}

				const direction = line.delta(v1);

				const denominator = this.normal.dot(direction);

				if (denominator === 0) {
					// line is coplanar, return origin
					if (this.distanceToPoint(line.start) === 0) {
						return target.copy(line.start);
					}

					// Unsure if this is the correct method to handle this case.
					return undefined;
				}

				const t = -(line.start.dot(this.normal) + this.constant) / denominator;

				if (t < 0 || t > 1) {
					return undefined;
				}

				return target.copy(direction).multiplyScalar(t).add(line.start);
			};
		}()),

		intersectsLine(line) {
			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			const startSign = this.distanceToPoint(line.start);
			const endSign = this.distanceToPoint(line.end);

			return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
		},

		intersectsBox(box) {
			return box.intersectsPlane(this);
		},

		intersectsSphere(sphere) {
			return sphere.intersectsPlane(this);
		},

		coplanarPoint(target) {
			if (target === undefined) {
				console.warn('THREE.Plane: .coplanarPoint() target is now required');
				target = new Vector3();
			}

			return target.copy(this.normal).multiplyScalar(-this.constant);
		},

		applyMatrix4: (function () {
			const v1 = new Vector3();
			const m1 = new Matrix3();

			return function applyMatrix4(matrix, optionalNormalMatrix) {
				const normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);

				const referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);

				const normal = this.normal.applyMatrix3(normalMatrix).normalize();

				this.constant = -referencePoint.dot(normal);

				return this;
			};
		}()),

		translate(offset) {
			this.constant -= offset.dot(this.normal);

			return this;
		},

		equals(plane) {
			return plane.normal.equals(this.normal) && (plane.constant === this.constant);
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://clara.io
	 */

	function Frustum(p0, p1, p2, p3, p4, p5) {
		this.planes = [

			(p0 !== undefined) ? p0 : new Plane(),
			(p1 !== undefined) ? p1 : new Plane(),
			(p2 !== undefined) ? p2 : new Plane(),
			(p3 !== undefined) ? p3 : new Plane(),
			(p4 !== undefined) ? p4 : new Plane(),
			(p5 !== undefined) ? p5 : new Plane(),

		];
	}

	Object.assign(Frustum.prototype, {

		set(p0, p1, p2, p3, p4, p5) {
			const { planes } = this;

			planes[0].copy(p0);
			planes[1].copy(p1);
			planes[2].copy(p2);
			planes[3].copy(p3);
			planes[4].copy(p4);
			planes[5].copy(p5);

			return this;
		},

		clone() {
			return new this.constructor().copy(this);
		},

		copy(frustum) {
			const { planes } = this;

			for (let i = 0; i < 6; i++) {
				planes[i].copy(frustum.planes[i]);
			}

			return this;
		},

		setFromMatrix(m) {
			const { planes } = this;
			const me = m.elements;
			const me0 = me[0]; const me1 = me[1]; const me2 = me[2]; const
				me3 = me[3];
			const me4 = me[4]; const me5 = me[5]; const me6 = me[6]; const
				me7 = me[7];
			const me8 = me[8]; const me9 = me[9]; const me10 = me[10]; const
				me11 = me[11];
			const me12 = me[12]; const me13 = me[13]; const me14 = me[14]; const
				me15 = me[15];

			planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
			planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
			planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
			planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
			planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
			planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();

			return this;
		},

		intersectsObject: (function () {
			const sphere = new Sphere();

			return function intersectsObject(object) {
				const { geometry } = object;

				if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

				sphere.copy(geometry.boundingSphere)
					.applyMatrix4(object.matrixWorld);

				return this.intersectsSphere(sphere);
			};
		}()),

		intersectsSprite: (function () {
			const sphere = new Sphere();

			return function intersectsSprite(sprite) {
				sphere.center.set(0, 0, 0);
				sphere.radius = 0.7071067811865476;
				sphere.applyMatrix4(sprite.matrixWorld);

				return this.intersectsSphere(sphere);
			};
		}()),

		intersectsSphere(sphere) {
			const { planes } = this;
			const { center } = sphere;
			const negRadius = -sphere.radius;

			for (let i = 0; i < 6; i++) {
				const distance = planes[i].distanceToPoint(center);

				if (distance < negRadius) {
					return false;
				}
			}

			return true;
		},

		intersectsBox: (function () {
			const p = new Vector3();

			return function intersectsBox(box) {
				const { planes } = this;

				for (let i = 0; i < 6; i++) {
					const plane = planes[i];

					// corner at max distance

					p.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p.z = plane.normal.z > 0 ? box.max.z : box.min.z;

					if (plane.distanceToPoint(p) < 0) {
						return false;
					}
				}

				return true;
			};
		}()),

		containsPoint(point) {
			const { planes } = this;

			for (let i = 0; i < 6; i++) {
				if (planes[i].distanceToPoint(point) < 0) {
					return false;
				}
			}

			return true;
		},

	});

	const alphamap_fragment = '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif';

	const alphamap_pars_fragment = '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif';

	const alphatest_fragment = '#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif';

	const aomap_fragment = '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif';

	const aomap_pars_fragment = '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif';

	const begin_vertex = 'vec3 transformed = vec3( position );';

	const beginnormal_vertex = 'vec3 objectNormal = vec3( normal );';

	const bsdfs = 'float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}';

	const bumpmap_pars_fragment = '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif';

	const clipping_planes_fragment = '#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif';

	const clipping_planes_pars_fragment = '#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif';

	const clipping_planes_pars_vertex = '#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif';

	const clipping_planes_vertex = '#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif';

	const color_fragment = '#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif';

	const color_pars_fragment = '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif';

	const color_pars_vertex = '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif';

	const color_vertex = '#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif';

	const common = '#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}';

	const cube_uv_reflection_fragment = '#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif';

	const defaultnormal_vertex = 'vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif';

	const displacementmap_pars_vertex = '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif';

	const displacementmap_vertex = '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif';

	const emissivemap_fragment = '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif';

	const emissivemap_pars_fragment = '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif';

	const encodings_fragment = 'gl_FragColor = linearToOutputTexel( gl_FragColor );';

	const encodings_pars_fragment = '\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}';

	const envmap_fragment = '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif';

	const envmap_pars_fragment = '#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif';

	const envmap_pars_vertex = '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif';

	const envmap_vertex = '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif';

	const fog_vertex = '#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif';

	const fog_pars_vertex = '#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif';

	const fog_fragment = '#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif';

	const fog_pars_fragment = '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif';

	const gradientmap_pars_fragment = '#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif';

	const lightmap_fragment = '#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif';

	const lightmap_pars_fragment = '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif';

	const lights_lambert_vertex = 'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif';

	const lights_pars_begin = 'uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif';

	const envmap_physical_pars_fragment = '#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif';

	const lights_phong_fragment = 'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;';

	const lights_phong_pars_fragment = 'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)';

	const lights_physical_fragment = 'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif';

	const lights_physical_pars_fragment = 'struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}';

	const lights_fragment_begin = '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif';

	const lights_fragment_maps = '#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif';

	const lights_fragment_end = '#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif';

	const logdepthbuf_fragment = '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif';

	const logdepthbuf_pars_fragment = '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif';

	const logdepthbuf_pars_vertex = '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif';

	const logdepthbuf_vertex = '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif';

	const map_fragment = '#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif';

	const map_pars_fragment = '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif';

	const map_particle_fragment = '#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif';

	const map_particle_pars_fragment = '#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif';

	const metalnessmap_fragment = 'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif';

	const metalnessmap_pars_fragment = '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif';

	const morphnormal_vertex = '#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif';

	const morphtarget_pars_vertex = '#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif';

	const morphtarget_vertex = '#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif';

	const normal_fragment_begin = '#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif';

	const normal_fragment_maps = '#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif';

	const normalmap_pars_fragment = '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif';

	const packing = 'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}';

	const premultiplied_alpha_fragment = '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif';

	const project_vertex = 'vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;';

	const dithering_fragment = '#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif';

	const dithering_pars_fragment = '#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif';

	const roughnessmap_fragment = 'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif';

	const roughnessmap_pars_fragment = '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif';

	const shadowmap_pars_fragment = '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif';

	const shadowmap_pars_vertex = '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif';

	const shadowmap_vertex = '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif';

	const shadowmask_pars_fragment = 'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}';

	const skinbase_vertex = '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif';

	const skinning_pars_vertex = '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif';

	const skinning_vertex = '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif';

	const skinnormal_vertex = '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif';

	const specularmap_fragment = 'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif';

	const specularmap_pars_fragment = '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif';

	const tonemapping_fragment = '#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif';

	const tonemapping_pars_fragment = '#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}';

	const uv_pars_fragment = '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif';

	const uv_pars_vertex = '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif';

	const uv_vertex = '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif';

	const uv2_pars_fragment = '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif';

	const uv2_pars_vertex = '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif';

	const uv2_vertex = '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif';

	const worldpos_vertex = '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif';

	const background_frag = 'uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}';

	const background_vert = 'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}';

	const cube_frag = 'uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}';

	const cube_vert = 'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}';

	const depth_frag = '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}';

	const depth_vert = '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}';

	const distanceRGBA_frag = '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}';

	const distanceRGBA_vert = '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}';

	const equirect_frag = 'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}';

	const equirect_vert = 'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}';

	const linedashed_frag = 'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}';

	const linedashed_vert = 'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}';

	const meshbasic_frag = 'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}';

	const meshbasic_vert = '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}';

	const meshlambert_frag = 'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}';

	const meshlambert_vert = '#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}';

	const meshmatcap_frag = '#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}';

	const meshmatcap_vert = '#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}';

	const meshphong_frag = '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}';

	const meshphong_vert = '#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}';

	const meshphysical_frag = '#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}';

	const meshphysical_vert = '#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}';

	const normal_frag = '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}';

	const normal_vert = '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}';

	const points_frag = 'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}';

	const points_vert = 'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}';

	const shadow_frag = 'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}';

	const shadow_vert = '#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}';

	const sprite_frag = 'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}';

	const sprite_vert = 'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}';

	const ShaderChunk = {
		alphamap_fragment,
		alphamap_pars_fragment,
		alphatest_fragment,
		aomap_fragment,
		aomap_pars_fragment,
		begin_vertex,
		beginnormal_vertex,
		bsdfs,
		bumpmap_pars_fragment,
		clipping_planes_fragment,
		clipping_planes_pars_fragment,
		clipping_planes_pars_vertex,
		clipping_planes_vertex,
		color_fragment,
		color_pars_fragment,
		color_pars_vertex,
		color_vertex,
		common,
		cube_uv_reflection_fragment,
		defaultnormal_vertex,
		displacementmap_pars_vertex,
		displacementmap_vertex,
		emissivemap_fragment,
		emissivemap_pars_fragment,
		encodings_fragment,
		encodings_pars_fragment,
		envmap_fragment,
		envmap_pars_fragment,
		envmap_pars_vertex,
		envmap_physical_pars_fragment,
		envmap_vertex,
		fog_vertex,
		fog_pars_vertex,
		fog_fragment,
		fog_pars_fragment,
		gradientmap_pars_fragment,
		lightmap_fragment,
		lightmap_pars_fragment,
		lights_lambert_vertex,
		lights_pars_begin,
		lights_phong_fragment,
		lights_phong_pars_fragment,
		lights_physical_fragment,
		lights_physical_pars_fragment,
		lights_fragment_begin,
		lights_fragment_maps,
		lights_fragment_end,
		logdepthbuf_fragment,
		logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex,
		logdepthbuf_vertex,
		map_fragment,
		map_pars_fragment,
		map_particle_fragment,
		map_particle_pars_fragment,
		metalnessmap_fragment,
		metalnessmap_pars_fragment,
		morphnormal_vertex,
		morphtarget_pars_vertex,
		morphtarget_vertex,
		normal_fragment_begin,
		normal_fragment_maps,
		normalmap_pars_fragment,
		packing,
		premultiplied_alpha_fragment,
		project_vertex,
		dithering_fragment,
		dithering_pars_fragment,
		roughnessmap_fragment,
		roughnessmap_pars_fragment,
		shadowmap_pars_fragment,
		shadowmap_pars_vertex,
		shadowmap_vertex,
		shadowmask_pars_fragment,
		skinbase_vertex,
		skinning_pars_vertex,
		skinning_vertex,
		skinnormal_vertex,
		specularmap_fragment,
		specularmap_pars_fragment,
		tonemapping_fragment,
		tonemapping_pars_fragment,
		uv_pars_fragment,
		uv_pars_vertex,
		uv_vertex,
		uv2_pars_fragment,
		uv2_pars_vertex,
		uv2_vertex,
		worldpos_vertex,

		background_frag,
		background_vert,
		cube_frag,
		cube_vert,
		depth_frag,
		depth_vert,
		distanceRGBA_frag,
		distanceRGBA_vert,
		equirect_frag,
		equirect_vert,
		linedashed_frag,
		linedashed_vert,
		meshbasic_frag,
		meshbasic_vert,
		meshlambert_frag,
		meshlambert_vert,
		meshmatcap_frag,
		meshmatcap_vert,
		meshphong_frag,
		meshphong_vert,
		meshphysical_frag,
		meshphysical_vert,
		normal_frag,
		normal_vert,
		points_frag,
		points_vert,
		shadow_frag,
		shadow_vert,
		sprite_frag,
		sprite_vert,
	};

	/**
	 * Uniform Utilities
	 */

	function cloneUniforms(src) {
		const dst = {};

		for (const u in src) {
			dst[u] = {};

			for (const p in src[u]) {
				const property = src[u][p];

				if (property && (property.isColor
					|| property.isMatrix3 || property.isMatrix4
					|| property.isVector2 || property.isVector3 || property.isVector4
					|| property.isTexture)) {
					dst[u][p] = property.clone();
				} else if (Array.isArray(property)) {
					dst[u][p] = property.slice();
				} else {
					dst[u][p] = property;
				}
			}
		}

		return dst;
	}

	function mergeUniforms(uniforms) {
		const merged = {};

		for (let u = 0; u < uniforms.length; u++) {
			const tmp = cloneUniforms(uniforms[u]);

			for (const p in tmp) {
				merged[p] = tmp[p];
			}
		}

		return merged;
	}

	// Legacy

	const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	const ColorKeywords = {
		aliceblue: 0xF0F8FF,
		antiquewhite: 0xFAEBD7,
		aqua: 0x00FFFF,
		aquamarine: 0x7FFFD4,
		azure: 0xF0FFFF,
		beige: 0xF5F5DC,
		bisque: 0xFFE4C4,
		black: 0x000000,
		blanchedalmond: 0xFFEBCD,
		blue: 0x0000FF,
		blueviolet: 0x8A2BE2,
		brown: 0xA52A2A,
		burlywood: 0xDEB887,
		cadetblue: 0x5F9EA0,
		chartreuse: 0x7FFF00,
		chocolate: 0xD2691E,
		coral: 0xFF7F50,
		cornflowerblue: 0x6495ED,
		cornsilk: 0xFFF8DC,
		crimson: 0xDC143C,
		cyan: 0x00FFFF,
		darkblue: 0x00008B,
		darkcyan: 0x008B8B,
		darkgoldenrod: 0xB8860B,
		darkgray: 0xA9A9A9,
		darkgreen: 0x006400,
		darkgrey: 0xA9A9A9,
		darkkhaki: 0xBDB76B,
		darkmagenta: 0x8B008B,
		darkolivegreen: 0x556B2F,
		darkorange: 0xFF8C00,
		darkorchid: 0x9932CC,
		darkred: 0x8B0000,
		darksalmon: 0xE9967A,
		darkseagreen: 0x8FBC8F,
		darkslateblue: 0x483D8B,
		darkslategray: 0x2F4F4F,
		darkslategrey: 0x2F4F4F,
		darkturquoise: 0x00CED1,
		darkviolet: 0x9400D3,
		deeppink: 0xFF1493,
		deepskyblue: 0x00BFFF,
		dimgray: 0x696969,
		dimgrey: 0x696969,
		dodgerblue: 0x1E90FF,
		firebrick: 0xB22222,
		floralwhite: 0xFFFAF0,
		forestgreen: 0x228B22,
		fuchsia: 0xFF00FF,
		gainsboro: 0xDCDCDC,
		ghostwhite: 0xF8F8FF,
		gold: 0xFFD700,
		goldenrod: 0xDAA520,
		gray: 0x808080,
		green: 0x008000,
		greenyellow: 0xADFF2F,
		grey: 0x808080,
		honeydew: 0xF0FFF0,
		hotpink: 0xFF69B4,
		indianred: 0xCD5C5C,
		indigo: 0x4B0082,
		ivory: 0xFFFFF0,
		khaki: 0xF0E68C,
		lavender: 0xE6E6FA,
		lavenderblush: 0xFFF0F5,
		lawngreen: 0x7CFC00,
		lemonchiffon: 0xFFFACD,
		lightblue: 0xADD8E6,
		lightcoral: 0xF08080,
		lightcyan: 0xE0FFFF,
		lightgoldenrodyellow: 0xFAFAD2,
		lightgray: 0xD3D3D3,
		lightgreen: 0x90EE90,
		lightgrey: 0xD3D3D3,
		lightpink: 0xFFB6C1,
		lightsalmon: 0xFFA07A,
		lightseagreen: 0x20B2AA,
		lightskyblue: 0x87CEFA,
		lightslategray: 0x778899,
		lightslategrey: 0x778899,
		lightsteelblue: 0xB0C4DE,
		lightyellow: 0xFFFFE0,
		lime: 0x00FF00,
		limegreen: 0x32CD32,
		linen: 0xFAF0E6,
		magenta: 0xFF00FF,
		maroon: 0x800000,
		mediumaquamarine: 0x66CDAA,
		mediumblue: 0x0000CD,
		mediumorchid: 0xBA55D3,
		mediumpurple: 0x9370DB,
		mediumseagreen: 0x3CB371,
		mediumslateblue: 0x7B68EE,
		mediumspringgreen: 0x00FA9A,
		mediumturquoise: 0x48D1CC,
		mediumvioletred: 0xC71585,
		midnightblue: 0x191970,
		mintcream: 0xF5FFFA,
		mistyrose: 0xFFE4E1,
		moccasin: 0xFFE4B5,
		navajowhite: 0xFFDEAD,
		navy: 0x000080,
		oldlace: 0xFDF5E6,
		olive: 0x808000,
		olivedrab: 0x6B8E23,
		orange: 0xFFA500,
		orangered: 0xFF4500,
		orchid: 0xDA70D6,
		palegoldenrod: 0xEEE8AA,
		palegreen: 0x98FB98,
		paleturquoise: 0xAFEEEE,
		palevioletred: 0xDB7093,
		papayawhip: 0xFFEFD5,
		peachpuff: 0xFFDAB9,
		peru: 0xCD853F,
		pink: 0xFFC0CB,
		plum: 0xDDA0DD,
		powderblue: 0xB0E0E6,
		purple: 0x800080,
		rebeccapurple: 0x663399,
		red: 0xFF0000,
		rosybrown: 0xBC8F8F,
		royalblue: 0x4169E1,
		saddlebrown: 0x8B4513,
		salmon: 0xFA8072,
		sandybrown: 0xF4A460,
		seagreen: 0x2E8B57,
		seashell: 0xFFF5EE,
		sienna: 0xA0522D,
		silver: 0xC0C0C0,
		skyblue: 0x87CEEB,
		slateblue: 0x6A5ACD,
		slategray: 0x708090,
		slategrey: 0x708090,
		snow: 0xFFFAFA,
		springgreen: 0x00FF7F,
		steelblue: 0x4682B4,
		tan: 0xD2B48C,
		teal: 0x008080,
		thistle: 0xD8BFD8,
		tomato: 0xFF6347,
		turquoise: 0x40E0D0,
		violet: 0xEE82EE,
		wheat: 0xF5DEB3,
		white: 0xFFFFFF,
		whitesmoke: 0xF5F5F5,
		yellow: 0xFFFF00,
		yellowgreen: 0x9ACD32,
	};

	function Color(r, g, b) {
		if (g === undefined && b === undefined) {
			// r is THREE.Color, hex or string
			return this.set(r);
		}

		return this.setRGB(r, g, b);
	}

	Object.assign(Color.prototype, {

		isColor: true,

		r: 1,
		g: 1,
		b: 1,

		set(value) {
			if (value && value.isColor) {
				this.copy(value);
			} else if (typeof value === 'number') {
				this.setHex(value);
			} else if (typeof value === 'string') {
				this.setStyle(value);
			}

			return this;
		},

		setScalar(scalar) {
			this.r = scalar;
			this.g = scalar;
			this.b = scalar;

			return this;
		},

		setHex(hex) {
			hex = Math.floor(hex);

			this.r = (hex >> 16 & 255) / 255;
			this.g = (hex >> 8 & 255) / 255;
			this.b = (hex & 255) / 255;

			return this;
		},

		setRGB(r, g, b) {
			this.r = r;
			this.g = g;
			this.b = b;

			return this;
		},

		setHSL: (function () {
			function hue2rgb(p, q, t) {
				if (t < 0) t += 1;
				if (t > 1) t -= 1;
				if (t < 1 / 6) return p + (q - p) * 6 * t;
				if (t < 1 / 2) return q;
				if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
				return p;
			}

			return function setHSL(h, s, l) {
				// h,s,l ranges are in 0.0 - 1.0
				h = _Math.euclideanModulo(h, 1);
				s = _Math.clamp(s, 0, 1);
				l = _Math.clamp(l, 0, 1);

				if (s === 0) {
					this.r = this.g = this.b = l;
				} else {
					const p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
					const q = (2 * l) - p;

					this.r = hue2rgb(q, p, h + 1 / 3);
					this.g = hue2rgb(q, p, h);
					this.b = hue2rgb(q, p, h - 1 / 3);
				}

				return this;
			};
		}()),

		setStyle(style) {
			function handleAlpha(string) {
				if (string === undefined) return;

				if (parseFloat(string) < 1) {
					console.warn(`THREE.Color: Alpha component of ${style} will be ignored.`);
				}
			}


			let m;

			if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
				// rgb / hsl

				let color;
				const name = m[1];
				const components = m[2];

				switch (name) {
				case 'rgb':
				case 'rgba':

					if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min(255, parseInt(color[1], 10)) / 255;
						this.g = Math.min(255, parseInt(color[2], 10)) / 255;
						this.b = Math.min(255, parseInt(color[3], 10)) / 255;

						handleAlpha(color[5]);

						return this;
					}

					if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min(100, parseInt(color[1], 10)) / 100;
						this.g = Math.min(100, parseInt(color[2], 10)) / 100;
						this.b = Math.min(100, parseInt(color[3], 10)) / 100;

						handleAlpha(color[5]);

						return this;
					}

					break;

				case 'hsl':
				case 'hsla':

					if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						const h = parseFloat(color[1]) / 360;
						const s = parseInt(color[2], 10) / 100;
						const l = parseInt(color[3], 10) / 100;

						handleAlpha(color[5]);

						return this.setHSL(h, s, l);
					}

					break;
				}
			} else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
				// hex color

				var hex = m[1];
				const size = hex.length;

				if (size === 3) {
					// #ff0
					this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
					this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
					this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;

					return this;
				} if (size === 6) {
					// #ff0000
					this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
					this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
					this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;

					return this;
				}
			}

			if (style && style.length > 0) {
				// color keywords
				var hex = ColorKeywords[style];

				if (hex !== undefined) {
					// red
					this.setHex(hex);
				} else {
					// unknown color
					console.warn(`THREE.Color: Unknown color ${style}`);
				}
			}

			return this;
		},

		clone() {
			return new this.constructor(this.r, this.g, this.b);
		},

		copy(color) {
			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;
		},

		copyGammaToLinear(color, gammaFactor) {
			if (gammaFactor === undefined) gammaFactor = 2.0;

			this.r = Math.pow(color.r, gammaFactor);
			this.g = Math.pow(color.g, gammaFactor);
			this.b = Math.pow(color.b, gammaFactor);

			return this;
		},

		copyLinearToGamma(color, gammaFactor) {
			if (gammaFactor === undefined) gammaFactor = 2.0;

			const safeInverse = (gammaFactor > 0) ? (1.0 / gammaFactor) : 1.0;

			this.r = Math.pow(color.r, safeInverse);
			this.g = Math.pow(color.g, safeInverse);
			this.b = Math.pow(color.b, safeInverse);

			return this;
		},

		convertGammaToLinear(gammaFactor) {
			this.copyGammaToLinear(this, gammaFactor);

			return this;
		},

		convertLinearToGamma(gammaFactor) {
			this.copyLinearToGamma(this, gammaFactor);

			return this;
		},

		copySRGBToLinear: (function () {
			function SRGBToLinear(c) {
				return (c < 0.04045) ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
			}

			return function copySRGBToLinear(color) {
				this.r = SRGBToLinear(color.r);
				this.g = SRGBToLinear(color.g);
				this.b = SRGBToLinear(color.b);

				return this;
			};
		}()),

		copyLinearToSRGB: (function () {
			function LinearToSRGB(c) {
				return (c < 0.0031308) ? c * 12.92 : 1.055 * (Math.pow(c, 0.41666)) - 0.055;
			}

			return function copyLinearToSRGB(color) {
				this.r = LinearToSRGB(color.r);
				this.g = LinearToSRGB(color.g);
				this.b = LinearToSRGB(color.b);

				return this;
			};
		}()),

		convertSRGBToLinear() {
			this.copySRGBToLinear(this);

			return this;
		},

		convertLinearToSRGB() {
			this.copyLinearToSRGB(this);

			return this;
		},

		getHex() {
			return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;
		},

		getHexString() {
			return (`000000${this.getHex().toString(16)}`).slice(-6);
		},

		getHSL(target) {
			// h,s,l ranges are in 0.0 - 1.0

			if (target === undefined) {
				console.warn('THREE.Color: .getHSL() target is now required');
				target = { h: 0, s: 0, l: 0 };
			}

			const { r } = this;
			const { g } = this;
			const { b } = this;

			const max = Math.max(r, g, b);
			const min = Math.min(r, g, b);

			let hue; let
				saturation;
			const lightness = (min + max) / 2.0;

			if (min === max) {
				hue = 0;
				saturation = 0;
			} else {
				const delta = max - min;

				saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

				switch (max) {
				case r: hue = (g - b) / delta + (g < b ? 6 : 0); break;
				case g: hue = (b - r) / delta + 2; break;
				case b: hue = (r - g) / delta + 4; break;
				}

				hue /= 6;
			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;

			return target;
		},

		getStyle() {
			return `rgb(${(this.r * 255) | 0},${(this.g * 255) | 0},${(this.b * 255) | 0})`;
		},

		offsetHSL: (function () {
			const hsl = {};

			return function (h, s, l) {
				this.getHSL(hsl);

				hsl.h += h; hsl.s += s; hsl.l += l;

				this.setHSL(hsl.h, hsl.s, hsl.l);

				return this;
			};
		}()),

		add(color) {
			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;
		},

		addColors(color1, color2) {
			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;
		},

		addScalar(s) {
			this.r += s;
			this.g += s;
			this.b += s;

			return this;
		},

		sub(color) {
			this.r = Math.max(0, this.r - color.r);
			this.g = Math.max(0, this.g - color.g);
			this.b = Math.max(0, this.b - color.b);

			return this;
		},

		multiply(color) {
			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;
		},

		multiplyScalar(s) {
			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;
		},

		lerp(color, alpha) {
			this.r += (color.r - this.r) * alpha;
			this.g += (color.g - this.g) * alpha;
			this.b += (color.b - this.b) * alpha;

			return this;
		},

		lerpHSL: (function () {
			const hslA = { h: 0, s: 0, l: 0 };
			const hslB = { h: 0, s: 0, l: 0 };

			return function lerpHSL(color, alpha) {
				this.getHSL(hslA);
				color.getHSL(hslB);

				const h = _Math.lerp(hslA.h, hslB.h, alpha);
				const s = _Math.lerp(hslA.s, hslB.s, alpha);
				const l = _Math.lerp(hslA.l, hslB.l, alpha);

				this.setHSL(h, s, l);

				return this;
			};
		}()),

		equals(c) {
			return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);
		},

		fromArray(array, offset) {
			if (offset === undefined) offset = 0;

			this.r = array[offset];
			this.g = array[offset + 1];
			this.b = array[offset + 2];

			return this;
		},

		toArray(array, offset) {
			if (array === undefined) array = [];
			if (offset === undefined) offset = 0;

			array[offset] = this.r;
			array[offset + 1] = this.g;
			array[offset + 2] = this.b;

			return array;
		},

		toJSON() {
			return this.getHex();
		},

	});

	/**
	 * Uniforms library for shared webgl shaders
	 */

	const UniformsLib = {

		common: {

			diffuse: { value: new Color(0xeeeeee) },
			opacity: { value: 1.0 },

			map: { value: null },
			uvTransform: { value: new Matrix3() },

			alphaMap: { value: null },

		},

		specularmap: {

			specularMap: { value: null },

		},

		envmap: {

			envMap: { value: null },
			flipEnvMap: { value: -1 },
			reflectivity: { value: 1.0 },
			refractionRatio: { value: 0.98 },
			maxMipLevel: { value: 0 },

		},

		aomap: {

			aoMap: { value: null },
			aoMapIntensity: { value: 1 },

		},

		lightmap: {

			lightMap: { value: null },
			lightMapIntensity: { value: 1 },

		},

		emissivemap: {

			emissiveMap: { value: null },

		},

		bumpmap: {

			bumpMap: { value: null },
			bumpScale: { value: 1 },

		},

		normalmap: {

			normalMap: { value: null },
			normalScale: { value: new Vector2(1, 1) },

		},

		displacementmap: {

			displacementMap: { value: null },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 },

		},

		roughnessmap: {

			roughnessMap: { value: null },

		},

		metalnessmap: {

			metalnessMap: { value: null },

		},

		gradientmap: {

			gradientMap: { value: null },

		},

		fog: {

			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: new Color(0xffffff) },

		},

		lights: {

			ambientLightColor: { value: [] },

			directionalLights: {
				value: [],
				properties: {
					direction: {},
					color: {},

					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {},
				},
			},

			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },

			spotLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {},

					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {},
				},
			},

			spotShadowMap: { value: [] },
			spotShadowMatrix: { value: [] },

			pointLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					decay: {},
					distance: {},

					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowCameraNear: {},
					shadowCameraFar: {},
				},
			},

			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },

			hemisphereLights: {
				value: [],
				properties: {
					direction: {},
					skyColor: {},
					groundColor: {},
				},
			},

			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					width: {},
					height: {},
				},
			},

		},

		points: {

			diffuse: { value: new Color(0xeeeeee) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			uvTransform: { value: new Matrix3() },

		},

		sprite: {

			diffuse: { value: new Color(0xeeeeee) },
			opacity: { value: 1.0 },
			center: { value: new Vector2(0.5, 0.5) },
			rotation: { value: 0.0 },
			map: { value: null },
			uvTransform: { value: new Matrix3() },

		},

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */

	const ShaderLib = {

		basic: {

			uniforms: mergeUniforms([
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog,
			]),

			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag,

		},

		lambert: {

			uniforms: mergeUniforms([
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color(0x000000) },
				},
			]),

			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag,

		},

		phong: {

			uniforms: mergeUniforms([
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color(0x000000) },
					specular: { value: new Color(0x111111) },
					shininess: { value: 30 },
				},
			]),

			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag,

		},

		standard: {

			uniforms: mergeUniforms([
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color(0x000000) },
					roughness: { value: 0.5 },
					metalness: { value: 0.5 },
					envMapIntensity: { value: 1 }, // temporary
				},
			]),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag,

		},

		matcap: {

			uniforms: mergeUniforms([
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				{
					matcap: { value: null },
				},
			]),

			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag,

		},

		points: {

			uniforms: mergeUniforms([
				UniformsLib.points,
				UniformsLib.fog,
			]),

			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag,

		},

		dashed: {

			uniforms: mergeUniforms([
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 },
				},
			]),

			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag,

		},

		depth: {

			uniforms: mergeUniforms([
				UniformsLib.common,
				UniformsLib.displacementmap,
			]),

			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag,

		},

		normal: {

			uniforms: mergeUniforms([
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 },
				},
			]),

			vertexShader: ShaderChunk.normal_vert,
			fragmentShader: ShaderChunk.normal_frag,

		},

		sprite: {

			uniforms: mergeUniforms([
				UniformsLib.sprite,
				UniformsLib.fog,
			]),

			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag,

		},

		background: {

			uniforms: {
				uvTransform: { value: new Matrix3() },
				t2D: { value: null },
			},

			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag,

		},
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		cube: {

			uniforms: {
				tCube: { value: null },
				tFlip: { value: -1 },
				opacity: { value: 1.0 },
			},

			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag,

		},

		equirect: {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag,

		},

		distanceRGBA: {

			uniforms: mergeUniforms([
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 },
				},
			]),

			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag,

		},

		shadow: {

			uniforms: mergeUniforms([
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: new Color(0x00000) },
					opacity: { value: 1.0 },
				},
			]),

			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag,

		},

	};

	ShaderLib.physical = {

		uniforms: mergeUniforms([
			ShaderLib.standard.uniforms,
			{
				clearCoat: { value: 0 },
				clearCoatRoughness: { value: 0 },
			},
		]),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag,

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLAnimation() {
		let context = null;
		let isAnimating = false;
		let animationLoop = null;

		function onAnimationFrame(time, frame) {
			if (isAnimating === false) return;

			animationLoop(time, frame);

			context.requestAnimationFrame(onAnimationFrame);
		}

		return {

			start() {
				if (isAnimating === true) return;
				if (animationLoop === null) return;

				context.requestAnimationFrame(onAnimationFrame);

				isAnimating = true;
			},

			stop() {
				isAnimating = false;
			},

			setAnimationLoop(callback) {
				animationLoop = callback;
			},

			setContext(value) {
				context = value;
			},

		};
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLAttributes(gl) {
		const buffers = new WeakMap();

		function createBuffer(attribute, bufferType) {
			const { array } = attribute;
			const usage = attribute.dynamic ? 35048 : 35044;

			const buffer = gl.createBuffer();

			gl.bindBuffer(bufferType, buffer);
			gl.bufferData(bufferType, array, usage);

			attribute.onUploadCallback();

			let type = 5126;

			if (array instanceof Float32Array) {
				type = 5126;
			} else if (array instanceof Float64Array) {
				console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
			} else if (array instanceof Uint16Array) {
				type = 5123;
			} else if (array instanceof Int16Array) {
				type = 5122;
			} else if (array instanceof Uint32Array) {
				type = 5125;
			} else if (array instanceof Int32Array) {
				type = 5124;
			} else if (array instanceof Int8Array) {
				type = 5120;
			} else if (array instanceof Uint8Array) {
				type = 5121;
			}

			return {
				buffer,
				type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version,
			};
		}

		function updateBuffer(buffer, attribute, bufferType) {
			const { array } = attribute;
			const { updateRange } = attribute;

			gl.bindBuffer(bufferType, buffer);

			if (attribute.dynamic === false) {
				gl.bufferData(bufferType, array, 35044);
			} else if (updateRange.count === -1) {
				// Not using update ranges

				gl.bufferSubData(bufferType, 0, array);
			} else if (updateRange.count === 0) {
				console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');
			} else {
				gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray(updateRange.offset, updateRange.offset + updateRange.count));

				updateRange.count = -1; // reset range
			}
		}

		//

		function get(attribute) {
			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;

			return buffers.get(attribute);
		}

		function remove(attribute) {
			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;

			const data = buffers.get(attribute);

			if (data) {
				gl.deleteBuffer(data.buffer);

				buffers.delete(attribute);
			}
		}

		function update(attribute, bufferType) {
			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;

			const data = buffers.get(attribute);

			if (data === undefined) {
				buffers.set(attribute, createBuffer(attribute, bufferType));
			} else if (data.version < attribute.version) {
				updateBuffer(data.buffer, attribute, bufferType);

				data.version = attribute.version;
			}
		}

		return {

			get,
			remove,
			update,

		};
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Face3(a, b, c, normal, color, materialIndex) {
		this.a = a;
		this.b = b;
		this.c = c;

		this.normal = (normal && normal.isVector3) ? normal : new Vector3();
		this.vertexNormals = Array.isArray(normal) ? normal : [];

		this.color = (color && color.isColor) ? color : new Color();
		this.vertexColors = Array.isArray(color) ? color : [];

		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
	}

	Object.assign(Face3.prototype, {

		clone() {
			return new this.constructor().copy(this);
		},

		copy(source) {
			this.a = source.a;
			this.b = source.b;
			this.c = source.c;

			this.normal.copy(source.normal);
			this.color.copy(source.color);

			this.materialIndex = source.materialIndex;

			for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
				this.vertexNormals[i] = source.vertexNormals[i].clone();
			}

			for (var i = 0, il = source.vertexColors.length; i < il; i++) {
				this.vertexColors[i] = source.vertexColors[i].clone();
			}

			return this;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	function Euler(x, y, z, order) {
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || Euler.DefaultOrder;
	}

	Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];

	Euler.DefaultOrder = 'XYZ';

	Object.defineProperties(Euler.prototype, {

		x: {

			get() {
				return this._x;
			},

			set(value) {
				this._x = value;
				this.onChangeCallback();
			},

		},

		y: {

			get() {
				return this._y;
			},

			set(value) {
				this._y = value;
				this.onChangeCallback();
			},

		},

		z: {

			get() {
				return this._z;
			},

			set(value) {
				this._z = value;
				this.onChangeCallback();
			},

		},

		order: {

			get() {
				return this._order;
			},

			set(value) {
				this._order = value;
				this.onChangeCallback();
			},

		},

	});

	Object.assign(Euler.prototype, {

		isEuler: true,

		set(x, y, z, order) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this.onChangeCallback();

			return this;
		},

		clone() {
			return new this.constructor(this._x, this._y, this._z, this._order);
		},

		copy(euler) {
			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this.onChangeCallback();

			return this;
		},

		setFromRotationMatrix(m, order, update) {
			const { clamp } = _Math;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			const te = m.elements;
			const m11 = te[0]; const m12 = te[4]; const
				m13 = te[8];
			const m21 = te[1]; const m22 = te[5]; const
				m23 = te[9];
			const m31 = te[2]; const m32 = te[6]; const
				m33 = te[10];

			order = order || this._order;

			if (order === 'XYZ') {
				this._y = Math.asin(clamp(m13, -1, 1));

				if (Math.abs(m13) < 0.99999) {
					this._x = Math.atan2(-m23, m33);
					this._z = Math.atan2(-m12, m11);
				} else {
					this._x = Math.atan2(m32, m22);
					this._z = 0;
				}
			} else if (order === 'YXZ') {
				this._x = Math.asin(-clamp(m23, -1, 1));

				if (Math.abs(m23) < 0.99999) {
					this._y = Math.atan2(m13, m33);
					this._z = Math.atan2(m21, m22);
				} else {
					this._y = Math.atan2(-m31, m11);
					this._z = 0;
				}
			} else if (order === 'ZXY') {
				this._x = Math.asin(clamp(m32, -1, 1));

				if (Math.abs(m32) < 0.99999) {
					this._y = Math.atan2(-m31, m33);
					this._z = Math.atan2(-m12, m22);
				} else {
					this._y = 0;
					this._z = Math.atan2(m21, m11);
				}
			} else if (order === 'ZYX') {
				this._y = Math.asin(-clamp(m31, -1, 1));

				if (Math.abs(m31) < 0.99999) {
					this._x = Math.atan2(m32, m33);
					this._z = Math.atan2(m21, m11);
				} else {
					this._x = 0;
					this._z = Math.atan2(-m12, m22);
				}
			} else if (order === 'YZX') {
				this._z = Math.asin(clamp(m21, -1, 1));

				if (Math.abs(m21) < 0.99999) {
					this._x = Math.atan2(-m23, m22);
					this._y = Math.atan2(-m31, m11);
				} else {
					this._x = 0;
					this._y = Math.atan2(m13, m33);
				}
			} else if (order === 'XZY') {
				this._z = Math.asin(-clamp(m12, -1, 1));

				if (Math.abs(m12) < 0.99999) {
					this._x = Math.atan2(m32, m22);
					this._y = Math.atan2(m13, m11);
				} else {
					this._x = Math.atan2(-m23, m33);
					this._y = 0;
				}
			} else {
				console.warn(`THREE.Euler: .setFromRotationMatrix() given unsupported order: ${order}`);
			}

			this._order = order;

			if (update !== false) this.onChangeCallback();

			return this;
		},

		setFromQuaternion: (function () {
			const matrix = new Matrix4();

			return function setFromQuaternion(q, order, update) {
				matrix.makeRotationFromQuaternion(q);

				return this.setFromRotationMatrix(matrix, order, update);
			};
		}()),

		setFromVector3(v, order) {
			return this.set(v.x, v.y, v.z, order || this._order);
		},

		reorder: (function () {
			// WARNING: this discards revolution information -bhouston

			const q = new Quaternion();

			return function reorder(newOrder) {
				q.setFromEuler(this);

				return this.setFromQuaternion(q, newOrder);
			};
		}()),

		equals(euler) {
			return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);
		},

		fromArray(array) {
			this._x = array[0];
			this._y = array[1];
			this._z = array[2];
			if (array[3] !== undefined) this._order = array[3];

			this.onChangeCallback();

			return this;
		},

		toArray(array, offset) {
			if (array === undefined) array = [];
			if (offset === undefined) offset = 0;

			array[offset] = this._x;
			array[offset + 1] = this._y;
			array[offset + 2] = this._z;
			array[offset + 3] = this._order;

			return array;
		},

		toVector3(optionalResult) {
			if (optionalResult) {
				return optionalResult.set(this._x, this._y, this._z);
			}
			return new Vector3(this._x, this._y, this._z);
		},

		onChange(callback) {
			this.onChangeCallback = callback;

			return this;
		},

		onChangeCallback() {},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Layers() {
		this.mask = 1 | 0;
	}

	Object.assign(Layers.prototype, {

		set(channel) {
			this.mask = 1 << channel | 0;
		},

		enable(channel) {
			this.mask |= 1 << channel | 0;
		},

		toggle(channel) {
			this.mask ^= 1 << channel | 0;
		},

		disable(channel) {
			this.mask &= ~(1 << channel | 0);
		},

		test(layers) {
			return (this.mask & layers.mask) !== 0;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */

	let object3DId = 0;

	function Object3D() {
		Object.defineProperty(this, 'id', { value: object3DId++ });

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DefaultUp.clone();

		const position = new Vector3();
		const rotation = new Euler();
		const quaternion = new Quaternion();
		const scale = new Vector3(1, 1, 1);

		function onRotationChange() {
			quaternion.setFromEuler(rotation, false);
		}

		function onQuaternionChange() {
			rotation.setFromQuaternion(quaternion, undefined, false);
		}

		rotation.onChange(onRotationChange);
		quaternion.onChange(onQuaternionChange);

		Object.defineProperties(this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position,
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation,
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion,
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale,
			},
			modelViewMatrix: {
				value: new Matrix4(),
			},
			normalMatrix: {
				value: new Matrix3(),
			},
		});

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.userData = {};
	}

	Object3D.DefaultUp = new Vector3(0, 1, 0);
	Object3D.DefaultMatrixAutoUpdate = true;

	Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {

		constructor: Object3D,

		isObject3D: true,

		onBeforeRender() {},
		onAfterRender() {},

		applyMatrix(matrix) {
			this.matrix.multiplyMatrices(matrix, this.matrix);

			this.matrix.decompose(this.position, this.quaternion, this.scale);
		},

		applyQuaternion(q) {
			this.quaternion.premultiply(q);

			return this;
		},

		setRotationFromAxisAngle(axis, angle) {
			// assumes axis is normalized

			this.quaternion.setFromAxisAngle(axis, angle);
		},

		setRotationFromEuler(euler) {
			this.quaternion.setFromEuler(euler, true);
		},

		setRotationFromMatrix(m) {
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix(m);
		},

		setRotationFromQuaternion(q) {
			// assumes q is normalized

			this.quaternion.copy(q);
		},

		rotateOnAxis: (function () {
			// rotate object on axis in object space
			// axis is assumed to be normalized

			const q1 = new Quaternion();

			return function rotateOnAxis(axis, angle) {
				q1.setFromAxisAngle(axis, angle);

				this.quaternion.multiply(q1);

				return this;
			};
		}()),

		rotateOnWorldAxis: (function () {
			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent

			const q1 = new Quaternion();

			return function rotateOnWorldAxis(axis, angle) {
				q1.setFromAxisAngle(axis, angle);

				this.quaternion.premultiply(q1);

				return this;
			};
		}()),

		rotateX: (function () {
			const v1 = new Vector3(1, 0, 0);

			return function rotateX(angle) {
				return this.rotateOnAxis(v1, angle);
			};
		}()),

		rotateY: (function () {
			const v1 = new Vector3(0, 1, 0);

			return function rotateY(angle) {
				return this.rotateOnAxis(v1, angle);
			};
		}()),

		rotateZ: (function () {
			const v1 = new Vector3(0, 0, 1);

			return function rotateZ(angle) {
				return this.rotateOnAxis(v1, angle);
			};
		}()),

		translateOnAxis: (function () {
			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			const v1 = new Vector3();

			return function translateOnAxis(axis, distance) {
				v1.copy(axis).applyQuaternion(this.quaternion);

				this.position.add(v1.multiplyScalar(distance));

				return this;
			};
		}()),

		translateX: (function () {
			const v1 = new Vector3(1, 0, 0);

			return function translateX(distance) {
				return this.translateOnAxis(v1, distance);
			};
		}()),

		translateY: (function () {
			const v1 = new Vector3(0, 1, 0);

			return function translateY(distance) {
				return this.translateOnAxis(v1, distance);
			};
		}()),

		translateZ: (function () {
			const v1 = new Vector3(0, 0, 1);

			return function translateZ(distance) {
				return this.translateOnAxis(v1, distance);
			};
		}()),

		localToWorld(vector) {
			return vector.applyMatrix4(this.matrixWorld);
		},

		worldToLocal: (function () {
			const m1 = new Matrix4();

			return function worldToLocal(vector) {
				return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
			};
		}()),

		lookAt: (function () {
			// This method does not support objects having non-uniformly-scaled parent(s)

			const q1 = new Quaternion();
			const m1 = new Matrix4();
			const target = new Vector3();
			const position = new Vector3();

			return function lookAt(x, y, z) {
				if (x.isVector3) {
					target.copy(x);
				} else {
					target.set(x, y, z);
				}

				const { parent } = this;

				this.updateWorldMatrix(true, false);

				position.setFromMatrixPosition(this.matrixWorld);

				if (this.isCamera || this.isLight) {
					m1.lookAt(position, target, this.up);
				} else {
					m1.lookAt(target, position, this.up);
				}

				this.quaternion.setFromRotationMatrix(m1);

				if (parent) {
					m1.extractRotation(parent.matrixWorld);
					q1.setFromRotationMatrix(m1);
					this.quaternion.premultiply(q1.inverse());
				}
			};
		}()),

		add(object) {
			if (arguments.length > 1) {
				for (let i = 0; i < arguments.length; i++) {
					this.add(arguments[i]);
				}

				return this;
			}

			if (object === this) {
				console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
				return this;
			}

			if ((object && object.isObject3D)) {
				if (object.parent !== null) {
					object.parent.remove(object);
				}

				object.parent = this;
				object.dispatchEvent({ type: 'added' });

				this.children.push(object);
			} else {
				console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
			}

			return this;
		},

		remove(object) {
			if (arguments.length > 1) {
				for (let i = 0; i < arguments.length; i++) {
					this.remove(arguments[i]);
				}

				return this;
			}

			const index = this.children.indexOf(object);

			if (index !== -1) {
				object.parent = null;

				object.dispatchEvent({ type: 'removed' });

				this.children.splice(index, 1);
			}

			return this;
		},

		getObjectById(id) {
			return this.getObjectByProperty('id', id);
		},

		getObjectByName(name) {
			return this.getObjectByProperty('name', name);
		},

		getObjectByProperty(name, value) {
			if (this[name] === value) return this;

			for (let i = 0, l = this.children.length; i < l; i++) {
				const child = this.children[i];
				const object = child.getObjectByProperty(name, value);

				if (object !== undefined) {
					return object;
				}
			}

			return undefined;
		},

		getWorldPosition(target) {
			if (target === undefined) {
				console.warn('THREE.Object3D: .getWorldPosition() target is now required');
				target = new Vector3();
			}

			this.updateMatrixWorld(true);

			return target.setFromMatrixPosition(this.matrixWorld);
		},

		getWorldQuaternion: (function () {
			const position = new Vector3();
			const scale = new Vector3();

			return function getWorldQuaternion(target) {
				if (target === undefined) {
					console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
					target = new Quaternion();
				}

				this.updateMatrixWorld(true);

				this.matrixWorld.decompose(position, target, scale);

				return target;
			};
		}()),

		getWorldScale: (function () {
			const position = new Vector3();
			const quaternion = new Quaternion();

			return function getWorldScale(target) {
				if (target === undefined) {
					console.warn('THREE.Object3D: .getWorldScale() target is now required');
					target = new Vector3();
				}

				this.updateMatrixWorld(true);

				this.matrixWorld.decompose(position, quaternion, target);

				return target;
			};
		}()),

		getWorldDirection(target) {
			if (target === undefined) {
				console.warn('THREE.Object3D: .getWorldDirection() target is now required');
				target = new Vector3();
			}

			this.updateMatrixWorld(true);

			const e = this.matrixWorld.elements;

			return target.set(e[8], e[9], e[10]).normalize();
		},

		raycast() {},

		traverse(callback) {
			callback(this);

			const { children } = this;

			for (let i = 0, l = children.length; i < l; i++) {
				children[i].traverse(callback);
			}
		},

		traverseVisible(callback) {
			if (this.visible === false) return;

			callback(this);

			const { children } = this;

			for (let i = 0, l = children.length; i < l; i++) {
				children[i].traverseVisible(callback);
			}
		},

		traverseAncestors(callback) {
			const { parent } = this;

			if (parent !== null) {
				callback(parent);

				parent.traverseAncestors(callback);
			}
		},

		updateMatrix() {
			this.matrix.compose(this.position, this.quaternion, this.scale);

			this.matrixWorldNeedsUpdate = true;
		},

		updateMatrixWorld(force) {
			if (this.matrixAutoUpdate) this.updateMatrix();

			if (this.matrixWorldNeedsUpdate || force) {
				if (this.parent === null) {
					this.matrixWorld.copy(this.matrix);
				} else {
					this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
				}

				this.matrixWorldNeedsUpdate = false;

				force = true;
			}

			// update children

			const { children } = this;

			for (let i = 0, l = children.length; i < l; i++) {
				children[i].updateMatrixWorld(force);
			}
		},

		updateWorldMatrix(updateParents, updateChildren) {
			const { parent } = this;

			if (updateParents === true && parent !== null) {
				parent.updateWorldMatrix(true, false);
			}

			if (this.matrixAutoUpdate) this.updateMatrix();

			if (this.parent === null) {
				this.matrixWorld.copy(this.matrix);
			} else {
				this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
			}

			// update children

			if (updateChildren === true) {
				const { children } = this;

				for (let i = 0, l = children.length; i < l; i++) {
					children[i].updateWorldMatrix(false, true);
				}
			}
		},

		toJSON(meta) {
			// meta is a string when called from JSON.stringify
			const isRootObject = (meta === undefined || typeof meta === 'string');

			const output = {};

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if (isRootObject) {
				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
				};

				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON',
				};
			}

			// standard Object3D serialization

			const object = {};

			object.uuid = this.uuid;
			object.type = this.type;

			if (this.name !== '') object.name = this.name;
			if (this.castShadow === true) object.castShadow = true;
			if (this.receiveShadow === true) object.receiveShadow = true;
			if (this.visible === false) object.visible = false;
			if (this.frustumCulled === false) object.frustumCulled = false;
			if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
			if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;

			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();

			if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;

			//

			function serialize(library, element) {
				if (library[element.uuid] === undefined) {
					library[element.uuid] = element.toJSON(meta);
				}

				return element.uuid;
			}

			if (this.isMesh || this.isLine || this.isPoints) {
				object.geometry = serialize(meta.geometries, this.geometry);

				const { parameters } = this.geometry;

				if (parameters !== undefined && parameters.shapes !== undefined) {
					var { shapes } = parameters;

					if (Array.isArray(shapes)) {
						for (var i = 0, l = shapes.length; i < l; i++) {
							const shape = shapes[i];

							serialize(meta.shapes, shape);
						}
					} else {
						serialize(meta.shapes, shapes);
					}
				}
			}

			if (this.material !== undefined) {
				if (Array.isArray(this.material)) {
					const uuids = [];

					for (var i = 0, l = this.material.length; i < l; i++) {
						uuids.push(serialize(meta.materials, this.material[i]));
					}

					object.material = uuids;
				} else {
					object.material = serialize(meta.materials, this.material);
				}
			}

			//

			if (this.children.length > 0) {
				object.children = [];

				for (var i = 0; i < this.children.length; i++) {
					object.children.push(this.children[i].toJSON(meta).object);
				}
			}

			if (isRootObject) {
				const geometries = extractFromCache(meta.geometries);
				const materials = extractFromCache(meta.materials);
				const textures = extractFromCache(meta.textures);
				const images = extractFromCache(meta.images);
				var shapes = extractFromCache(meta.shapes);

				if (geometries.length > 0) output.geometries = geometries;
				if (materials.length > 0) output.materials = materials;
				if (textures.length > 0) output.textures = textures;
				if (images.length > 0) output.images = images;
				if (shapes.length > 0) output.shapes = shapes;
			}

			output.object = object;

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache(cache) {
				const values = [];
				for (const key in cache) {
					const data = cache[key];
					delete data.metadata;
					values.push(data);
				}
				return values;
			}
		},

		clone(recursive) {
			return new this.constructor().copy(this, recursive);
		},

		copy(source, recursive) {
			if (recursive === undefined) recursive = true;

			this.name = source.name;

			this.up.copy(source.up);

			this.position.copy(source.position);
			this.quaternion.copy(source.quaternion);
			this.scale.copy(source.scale);

			this.matrix.copy(source.matrix);
			this.matrixWorld.copy(source.matrixWorld);

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.layers.mask = source.layers.mask;
			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.userData = JSON.parse(JSON.stringify(source.userData));

			if (recursive === true) {
				for (let i = 0; i < source.children.length; i++) {
					const child = source.children[i];
					this.add(child.clone());
				}
			}

			return this;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://clara.io
	 */

	let geometryId = 0; // Geometry uses even numbers as Id

	function Geometry() {
		Object.defineProperty(this, 'id', { value: geometryId += 2 });

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Geometry';

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];

		this.morphTargets = [];
		this.morphNormals = [];

		this.skinWeights = [];
		this.skinIndices = [];

		this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.elementsNeedUpdate = false;
		this.verticesNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;
	}

	Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {

		constructor: Geometry,

		isGeometry: true,

		applyMatrix(matrix) {
			const normalMatrix = new Matrix3().getNormalMatrix(matrix);

			for (var i = 0, il = this.vertices.length; i < il; i++) {
				const vertex = this.vertices[i];
				vertex.applyMatrix4(matrix);
			}

			for (var i = 0, il = this.faces.length; i < il; i++) {
				const face = this.faces[i];
				face.normal.applyMatrix3(normalMatrix).normalize();

				for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {
					face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
				}
			}

			if (this.boundingBox !== null) {
				this.computeBoundingBox();
			}

			if (this.boundingSphere !== null) {
				this.computeBoundingSphere();
			}

			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;

			return this;
		},

		rotateX: (function () {
			// rotate geometry around world x-axis

			const m1 = new Matrix4();

			return function rotateX(angle) {
				m1.makeRotationX(angle);

				this.applyMatrix(m1);

				return this;
			};
		}()),

		rotateY: (function () {
			// rotate geometry around world y-axis

			const m1 = new Matrix4();

			return function rotateY(angle) {
				m1.makeRotationY(angle);

				this.applyMatrix(m1);

				return this;
			};
		}()),

		rotateZ: (function () {
			// rotate geometry around world z-axis

			const m1 = new Matrix4();

			return function rotateZ(angle) {
				m1.makeRotationZ(angle);

				this.applyMatrix(m1);

				return this;
			};
		}()),

		translate: (function () {
			// translate geometry

			const m1 = new Matrix4();

			return function translate(x, y, z) {
				m1.makeTranslation(x, y, z);

				this.applyMatrix(m1);

				return this;
			};
		}()),

		scale: (function () {
			// scale geometry

			const m1 = new Matrix4();

			return function scale(x, y, z) {
				m1.makeScale(x, y, z);

				this.applyMatrix(m1);

				return this;
			};
		}()),

		lookAt: (function () {
			const obj = new Object3D();

			return function lookAt(vector) {
				obj.lookAt(vector);

				obj.updateMatrix();

				this.applyMatrix(obj.matrix);
			};
		}()),

		fromBufferGeometry(geometry) {
			const scope = this;

			const indices = geometry.index !== null ? geometry.index.array : undefined;
			const { attributes } = geometry;

			const positions = attributes.position.array;
			const normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			const colors = attributes.color !== undefined ? attributes.color.array : undefined;
			const uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
			const uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

			if (uvs2 !== undefined) this.faceVertexUvs[1] = [];

			for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {
				scope.vertices.push(new Vector3().fromArray(positions, i));

				if (colors !== undefined) {
					scope.colors.push(new Color().fromArray(colors, i));
				}
			}

			function addFace(a, b, c, materialIndex) {
				const vertexColors = (colors === undefined) ? [] : [
					scope.colors[a].clone(),
					scope.colors[b].clone(),
					scope.colors[c].clone()];

				const vertexNormals = (normals === undefined) ? [] : [
					new Vector3().fromArray(normals, a * 3),
					new Vector3().fromArray(normals, b * 3),
					new Vector3().fromArray(normals, c * 3),
				];

				const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);

				scope.faces.push(face);

				if (uvs !== undefined) {
					scope.faceVertexUvs[0].push([
						new Vector2().fromArray(uvs, a * 2),
						new Vector2().fromArray(uvs, b * 2),
						new Vector2().fromArray(uvs, c * 2),
					]);
				}

				if (uvs2 !== undefined) {
					scope.faceVertexUvs[1].push([
						new Vector2().fromArray(uvs2, a * 2),
						new Vector2().fromArray(uvs2, b * 2),
						new Vector2().fromArray(uvs2, c * 2),
					]);
				}
			}

			const { groups } = geometry;

			if (groups.length > 0) {
				for (var i = 0; i < groups.length; i++) {
					const group = groups[i];

					const { start } = group;
					const { count } = group;

					for (var j = start, jl = start + count; j < jl; j += 3) {
						if (indices !== undefined) {
							addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
						} else {
							addFace(j, j + 1, j + 2, group.materialIndex);
						}
					}
				}
			} else if (indices !== undefined) {
				for (var i = 0; i < indices.length; i += 3) {
					addFace(indices[i], indices[i + 1], indices[i + 2]);
				}
			} else {
				for (var i = 0; i < positions.length / 3; i += 3) {
					addFace(i, i + 1, i + 2);
				}
			}

			this.computeFaceNormals();

			if (geometry.boundingBox !== null) {
				this.boundingBox = geometry.boundingBox.clone();
			}

			if (geometry.boundingSphere !== null) {
				this.boundingSphere = geometry.boundingSphere.clone();
			}

			return this;
		},

		center: (function () {
			const offset = new Vector3();

			return function center() {
				this.computeBoundingBox();

				this.boundingBox.getCenter(offset).negate();

				this.translate(offset.x, offset.y, offset.z);

				return this;
			};
		}()),

		normalize() {
			this.computeBoundingSphere();

			const { center } = this.boundingSphere;
			const { radius } = this.boundingSphere;

			const s = radius === 0 ? 1 : 1.0 / radius;

			const matrix = new Matrix4();
			matrix.set(
				s, 0, 0, -s * center.x,
				0, s, 0, -s * center.y,
				0, 0, s, -s * center.z,
				0, 0, 0, 1,
			);

			this.applyMatrix(matrix);

			return this;
		},

		computeFaceNormals() {
			const cb = new Vector3(); const
				ab = new Vector3();

			for (let f = 0, fl = this.faces.length; f < fl; f++) {
				const face = this.faces[f];

				const vA = this.vertices[face.a];
				const vB = this.vertices[face.b];
				const vC = this.vertices[face.c];

				cb.subVectors(vC, vB);
				ab.subVectors(vA, vB);
				cb.cross(ab);

				cb.normalize();

				face.normal.copy(cb);
			}
		},

		computeVertexNormals(areaWeighted) {
			if (areaWeighted === undefined) areaWeighted = true;

			let v; let vl; let f; let fl; let face; let
				vertices;

			vertices = new Array(this.vertices.length);

			for (v = 0, vl = this.vertices.length; v < vl; v++) {
				vertices[v] = new Vector3();
			}

			if (areaWeighted) {
				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm

				let vA; let vB; let
					vC;
				const cb = new Vector3(); const
					ab = new Vector3();

				for (f = 0, fl = this.faces.length; f < fl; f++) {
					face = this.faces[f];

					vA = this.vertices[face.a];
					vB = this.vertices[face.b];
					vC = this.vertices[face.c];

					cb.subVectors(vC, vB);
					ab.subVectors(vA, vB);
					cb.cross(ab);

					vertices[face.a].add(cb);
					vertices[face.b].add(cb);
					vertices[face.c].add(cb);
				}
			} else {
				this.computeFaceNormals();

				for (f = 0, fl = this.faces.length; f < fl; f++) {
					face = this.faces[f];

					vertices[face.a].add(face.normal);
					vertices[face.b].add(face.normal);
					vertices[face.c].add(face.normal);
				}
			}

			for (v = 0, vl = this.vertices.length; v < vl; v++) {
				vertices[v].normalize();
			}

			for (f = 0, fl = this.faces.length; f < fl; f++) {
				face = this.faces[f];

				const { vertexNormals } = face;

				if (vertexNormals.length === 3) {
					vertexNormals[0].copy(vertices[face.a]);
					vertexNormals[1].copy(vertices[face.b]);
					vertexNormals[2].copy(vertices[face.c]);
				} else {
					vertexNormals[0] = vertices[face.a].clone();
					vertexNormals[1] = vertices[face.b].clone();
					vertexNormals[2] = vertices[face.c].clone();
				}
			}

			if (this.faces.length > 0) {
				this.normalsNeedUpdate = true;
			}
		},

		computeFlatVertexNormals() {
			let f; let fl; let
				face;

			this.computeFaceNormals();

			for (f = 0, fl = this.faces.length; f < fl; f++) {
				face = this.faces[f];

				const { vertexNormals } = face;

				if (vertexNormals.length === 3) {
					vertexNormals[0].copy(face.normal);
					vertexNormals[1].copy(face.normal);
					vertexNormals[2].copy(face.normal);
				} else {
					vertexNormals[0] = face.normal.clone();
					vertexNormals[1] = face.normal.clone();
					vertexNormals[2] = face.normal.clone();
				}
			}

			if (this.faces.length > 0) {
				this.normalsNeedUpdate = true;
			}
		},

		computeMorphNormals() {
			let i; let il; let f; let fl; let
				face;

			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)

			for (f = 0, fl = this.faces.length; f < fl; f++) {
				face = this.faces[f];

				if (!face.__originalFaceNormal) {
					face.__originalFaceNormal = face.normal.clone();
				} else {
					face.__originalFaceNormal.copy(face.normal);
				}

				if (!face.__originalVertexNormals) face.__originalVertexNormals = [];

				for (i = 0, il = face.vertexNormals.length; i < il; i++) {
					if (!face.__originalVertexNormals[i]) {
						face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
					} else {
						face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
					}
				}
			}

			// use temp geometry to compute face and vertex normals for each morph

			const tmpGeo = new Geometry();
			tmpGeo.faces = this.faces;

			for (i = 0, il = this.morphTargets.length; i < il; i++) {
				// create on first access

				if (!this.morphNormals[i]) {
					this.morphNormals[i] = {};
					this.morphNormals[i].faceNormals = [];
					this.morphNormals[i].vertexNormals = [];

					const dstNormalsFace = this.morphNormals[i].faceNormals;
					const dstNormalsVertex = this.morphNormals[i].vertexNormals;

					var faceNormal; var
						vertexNormals;

					for (f = 0, fl = this.faces.length; f < fl; f++) {
						faceNormal = new Vector3();
						vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

						dstNormalsFace.push(faceNormal);
						dstNormalsVertex.push(vertexNormals);
					}
				}

				const morphNormals = this.morphNormals[i];

				// set vertices to morph target

				tmpGeo.vertices = this.morphTargets[i].vertices;

				// compute morph normals

				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();

				// store morph normals

				var faceNormal; var
					vertexNormals;

				for (f = 0, fl = this.faces.length; f < fl; f++) {
					face = this.faces[f];

					faceNormal = morphNormals.faceNormals[f];
					vertexNormals = morphNormals.vertexNormals[f];

					faceNormal.copy(face.normal);

					vertexNormals.a.copy(face.vertexNormals[0]);
					vertexNormals.b.copy(face.vertexNormals[1]);
					vertexNormals.c.copy(face.vertexNormals[2]);
				}
			}

			// restore original normals

			for (f = 0, fl = this.faces.length; f < fl; f++) {
				face = this.faces[f];

				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;
			}
		},

		computeBoundingBox() {
			if (this.boundingBox === null) {
				this.boundingBox = new Box3();
			}

			this.boundingBox.setFromPoints(this.vertices);
		},

		computeBoundingSphere() {
			if (this.boundingSphere === null) {
				this.boundingSphere = new Sphere();
			}

			this.boundingSphere.setFromPoints(this.vertices);
		},

		merge(geometry, matrix, materialIndexOffset) {
			if (!(geometry && geometry.isGeometry)) {
				console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
				return;
			}

			let normalMatrix;
			const vertexOffset = this.vertices.length;
			const vertices1 = this.vertices;
			const vertices2 = geometry.vertices;
			const faces1 = this.faces;
			const faces2 = geometry.faces;
			const uvs1 = this.faceVertexUvs[0];
			const uvs2 = geometry.faceVertexUvs[0];
			const colors1 = this.colors;
			const colors2 = geometry.colors;

			if (materialIndexOffset === undefined) materialIndexOffset = 0;

			if (matrix !== undefined) {
				normalMatrix = new Matrix3().getNormalMatrix(matrix);
			}

			// vertices

			for (var i = 0, il = vertices2.length; i < il; i++) {
				const vertex = vertices2[i];

				const vertexCopy = vertex.clone();

				if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);

				vertices1.push(vertexCopy);
			}

			// colors

			for (var i = 0, il = colors2.length; i < il; i++) {
				colors1.push(colors2[i].clone());
			}

			// faces

			for (i = 0, il = faces2.length; i < il; i++) {
				const face = faces2[i]; var faceCopy; var normal; var color;
				const faceVertexNormals = face.vertexNormals;
				const faceVertexColors = face.vertexColors;

				faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
				faceCopy.normal.copy(face.normal);

				if (normalMatrix !== undefined) {
					faceCopy.normal.applyMatrix3(normalMatrix).normalize();
				}

				for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
					normal = faceVertexNormals[j].clone();

					if (normalMatrix !== undefined) {
						normal.applyMatrix3(normalMatrix).normalize();
					}

					faceCopy.vertexNormals.push(normal);
				}

				faceCopy.color.copy(face.color);

				for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
					color = faceVertexColors[j];
					faceCopy.vertexColors.push(color.clone());
				}

				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

				faces1.push(faceCopy);
			}

			// uvs

			for (i = 0, il = uvs2.length; i < il; i++) {
				const uv = uvs2[i]; const
					uvCopy = [];

				if (uv === undefined) {
					continue;
				}

				for (var j = 0, jl = uv.length; j < jl; j++) {
					uvCopy.push(uv[j].clone());
				}

				uvs1.push(uvCopy);
			}
		},

		mergeMesh(mesh) {
			if (!(mesh && mesh.isMesh)) {
				console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
				return;
			}

			if (mesh.matrixAutoUpdate) mesh.updateMatrix();

			this.merge(mesh.geometry, mesh.matrix);
		},

		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */

		mergeVertices() {
			const verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
			const unique = []; const
				changes = [];

			let v; let
				key;
			const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
			const precision = Math.pow(10, precisionPoints);
			let i; let il; let
				face;
			let indices; let j; let
				jl;

			for (i = 0, il = this.vertices.length; i < il; i++) {
				v = this.vertices[i];
				key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;

				if (verticesMap[key] === undefined) {
					verticesMap[key] = i;
					unique.push(this.vertices[i]);
					changes[i] = unique.length - 1;
				} else {
					// console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[i] = changes[verticesMap[key]];
				}
			}


			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			const faceIndicesToRemove = [];

			for (i = 0, il = this.faces.length; i < il; i++) {
				face = this.faces[i];

				face.a = changes[face.a];
				face.b = changes[face.b];
				face.c = changes[face.c];

				indices = [face.a, face.b, face.c];

				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for (let n = 0; n < 3; n++) {
					if (indices[n] === indices[(n + 1) % 3]) {
						faceIndicesToRemove.push(i);
						break;
					}
				}
			}

			for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
				const idx = faceIndicesToRemove[i];

				this.faces.splice(idx, 1);

				for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
					this.faceVertexUvs[j].splice(idx, 1);
				}
			}

			// Use unique set of vertices

			const diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;
		},

		setFromPoints(points) {
			this.vertices = [];

			for (let i = 0, l = points.length; i < l; i++) {
				const point = points[i];
				this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
			}

			return this;
		},

		sortFacesByMaterialIndex() {
			const { faces } = this;
			const { length } = faces;

			// tag faces

			for (var i = 0; i < length; i++) {
				faces[i]._id = i;
			}

			// sort faces

			function materialIndexSort(a, b) {
				return a.materialIndex - b.materialIndex;
			}

			faces.sort(materialIndexSort);

			// sort uvs

			const uvs1 = this.faceVertexUvs[0];
			const uvs2 = this.faceVertexUvs[1];

			let newUvs1; let
				newUvs2;

			if (uvs1 && uvs1.length === length) newUvs1 = [];
			if (uvs2 && uvs2.length === length) newUvs2 = [];

			for (var i = 0; i < length; i++) {
				const id = faces[i]._id;

				if (newUvs1) newUvs1.push(uvs1[id]);
				if (newUvs2) newUvs2.push(uvs2[id]);
			}

			if (newUvs1) this.faceVertexUvs[0] = newUvs1;
			if (newUvs2) this.faceVertexUvs[1] = newUvs2;
		},

		toJSON() {
			const data = {
				metadata: {
					version: 4.5,
					type: 'Geometry',
					generator: 'Geometry.toJSON',
				},
			};

			// standard Geometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if (this.name !== '') data.name = this.name;

			if (this.parameters !== undefined) {
				const { parameters } = this;

				for (const key in parameters) {
					if (parameters[key] !== undefined) data[key] = parameters[key];
				}

				return data;
			}

			const vertices = [];

			for (var i = 0; i < this.vertices.length; i++) {
				const vertex = this.vertices[i];
				vertices.push(vertex.x, vertex.y, vertex.z);
			}

			const faces = [];
			const normals = [];
			const normalsHash = {};
			const colors = [];
			const colorsHash = {};
			const uvs = [];
			const uvsHash = {};

			for (var i = 0; i < this.faces.length; i++) {
				const face = this.faces[i];

				const hasMaterial = true;
				const hasFaceUv = false; // deprecated
				const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
				const hasFaceNormal = face.normal.length() > 0;
				const hasFaceVertexNormal = face.vertexNormals.length > 0;
				const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				const hasFaceVertexColor = face.vertexColors.length > 0;

				let faceType = 0;

				faceType = setBit(faceType, 0, 0); // isQuad
				faceType = setBit(faceType, 1, hasMaterial);
				faceType = setBit(faceType, 2, hasFaceUv);
				faceType = setBit(faceType, 3, hasFaceVertexUv);
				faceType = setBit(faceType, 4, hasFaceNormal);
				faceType = setBit(faceType, 5, hasFaceVertexNormal);
				faceType = setBit(faceType, 6, hasFaceColor);
				faceType = setBit(faceType, 7, hasFaceVertexColor);

				faces.push(faceType);
				faces.push(face.a, face.b, face.c);
				faces.push(face.materialIndex);

				if (hasFaceVertexUv) {
					const faceVertexUvs = this.faceVertexUvs[0][i];

					faces.push(
						getUvIndex(faceVertexUvs[0]),
						getUvIndex(faceVertexUvs[1]),
						getUvIndex(faceVertexUvs[2]),
					);
				}

				if (hasFaceNormal) {
					faces.push(getNormalIndex(face.normal));
				}

				if (hasFaceVertexNormal) {
					const { vertexNormals } = face;

					faces.push(
						getNormalIndex(vertexNormals[0]),
						getNormalIndex(vertexNormals[1]),
						getNormalIndex(vertexNormals[2]),
					);
				}

				if (hasFaceColor) {
					faces.push(getColorIndex(face.color));
				}

				if (hasFaceVertexColor) {
					const { vertexColors } = face;

					faces.push(
						getColorIndex(vertexColors[0]),
						getColorIndex(vertexColors[1]),
						getColorIndex(vertexColors[2]),
					);
				}
			}

			function setBit(value, position, enabled) {
				return enabled ? value | (1 << position) : value & (~(1 << position));
			}

			function getNormalIndex(normal) {
				const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

				if (normalsHash[hash] !== undefined) {
					return normalsHash[hash];
				}

				normalsHash[hash] = normals.length / 3;
				normals.push(normal.x, normal.y, normal.z);

				return normalsHash[hash];
			}

			function getColorIndex(color) {
				const hash = color.r.toString() + color.g.toString() + color.b.toString();

				if (colorsHash[hash] !== undefined) {
					return colorsHash[hash];
				}

				colorsHash[hash] = colors.length;
				colors.push(color.getHex());

				return colorsHash[hash];
			}

			function getUvIndex(uv) {
				const hash = uv.x.toString() + uv.y.toString();

				if (uvsHash[hash] !== undefined) {
					return uvsHash[hash];
				}

				uvsHash[hash] = uvs.length / 2;
				uvs.push(uv.x, uv.y);

				return uvsHash[hash];
			}

			data.data = {};

			data.data.vertices = vertices;
			data.data.normals = normals;
			if (colors.length > 0) data.data.colors = colors;
			if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility
			data.data.faces = faces;

			return data;
		},

		clone() {
			/*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new Geometry().copy(this);
		},

		copy(source) {
			let i; let il; let j; let jl; let k; let
				kl;

			// reset

			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [[]];
			this.morphTargets = [];
			this.morphNormals = [];
			this.skinWeights = [];
			this.skinIndices = [];
			this.lineDistances = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// name

			this.name = source.name;

			// vertices

			const { vertices } = source;

			for (i = 0, il = vertices.length; i < il; i++) {
				this.vertices.push(vertices[i].clone());
			}

			// colors

			const { colors } = source;

			for (i = 0, il = colors.length; i < il; i++) {
				this.colors.push(colors[i].clone());
			}

			// faces

			const { faces } = source;

			for (i = 0, il = faces.length; i < il; i++) {
				this.faces.push(faces[i].clone());
			}

			// face vertex uvs

			for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {
				const faceVertexUvs = source.faceVertexUvs[i];

				if (this.faceVertexUvs[i] === undefined) {
					this.faceVertexUvs[i] = [];
				}

				for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {
					const uvs = faceVertexUvs[j]; const
						uvsCopy = [];

					for (k = 0, kl = uvs.length; k < kl; k++) {
						const uv = uvs[k];

						uvsCopy.push(uv.clone());
					}

					this.faceVertexUvs[i].push(uvsCopy);
				}
			}

			// morph targets

			const { morphTargets } = source;

			for (i = 0, il = morphTargets.length; i < il; i++) {
				const morphTarget = {};
				morphTarget.name = morphTargets[i].name;

				// vertices

				if (morphTargets[i].vertices !== undefined) {
					morphTarget.vertices = [];

					for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {
						morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
					}
				}

				// normals

				if (morphTargets[i].normals !== undefined) {
					morphTarget.normals = [];

					for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {
						morphTarget.normals.push(morphTargets[i].normals[j].clone());
					}
				}

				this.morphTargets.push(morphTarget);
			}

			// morph normals

			const { morphNormals } = source;

			for (i = 0, il = morphNormals.length; i < il; i++) {
				const morphNormal = {};

				// vertex normals

				if (morphNormals[i].vertexNormals !== undefined) {
					morphNormal.vertexNormals = [];

					for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
						const srcVertexNormal = morphNormals[i].vertexNormals[j];
						const destVertexNormal = {};

						destVertexNormal.a = srcVertexNormal.a.clone();
						destVertexNormal.b = srcVertexNormal.b.clone();
						destVertexNormal.c = srcVertexNormal.c.clone();

						morphNormal.vertexNormals.push(destVertexNormal);
					}
				}

				// face normals

				if (morphNormals[i].faceNormals !== undefined) {
					morphNormal.faceNormals = [];

					for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {
						morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
					}
				}

				this.morphNormals.push(morphNormal);
			}

			// skin weights

			const { skinWeights } = source;

			for (i = 0, il = skinWeights.length; i < il; i++) {
				this.skinWeights.push(skinWeights[i].clone());
			}

			// skin indices

			const { skinIndices } = source;

			for (i = 0, il = skinIndices.length; i < il; i++) {
				this.skinIndices.push(skinIndices[i].clone());
			}

			// line distances

			const { lineDistances } = source;

			for (i = 0, il = lineDistances.length; i < il; i++) {
				this.lineDistances.push(lineDistances[i]);
			}

			// bounding box

			const { boundingBox } = source;

			if (boundingBox !== null) {
				this.boundingBox = boundingBox.clone();
			}

			// bounding sphere

			const { boundingSphere } = source;

			if (boundingSphere !== null) {
				this.boundingSphere = boundingSphere.clone();
			}

			// update flags

			this.elementsNeedUpdate = source.elementsNeedUpdate;
			this.verticesNeedUpdate = source.verticesNeedUpdate;
			this.uvsNeedUpdate = source.uvsNeedUpdate;
			this.normalsNeedUpdate = source.normalsNeedUpdate;
			this.colorsNeedUpdate = source.colorsNeedUpdate;
			this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
			this.groupsNeedUpdate = source.groupsNeedUpdate;

			return this;
		},

		dispose() {
			this.dispatchEvent({ type: 'dispose' });
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function BufferAttribute(array, itemSize, normalized) {
		if (Array.isArray(array)) {
			throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
		}

		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: -1 };

		this.version = 0;
	}

	Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {

		set(value) {
			if (value === true) this.version++;
		},

	});

	Object.assign(BufferAttribute.prototype, {

		isBufferAttribute: true,

		onUploadCallback() {},

		setArray(array) {
			if (Array.isArray(array)) {
				throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
			}

			this.count = array !== undefined ? array.length / this.itemSize : 0;
			this.array = array;

			return this;
		},

		setDynamic(value) {
			this.dynamic = value;

			return this;
		},

		copy(source) {
			this.name = source.name;
			this.array = new source.array.constructor(source.array);
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;

			this.dynamic = source.dynamic;

			return this;
		},

		copyAt(index1, attribute, index2) {
			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for (let i = 0, l = this.itemSize; i < l; i++) {
				this.array[index1 + i] = attribute.array[index2 + i];
			}

			return this;
		},

		copyArray(array) {
			this.array.set(array);

			return this;
		},

		copyColorsArray(colors) {
			const { array } = this;
			let offset = 0;

			for (let i = 0, l = colors.length; i < l; i++) {
				let color = colors[i];

				if (color === undefined) {
					console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
					color = new Color();
				}

				array[offset++] = color.r;
				array[offset++] = color.g;
				array[offset++] = color.b;
			}

			return this;
		},

		copyVector2sArray(vectors) {
			const { array } = this;
			let offset = 0;

			for (let i = 0, l = vectors.length; i < l; i++) {
				let vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
					vector = new Vector2();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
			}

			return this;
		},

		copyVector3sArray(vectors) {
			const { array } = this;
			let offset = 0;

			for (let i = 0, l = vectors.length; i < l; i++) {
				let vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
					vector = new Vector3();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
				array[offset++] = vector.z;
			}

			return this;
		},

		copyVector4sArray(vectors) {
			const { array } = this;
			let offset = 0;

			for (let i = 0, l = vectors.length; i < l; i++) {
				let vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
					vector = new Vector4();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
				array[offset++] = vector.z;
				array[offset++] = vector.w;
			}

			return this;
		},

		set(value, offset) {
			if (offset === undefined) offset = 0;

			this.array.set(value, offset);

			return this;
		},

		getX(index) {
			return this.array[index * this.itemSize];
		},

		setX(index, x) {
			this.array[index * this.itemSize] = x;

			return this;
		},

		getY(index) {
			return this.array[index * this.itemSize + 1];
		},

		setY(index, y) {
			this.array[index * this.itemSize + 1] = y;

			return this;
		},

		getZ(index) {
			return this.array[index * this.itemSize + 2];
		},

		setZ(index, z) {
			this.array[index * this.itemSize + 2] = z;

			return this;
		},

		getW(index) {
			return this.array[index * this.itemSize + 3];
		},

		setW(index, w) {
			this.array[index * this.itemSize + 3] = w;

			return this;
		},

		setXY(index, x, y) {
			index *= this.itemSize;

			this.array[index + 0] = x;
			this.array[index + 1] = y;

			return this;
		},

		setXYZ(index, x, y, z) {
			index *= this.itemSize;

			this.array[index + 0] = x;
			this.array[index + 1] = y;
			this.array[index + 2] = z;

			return this;
		},

		setXYZW(index, x, y, z, w) {
			index *= this.itemSize;

			this.array[index + 0] = x;
			this.array[index + 1] = y;
			this.array[index + 2] = z;
			this.array[index + 3] = w;

			return this;
		},

		onUpload(callback) {
			this.onUploadCallback = callback;

			return this;
		},

		clone() {
			return new this.constructor(this.array, this.itemSize).copy(this);
		},

	});

	//

	function Int8BufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
	}

	Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


	function Uint8BufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
	}

	Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


	function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
	}

	Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


	function Int16BufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
	}

	Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


	function Uint16BufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
	}

	Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


	function Int32BufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
	}

	Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


	function Uint32BufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
	}

	Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


	function Float32BufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
	}

	Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


	function Float64BufferAttribute(array, itemSize, normalized) {
		BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
	}

	Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function DirectGeometry() {
		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];

		this.groups = [];

		this.morphTargets = {};

		this.skinWeights = [];
		this.skinIndices = [];

		// this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.verticesNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.groupsNeedUpdate = false;
	}

	Object.assign(DirectGeometry.prototype, {

		computeGroups(geometry) {
			let group;
			const groups = [];
			let materialIndex;

			const { faces } = geometry;

			for (var i = 0; i < faces.length; i++) {
				const face = faces[i];

				// materials

				if (face.materialIndex !== materialIndex) {
					materialIndex = face.materialIndex;

					if (group !== undefined) {
						group.count = (i * 3) - group.start;
						groups.push(group);
					}

					group = {
						start: i * 3,
						materialIndex,
					};
				}
			}

			if (group !== undefined) {
				group.count = (i * 3) - group.start;
				groups.push(group);
			}

			this.groups = groups;
		},

		fromGeometry(geometry) {
			const { faces } = geometry;
			const { vertices } = geometry;
			const { faceVertexUvs } = geometry;

			const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
			const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;

			// morphs

			const { morphTargets } = geometry;
			const morphTargetsLength = morphTargets.length;

			let morphTargetsPosition;

			if (morphTargetsLength > 0) {
				morphTargetsPosition = [];

				for (var i = 0; i < morphTargetsLength; i++) {
					morphTargetsPosition[i] = {
						name: morphTargets[i].name,
					 	data: [],
					};
				}

				this.morphTargets.position = morphTargetsPosition;
			}

			const { morphNormals } = geometry;
			const morphNormalsLength = morphNormals.length;

			let morphTargetsNormal;

			if (morphNormalsLength > 0) {
				morphTargetsNormal = [];

				for (var i = 0; i < morphNormalsLength; i++) {
					morphTargetsNormal[i] = {
						name: morphNormals[i].name,
					 	data: [],
					};
				}

				this.morphTargets.normal = morphTargetsNormal;
			}

			// skins

			const { skinIndices } = geometry;
			const { skinWeights } = geometry;

			const hasSkinIndices = skinIndices.length === vertices.length;
			const hasSkinWeights = skinWeights.length === vertices.length;

			//

			if (vertices.length > 0 && faces.length === 0) {
				console.error('THREE.DirectGeometry: Faceless geometries are not supported.');
			}

			for (var i = 0; i < faces.length; i++) {
				const face = faces[i];

				this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);

				const { vertexNormals } = face;

				if (vertexNormals.length === 3) {
					this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
				} else {
					const { normal } = face;

					this.normals.push(normal, normal, normal);
				}

				const { vertexColors } = face;

				if (vertexColors.length === 3) {
					this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
				} else {
					const { color } = face;

					this.colors.push(color, color, color);
				}

				if (hasFaceVertexUv === true) {
					var vertexUvs = faceVertexUvs[0][i];

					if (vertexUvs !== undefined) {
						this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
					} else {
						console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);

						this.uvs.push(new Vector2(), new Vector2(), new Vector2());
					}
				}

				if (hasFaceVertexUv2 === true) {
					var vertexUvs = faceVertexUvs[1][i];

					if (vertexUvs !== undefined) {
						this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
					} else {
						console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);

						this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
					}
				}

				// morphs

				for (var j = 0; j < morphTargetsLength; j++) {
					const morphTarget = morphTargets[j].vertices;

					morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
				}

				for (var j = 0; j < morphNormalsLength; j++) {
					const morphNormal = morphNormals[j].vertexNormals[i];

					morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
				}

				// skins

				if (hasSkinIndices) {
					this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
				}

				if (hasSkinWeights) {
					this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
				}
			}

			this.computeGroups(geometry);

			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
			this.groupsNeedUpdate = geometry.groupsNeedUpdate;

			return this;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function arrayMax(array) {
		if (array.length === 0) return -Infinity;

		let max = array[0];

		for (let i = 1, l = array.length; i < l; ++i) {
			if (array[i] > max) max = array[i];
		}

		return max;
	}

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	let bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

	function BufferGeometry() {
		Object.defineProperty(this, 'id', { value: bufferGeometryId += 2 });

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};
	}

	BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {

		constructor: BufferGeometry,

		isBufferGeometry: true,

		getIndex() {
			return this.index;
		},

		setIndex(index) {
			if (Array.isArray(index)) {
				this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
			} else {
				this.index = index;
			}
		},

		addAttribute(name, attribute) {
			if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
				console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');

				return this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
			}

			if (name === 'index') {
				console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
				this.setIndex(attribute);

				return this;
			}

			this.attributes[name] = attribute;

			return this;
		},

		getAttribute(name) {
			return this.attributes[name];
		},

		removeAttribute(name) {
			delete this.attributes[name];

			return this;
		},

		addGroup(start, count, materialIndex) {
			this.groups.push({

				start,
				count,
				materialIndex: materialIndex !== undefined ? materialIndex : 0,

			});
		},

		clearGroups() {
			this.groups = [];
		},

		setDrawRange(start, count) {
			this.drawRange.start = start;
			this.drawRange.count = count;
		},

		applyMatrix(matrix) {
			const { position } = this.attributes;

			if (position !== undefined) {
				matrix.applyToBufferAttribute(position);
				position.needsUpdate = true;
			}

			const { normal } = this.attributes;

			if (normal !== undefined) {
				const normalMatrix = new Matrix3().getNormalMatrix(matrix);

				normalMatrix.applyToBufferAttribute(normal);
				normal.needsUpdate = true;
			}

			if (this.boundingBox !== null) {
				this.computeBoundingBox();
			}

			if (this.boundingSphere !== null) {
				this.computeBoundingSphere();
			}

			return this;
		},

		rotateX: (function () {
			// rotate geometry around world x-axis

			const m1 = new Matrix4();

			return function rotateX(angle) {
				m1.makeRotationX(angle);

				this.applyMatrix(m1);

				return this;
			};
		}()),

		rotateY: (function () {
			// rotate geometry around world y-axis

			const m1 = new Matrix4();

			return function rotateY(angle) {
				m1.makeRotationY(angle);

				this.applyMatrix(m1);

				return this;
			};
		}()),

		rotateZ: (function () {
			// rotate geometry around world z-axis

			const m1 = new Matrix4();

			return function rotateZ(angle) {
				m1.makeRotationZ(angle);

				this.applyMatrix(m1);

				return this;
			};
		}()),

		translate: (function () {
			// translate geometry

			const m1 = new Matrix4();

			return function translate(x, y, z) {
				m1.makeTranslation(x, y, z);

				this.applyMatrix(m1);

				return this;
			};
		}()),

		scale: (function () {
			// scale geometry

			const m1 = new Matrix4();

			return function scale(x, y, z) {
				m1.makeScale(x, y, z);

				this.applyMatrix(m1);

				return this;
			};
		}()),

		lookAt: (function () {
			const obj = new Object3D();

			return function lookAt(vector) {
				obj.lookAt(vector);

				obj.updateMatrix();

				this.applyMatrix(obj.matrix);
			};
		}()),

		center: (function () {
			const offset = new Vector3();

			return function center() {
				this.computeBoundingBox();

				this.boundingBox.getCenter(offset).negate();

				this.translate(offset.x, offset.y, offset.z);

				return this;
			};
		}()),

		setFromObject(object) {
			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

			const { geometry } = object;

			if (object.isPoints || object.isLine) {
				const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
				const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);

				this.addAttribute('position', positions.copyVector3sArray(geometry.vertices));
				this.addAttribute('color', colors.copyColorsArray(geometry.colors));

				if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
					const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);

					this.addAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
				}

				if (geometry.boundingSphere !== null) {
					this.boundingSphere = geometry.boundingSphere.clone();
				}

				if (geometry.boundingBox !== null) {
					this.boundingBox = geometry.boundingBox.clone();
				}
			} else if (object.isMesh) {
				if (geometry && geometry.isGeometry) {
					this.fromGeometry(geometry);
				}
			}

			return this;
		},

		setFromPoints(points) {
			const position = [];

			for (let i = 0, l = points.length; i < l; i++) {
				const point = points[i];
				position.push(point.x, point.y, point.z || 0);
			}

			this.addAttribute('position', new Float32BufferAttribute(position, 3));

			return this;
		},

		updateFromObject(object) {
			let { geometry } = object;

			if (object.isMesh) {
				let direct = geometry.__directGeometry;

				if (geometry.elementsNeedUpdate === true) {
					direct = undefined;
					geometry.elementsNeedUpdate = false;
				}

				if (direct === undefined) {
					return this.fromGeometry(geometry);
				}

				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;

				geometry = direct;
			}

			let attribute;

			if (geometry.verticesNeedUpdate === true) {
				attribute = this.attributes.position;

				if (attribute !== undefined) {
					attribute.copyVector3sArray(geometry.vertices);
					attribute.needsUpdate = true;
				}

				geometry.verticesNeedUpdate = false;
			}

			if (geometry.normalsNeedUpdate === true) {
				attribute = this.attributes.normal;

				if (attribute !== undefined) {
					attribute.copyVector3sArray(geometry.normals);
					attribute.needsUpdate = true;
				}

				geometry.normalsNeedUpdate = false;
			}

			if (geometry.colorsNeedUpdate === true) {
				attribute = this.attributes.color;

				if (attribute !== undefined) {
					attribute.copyColorsArray(geometry.colors);
					attribute.needsUpdate = true;
				}

				geometry.colorsNeedUpdate = false;
			}

			if (geometry.uvsNeedUpdate) {
				attribute = this.attributes.uv;

				if (attribute !== undefined) {
					attribute.copyVector2sArray(geometry.uvs);
					attribute.needsUpdate = true;
				}

				geometry.uvsNeedUpdate = false;
			}

			if (geometry.lineDistancesNeedUpdate) {
				attribute = this.attributes.lineDistance;

				if (attribute !== undefined) {
					attribute.copyArray(geometry.lineDistances);
					attribute.needsUpdate = true;
				}

				geometry.lineDistancesNeedUpdate = false;
			}

			if (geometry.groupsNeedUpdate) {
				geometry.computeGroups(object.geometry);
				this.groups = geometry.groups;

				geometry.groupsNeedUpdate = false;
			}

			return this;
		},

		fromGeometry(geometry) {
			geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);

			return this.fromDirectGeometry(geometry.__directGeometry);
		},

		fromDirectGeometry(geometry) {
			const positions = new Float32Array(geometry.vertices.length * 3);
			this.addAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));

			if (geometry.normals.length > 0) {
				const normals = new Float32Array(geometry.normals.length * 3);
				this.addAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
			}

			if (geometry.colors.length > 0) {
				const colors = new Float32Array(geometry.colors.length * 3);
				this.addAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
			}

			if (geometry.uvs.length > 0) {
				const uvs = new Float32Array(geometry.uvs.length * 2);
				this.addAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
			}

			if (geometry.uvs2.length > 0) {
				const uvs2 = new Float32Array(geometry.uvs2.length * 2);
				this.addAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
			}

			// groups

			this.groups = geometry.groups;

			// morphs

			for (const name in geometry.morphTargets) {
				const array = [];
				const morphTargets = geometry.morphTargets[name];

				for (let i = 0, l = morphTargets.length; i < l; i++) {
					const morphTarget = morphTargets[i];

					const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
					attribute.name = morphTarget.name;

					array.push(attribute.copyVector3sArray(morphTarget.data));
				}

				this.morphAttributes[name] = array;
			}

			// skinning

			if (geometry.skinIndices.length > 0) {
				const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
				this.addAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
			}

			if (geometry.skinWeights.length > 0) {
				const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
				this.addAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
			}

			//

			if (geometry.boundingSphere !== null) {
				this.boundingSphere = geometry.boundingSphere.clone();
			}

			if (geometry.boundingBox !== null) {
				this.boundingBox = geometry.boundingBox.clone();
			}

			return this;
		},

		computeBoundingBox() {
			if (this.boundingBox === null) {
				this.boundingBox = new Box3();
			}

			const { position } = this.attributes;

			if (position !== undefined) {
				this.boundingBox.setFromBufferAttribute(position);
			} else {
				this.boundingBox.makeEmpty();
			}

			if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
				console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
			}
		},

		computeBoundingSphere: (function () {
			const box = new Box3();
			const vector = new Vector3();

			return function computeBoundingSphere() {
				if (this.boundingSphere === null) {
					this.boundingSphere = new Sphere();
				}

				const { position } = this.attributes;

				if (position) {
					const { center } = this.boundingSphere;

					box.setFromBufferAttribute(position);
					box.getCenter(center);

					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

					let maxRadiusSq = 0;

					for (let i = 0, il = position.count; i < il; i++) {
						vector.x = position.getX(i);
						vector.y = position.getY(i);
						vector.z = position.getZ(i);
						maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
					}

					this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

					if (isNaN(this.boundingSphere.radius)) {
						console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
					}
				}
			};
		}()),

		computeFaceNormals() {

			// backwards compatibility

		},

		computeVertexNormals() {
			const { index } = this;
			const { attributes } = this;

			if (attributes.position) {
				const positions = attributes.position.array;

				if (attributes.normal === undefined) {
					this.addAttribute('normal', new BufferAttribute(new Float32Array(positions.length), 3));
				} else {
					// reset existing normals to zero

					const { array } = attributes.normal;

					for (var i = 0, il = array.length; i < il; i++) {
						array[i] = 0;
					}
				}

				const normals = attributes.normal.array;

				let vA; let vB; let
					vC;
				const pA = new Vector3(); const pB = new Vector3(); const
					pC = new Vector3();
				const cb = new Vector3(); const
					ab = new Vector3();

				// indexed elements

				if (index) {
					const indices = index.array;

					for (var i = 0, il = index.count; i < il; i += 3) {
						vA = indices[i + 0] * 3;
						vB = indices[i + 1] * 3;
						vC = indices[i + 2] * 3;

						pA.fromArray(positions, vA);
						pB.fromArray(positions, vB);
						pC.fromArray(positions, vC);

						cb.subVectors(pC, pB);
						ab.subVectors(pA, pB);
						cb.cross(ab);

						normals[vA] += cb.x;
						normals[vA + 1] += cb.y;
						normals[vA + 2] += cb.z;

						normals[vB] += cb.x;
						normals[vB + 1] += cb.y;
						normals[vB + 2] += cb.z;

						normals[vC] += cb.x;
						normals[vC + 1] += cb.y;
						normals[vC + 2] += cb.z;
					}
				} else {
					// non-indexed elements (unconnected triangle soup)

					for (var i = 0, il = positions.length; i < il; i += 9) {
						pA.fromArray(positions, i);
						pB.fromArray(positions, i + 3);
						pC.fromArray(positions, i + 6);

						cb.subVectors(pC, pB);
						ab.subVectors(pA, pB);
						cb.cross(ab);

						normals[i] = cb.x;
						normals[i + 1] = cb.y;
						normals[i + 2] = cb.z;

						normals[i + 3] = cb.x;
						normals[i + 4] = cb.y;
						normals[i + 5] = cb.z;

						normals[i + 6] = cb.x;
						normals[i + 7] = cb.y;
						normals[i + 8] = cb.z;
					}
				}

				this.normalizeNormals();

				attributes.normal.needsUpdate = true;
			}
		},

		merge(geometry, offset) {
			if (!(geometry && geometry.isBufferGeometry)) {
				console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
				return;
			}

			if (offset === undefined) {
				offset = 0;

				console.warn(
					'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
					+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.',
				);
			}

			const { attributes } = this;

			for (const key in attributes) {
				if (geometry.attributes[key] === undefined) continue;

				const attribute1 = attributes[key];
				const attributeArray1 = attribute1.array;

				const attribute2 = geometry.attributes[key];
				const attributeArray2 = attribute2.array;

				const attributeSize = attribute2.itemSize;

				for (let i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
					attributeArray1[j] = attributeArray2[i];
				}
			}

			return this;
		},

		normalizeNormals: (function () {
			const vector = new Vector3();

			return function normalizeNormals() {
				const normals = this.attributes.normal;

				for (let i = 0, il = normals.count; i < il; i++) {
					vector.x = normals.getX(i);
					vector.y = normals.getY(i);
					vector.z = normals.getZ(i);

					vector.normalize();

					normals.setXYZ(i, vector.x, vector.y, vector.z);
				}
			};
		}()),

		toNonIndexed() {
			if (this.index === null) {
				console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
				return this;
			}

			const geometry2 = new BufferGeometry();

			const indices = this.index.array;
			const { attributes } = this;

			for (const name in attributes) {
				const attribute = attributes[name];

				const { array } = attribute;
				const { itemSize } = attribute;

				const array2 = new array.constructor(indices.length * itemSize);

				let index = 0; let
					index2 = 0;

				for (var i = 0, l = indices.length; i < l; i++) {
					index = indices[i] * itemSize;

					for (let j = 0; j < itemSize; j++) {
						array2[index2++] = array[index++];
					}
				}

				geometry2.addAttribute(name, new BufferAttribute(array2, itemSize));
			}

			const { groups } = this;

			for (var i = 0, l = groups.length; i < l; i++) {
				const group = groups[i];
				geometry2.addGroup(group.start, group.count, group.materialIndex);
			}

			return geometry2;
		},

		toJSON() {
			const data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON',
				},
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if (this.name !== '') data.name = this.name;
			if (Object.keys(this.userData).length > 0) data.userData = this.userData;

			if (this.parameters !== undefined) {
				const { parameters } = this;

				for (var key in parameters) {
					if (parameters[key] !== undefined) data[key] = parameters[key];
				}

				return data;
			}

			data.data = { attributes: {} };

			const { index } = this;

			if (index !== null) {
				var array = Array.prototype.slice.call(index.array);

				data.data.index = {
					type: index.array.constructor.name,
					array,
				};
			}

			const { attributes } = this;

			for (var key in attributes) {
				const attribute = attributes[key];

				var array = Array.prototype.slice.call(attribute.array);

				data.data.attributes[key] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array,
					normalized: attribute.normalized,
				};
			}

			const { groups } = this;

			if (groups.length > 0) {
				data.data.groups = JSON.parse(JSON.stringify(groups));
			}

			const { boundingSphere } = this;

			if (boundingSphere !== null) {
				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius,
				};
			}

			return data;
		},

		clone() {
			/*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new BufferGeometry().copy(this);
		},

		copy(source) {
			let name; let i; let
				l;

			// reset

			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// name

			this.name = source.name;

			// index

			const { index } = source;

			if (index !== null) {
				this.setIndex(index.clone());
			}

			// attributes

			const { attributes } = source;

			for (name in attributes) {
				const attribute = attributes[name];
				this.addAttribute(name, attribute.clone());
			}

			// morph attributes

			const { morphAttributes } = source;

			for (name in morphAttributes) {
				const array = [];
				const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

				for (i = 0, l = morphAttribute.length; i < l; i++) {
					array.push(morphAttribute[i].clone());
				}

				this.morphAttributes[name] = array;
			}

			// groups

			const { groups } = source;

			for (i = 0, l = groups.length; i < l; i++) {
				const group = groups[i];
				this.addGroup(group.start, group.count, group.materialIndex);
			}

			// bounding box

			const { boundingBox } = source;

			if (boundingBox !== null) {
				this.boundingBox = boundingBox.clone();
			}

			// bounding sphere

			const { boundingSphere } = source;

			if (boundingSphere !== null) {
				this.boundingSphere = boundingSphere.clone();
			}

			// draw range

			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;

			// user data

			this.userData = source.userData;

			return this;
		},

		dispose() {
			this.dispatchEvent({ type: 'dispose' });
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// BoxGeometry

	function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
		Geometry.call(this);

		this.type = 'BoxGeometry';

		this.parameters = {
			width,
			height,
			depth,
			widthSegments,
			heightSegments,
			depthSegments,
		};

		this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
		this.mergeVertices();
	}

	BoxGeometry.prototype = Object.create(Geometry.prototype);
	BoxGeometry.prototype.constructor = BoxGeometry;

	// BoxBufferGeometry

	function BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
		BufferGeometry.call(this);

		this.type = 'BoxBufferGeometry';

		this.parameters = {
			width,
			height,
			depth,
			widthSegments,
			heightSegments,
			depthSegments,
		};

		const scope = this;

		width = width || 1;
		height = height || 1;
		depth = depth || 1;

		// segments

		widthSegments = Math.floor(widthSegments) || 1;
		heightSegments = Math.floor(heightSegments) || 1;
		depthSegments = Math.floor(depthSegments) || 1;

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let numberOfVertices = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
		buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
		buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
		buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
		buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
		buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz

		// build geometry

		this.setIndex(indices);
		this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

		function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
			const segmentWidth = width / gridX;
			const segmentHeight = height / gridY;

			const widthHalf = width / 2;
			const heightHalf = height / 2;
			const depthHalf = depth / 2;

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			let vertexCounter = 0;
			let groupCount = 0;

			let ix; let
				iy;

			const vector = new Vector3();

			// generate vertices, normals and uvs

			for (iy = 0; iy < gridY1; iy++) {
				const y = iy * segmentHeight - heightHalf;

				for (ix = 0; ix < gridX1; ix++) {
					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[u] = x * udir;
					vector[v] = y * vdir;
					vector[w] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push(vector.x, vector.y, vector.z);

					// set values to correct vector component

					vector[u] = 0;
					vector[v] = 0;
					vector[w] = depth > 0 ? 1 : -1;

					// now apply vector to normal buffer

					normals.push(vector.x, vector.y, vector.z);

					// uvs

					uvs.push(ix / gridX);
					uvs.push(1 - (iy / gridY));

					// counters

					vertexCounter += 1;
				}
			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for (iy = 0; iy < gridY; iy++) {
				for (ix = 0; ix < gridX; ix++) {
					const a = numberOfVertices + ix + gridX1 * iy;
					const b = numberOfVertices + ix + gridX1 * (iy + 1);
					const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
					const d = numberOfVertices + (ix + 1) + gridX1 * iy;

					// faces

					indices.push(a, b, d);
					indices.push(b, c, d);

					// increase counter

					groupCount += 6;
				}
			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup(groupStart, groupCount, materialIndex);

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;
		}
	}

	BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// PlaneGeometry

	function PlaneGeometry(width, height, widthSegments, heightSegments) {
		Geometry.call(this);

		this.type = 'PlaneGeometry';

		this.parameters = {
			width,
			height,
			widthSegments,
			heightSegments,
		};

		this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
		this.mergeVertices();
	}

	PlaneGeometry.prototype = Object.create(Geometry.prototype);
	PlaneGeometry.prototype.constructor = PlaneGeometry;

	// PlaneBufferGeometry

	function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
		BufferGeometry.call(this);

		this.type = 'PlaneBufferGeometry';

		this.parameters = {
			width,
			height,
			widthSegments,
			heightSegments,
		};

		width = width || 1;
		height = height || 1;

		const width_half = width / 2;
		const height_half = height / 2;

		const gridX = Math.floor(widthSegments) || 1;
		const gridY = Math.floor(heightSegments) || 1;

		const gridX1 = gridX + 1;
		const gridY1 = gridY + 1;

		const segment_width = width / gridX;
		const segment_height = height / gridY;

		let ix; let
			iy;

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// generate vertices, normals and uvs

		for (iy = 0; iy < gridY1; iy++) {
			const y = iy * segment_height - height_half;

			for (ix = 0; ix < gridX1; ix++) {
				const x = ix * segment_width - width_half;

				vertices.push(x, -y, 0);

				normals.push(0, 0, 1);

				uvs.push(ix / gridX);
				uvs.push(1 - (iy / gridY));
			}
		}

		// indices

		for (iy = 0; iy < gridY; iy++) {
			for (ix = 0; ix < gridX; ix++) {
				const a = ix + gridX1 * iy;
				const b = ix + gridX1 * (iy + 1);
				const c = (ix + 1) + gridX1 * (iy + 1);
				const d = (ix + 1) + gridX1 * iy;

				// faces

				indices.push(a, b, d);
				indices.push(b, c, d);
			}
		}

		// build geometry

		this.setIndex(indices);
		this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
	}

	PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	let materialId = 0;

	function Material() {
		Object.defineProperty(this, 'id', { value: materialId++ });

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Material';

		this.fog = true;
		this.lights = true;

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.flatShading = false;
		this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

		this.opacity = 1;
		this.transparent = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaTest = 0;
		this.premultipliedAlpha = false;

		this.visible = true;

		this.userData = {};

		this.needsUpdate = true;
	}

	Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {

		constructor: Material,

		isMaterial: true,

		onBeforeCompile() {},

		setValues(values) {
			if (values === undefined) return;

			for (const key in values) {
				const newValue = values[key];

				if (newValue === undefined) {
					console.warn(`THREE.Material: '${key}' parameter is undefined.`);
					continue;
				}

				// for backward compatability if shading is set in the constructor
				if (key === 'shading') {
					console.warn(`THREE.${this.type}: .shading has been removed. Use the boolean .flatShading instead.`);
					this.flatShading = (newValue === FlatShading);
					continue;
				}

				const currentValue = this[key];

				if (currentValue === undefined) {
					console.warn(`THREE.${this.type}: '${key}' is not a property of this material.`);
					continue;
				}

				if (currentValue && currentValue.isColor) {
					currentValue.set(newValue);
				} else if ((currentValue && currentValue.isVector3) && (newValue && newValue.isVector3)) {
					currentValue.copy(newValue);
				} else {
					this[key] = newValue;
				}
			}
		},

		toJSON(meta) {
			const isRoot = (meta === undefined || typeof meta === 'string');

			if (isRoot) {
				meta = {
					textures: {},
					images: {},
				};
			}

			const data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON',
				},
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;

			if (this.name !== '') data.name = this.name;

			if (this.color && this.color.isColor) data.color = this.color.getHex();

			if (this.roughness !== undefined) data.roughness = this.roughness;
			if (this.metalness !== undefined) data.metalness = this.metalness;

			if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
			if (this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;

			if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
			if (this.shininess !== undefined) data.shininess = this.shininess;
			if (this.clearCoat !== undefined) data.clearCoat = this.clearCoat;
			if (this.clearCoatRoughness !== undefined) data.clearCoatRoughness = this.clearCoatRoughness;

			if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
			if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
			if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;

			if (this.aoMap && this.aoMap.isTexture) {
				data.aoMap = this.aoMap.toJSON(meta).uuid;
				data.aoMapIntensity = this.aoMapIntensity;
			}

			if (this.bumpMap && this.bumpMap.isTexture) {
				data.bumpMap = this.bumpMap.toJSON(meta).uuid;
				data.bumpScale = this.bumpScale;
			}

			if (this.normalMap && this.normalMap.isTexture) {
				data.normalMap = this.normalMap.toJSON(meta).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();
			}

			if (this.displacementMap && this.displacementMap.isTexture) {
				data.displacementMap = this.displacementMap.toJSON(meta).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;
			}

			if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
			if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;

			if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
			if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;

			if (this.envMap && this.envMap.isTexture) {
				data.envMap = this.envMap.toJSON(meta).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap

				if (this.combine !== undefined) data.combine = this.combine;
				if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
			}

			if (this.gradientMap && this.gradientMap.isTexture) {
				data.gradientMap = this.gradientMap.toJSON(meta).uuid;
			}

			if (this.size !== undefined) data.size = this.size;
			if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;

			if (this.blending !== NormalBlending) data.blending = this.blending;
			if (this.flatShading === true) data.flatShading = this.flatShading;
			if (this.side !== FrontSide) data.side = this.side;
			if (this.vertexColors !== NoColors) data.vertexColors = this.vertexColors;

			if (this.opacity < 1) data.opacity = this.opacity;
			if (this.transparent === true) data.transparent = this.transparent;

			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;

			// rotation (SpriteMaterial)
			if (this.rotation !== 0) data.rotation = this.rotation;

			if (this.polygonOffset === true) data.polygonOffset = true;
			if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;

			if (this.linewidth !== 1) data.linewidth = this.linewidth;
			if (this.dashSize !== undefined) data.dashSize = this.dashSize;
			if (this.gapSize !== undefined) data.gapSize = this.gapSize;
			if (this.scale !== undefined) data.scale = this.scale;

			if (this.dithering === true) data.dithering = true;

			if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
			if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;

			if (this.wireframe === true) data.wireframe = this.wireframe;
			if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
			if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
			if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;

			if (this.morphTargets === true) data.morphTargets = true;
			if (this.skinning === true) data.skinning = true;

			if (this.visible === false) data.visible = false;
			if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;

			// TODO: Copied from Object3D.toJSON

			function extractFromCache(cache) {
				const values = [];

				for (const key in cache) {
					const data = cache[key];
					delete data.metadata;
					values.push(data);
				}

				return values;
			}

			if (isRoot) {
				const textures = extractFromCache(meta.textures);
				const images = extractFromCache(meta.images);

				if (textures.length > 0) data.textures = textures;
				if (images.length > 0) data.images = images;
			}

			return data;
		},

		clone() {
			return new this.constructor().copy(this);
		},

		copy(source) {
			this.name = source.name;

			this.fog = source.fog;
			this.lights = source.lights;

			this.blending = source.blending;
			this.side = source.side;
			this.flatShading = source.flatShading;
			this.vertexColors = source.vertexColors;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.colorWrite = source.colorWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.dithering = source.dithering;

			this.alphaTest = source.alphaTest;
			this.premultipliedAlpha = source.premultipliedAlpha;

			this.visible = source.visible;
			this.userData = JSON.parse(JSON.stringify(source.userData));

			this.clipShadows = source.clipShadows;
			this.clipIntersection = source.clipIntersection;

			const srcPlanes = source.clippingPlanes;
			let dstPlanes = null;

			if (srcPlanes !== null) {
				const n = srcPlanes.length;
				dstPlanes = new Array(n);

				for (let i = 0; i !== n; ++i) dstPlanes[i] = srcPlanes[i].clone();
			}

			this.clippingPlanes = dstPlanes;

			this.shadowSide = source.shadowSide;

			return this;
		},

		dispose() {
			this.dispatchEvent({ type: 'dispose' });
		},

	});

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function ShaderMaterial(parameters) {
		Material.call(this);

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};

		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.skinning = false; // set to use skinning attribute streams
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals

		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false, // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			color: [1, 1, 1],
			uv: [0, 0],
			uv2: [0, 0],
		};

		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;

		if (parameters !== undefined) {
			if (parameters.attributes !== undefined) {
				console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
			}

			this.setValues(parameters);
		}
	}

	ShaderMaterial.prototype = Object.create(Material.prototype);
	ShaderMaterial.prototype.constructor = ShaderMaterial;

	ShaderMaterial.prototype.isShaderMaterial = true;

	ShaderMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = cloneUniforms(source.uniforms);

		this.defines = { ...source.defines };

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.lights = source.lights;
		this.clipping = source.clipping;

		this.skinning = source.skinning;

		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.extensions = source.extensions;

		return this;
	};

	ShaderMaterial.prototype.toJSON = function (meta) {
		const data = Material.prototype.toJSON.call(this, meta);

		data.uniforms = {};

		for (const name in this.uniforms) {
			const uniform = this.uniforms[name];
			const { value } = uniform;

			if (value && value.isTexture) {
				data.uniforms[name] = {
					type: 't',
					value: value.toJSON(meta).uuid,
				};
			} else if (value && value.isColor) {
				data.uniforms[name] = {
					type: 'c',
					value: value.getHex(),
				};
			} else if (value && value.isVector2) {
				data.uniforms[name] = {
					type: 'v2',
					value: value.toArray(),
				};
			} else if (value && value.isVector3) {
				data.uniforms[name] = {
					type: 'v3',
					value: value.toArray(),
				};
			} else if (value && value.isVector4) {
				data.uniforms[name] = {
					type: 'v4',
					value: value.toArray(),
				};
			} else if (value && value.isMatrix4) {
				data.uniforms[name] = {
					type: 'm4',
					value: value.toArray(),
				};
			} else {
				data.uniforms[name] = {
					value,
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
			}
		}

		if (Object.keys(this.defines).length > 0) data.defines = this.defines;

		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		const extensions = {};

		for (const key in this.extensions) {
			if (this.extensions[key] === true) extensions[key] = true;
		}

		if (Object.keys(extensions).length > 0) data.extensions = extensions;

		return data;
	};

	/**
	 * @author bhouston / http://clara.io
	 */

	function Ray(origin, direction) {
		this.origin = (origin !== undefined) ? origin : new Vector3();
		this.direction = (direction !== undefined) ? direction : new Vector3();
	}

	Object.assign(Ray.prototype, {

		set(origin, direction) {
			this.origin.copy(origin);
			this.direction.copy(direction);

			return this;
		},

		clone() {
			return new this.constructor().copy(this);
		},

		copy(ray) {
			this.origin.copy(ray.origin);
			this.direction.copy(ray.direction);

			return this;
		},

		at(t, target) {
			if (target === undefined) {
				console.warn('THREE.Ray: .at() target is now required');
				target = new Vector3();
			}

			return target.copy(this.direction).multiplyScalar(t).add(this.origin);
		},

		lookAt(v) {
			this.direction.copy(v).sub(this.origin).normalize();

			return this;
		},

		recast: (function () {
			const v1 = new Vector3();

			return function recast(t) {
				this.origin.copy(this.at(t, v1));

				return this;
			};
		}()),

		closestPointToPoint(point, target) {
			if (target === undefined) {
				console.warn('THREE.Ray: .closestPointToPoint() target is now required');
				target = new Vector3();
			}

			target.subVectors(point, this.origin);

			const directionDistance = target.dot(this.direction);

			if (directionDistance < 0) {
				return target.copy(this.origin);
			}

			return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
		},

		distanceToPoint(point) {
			return Math.sqrt(this.distanceSqToPoint(point));
		},

		distanceSqToPoint: (function () {
			const v1 = new Vector3();

			return function distanceSqToPoint(point) {
				const directionDistance = v1.subVectors(point, this.origin).dot(this.direction);

				// point behind the ray

				if (directionDistance < 0) {
					return this.origin.distanceToSquared(point);
				}

				v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

				return v1.distanceToSquared(point);
			};
		}()),

		distanceSqToSegment: (function () {
			const segCenter = new Vector3();
			const segDir = new Vector3();
			const diff = new Vector3();

			return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment

				segCenter.copy(v0).add(v1).multiplyScalar(0.5);
				segDir.copy(v1).sub(v0).normalize();
				diff.copy(this.origin).sub(segCenter);

				const segExtent = v0.distanceTo(v1) * 0.5;
				const a01 = -this.direction.dot(segDir);
				const b0 = diff.dot(this.direction);
				const b1 = -diff.dot(segDir);
				const c = diff.lengthSq();
				const det = Math.abs(1 - a01 * a01);
				let s0; let s1; let sqrDist; let
					extDet;

				if (det > 0) {
					// The ray and segment are not parallel.

					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;

					if (s0 >= 0) {
						if (s1 >= -extDet) {
							if (s1 <= extDet) {
								// region 0
								// Minimum at interior points of ray and segment.

								const invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
							} else {
								// region 1

								s1 = segExtent;
								s0 = Math.max(0, -(a01 * s1 + b0));
								sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
							}
						} else {
							// region 5

							s1 = -segExtent;
							s0 = Math.max(0, -(a01 * s1 + b0));
							sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
						}
					} else if (s1 <= -extDet) {
						// region 4

						s0 = Math.max(0, -(-a01 * segExtent + b0));
						s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					} else if (s1 <= extDet) {
						// region 3

						s0 = 0;
						s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = s1 * (s1 + 2 * b1) + c;
					} else {
						// region 2

						s0 = Math.max(0, -(a01 * segExtent + b0));
						s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					}
				} else {
					// Ray and segment are parallel.

					s1 = (a01 > 0) ? -segExtent : segExtent;
					s0 = Math.max(0, -(a01 * s1 + b0));
					sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
				}

				if (optionalPointOnRay) {
					optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
				}

				if (optionalPointOnSegment) {
					optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
				}

				return sqrDist;
			};
		}()),

		intersectSphere: (function () {
			const v1 = new Vector3();

			return function intersectSphere(sphere, target) {
				v1.subVectors(sphere.center, this.origin);
				const tca = v1.dot(this.direction);
				const d2 = v1.dot(v1) - tca * tca;
				const radius2 = sphere.radius * sphere.radius;

				if (d2 > radius2) return null;

				const thc = Math.sqrt(radius2 - d2);

				// t0 = first intersect point - entrance on front of sphere
				const t0 = tca - thc;

				// t1 = second intersect point - exit point on back of sphere
				const t1 = tca + thc;

				// test to see if both t0 and t1 are behind the ray - if so, return null
				if (t0 < 0 && t1 < 0) return null;

				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if (t0 < 0) return this.at(t1, target);

				// else t0 is in front of the ray, so return the first collision point scaled by t0
				return this.at(t0, target);
			};
		}()),

		intersectsSphere(sphere) {
			return this.distanceSqToPoint(sphere.center) <= (sphere.radius * sphere.radius);
		},

		distanceToPlane(plane) {
			const denominator = plane.normal.dot(this.direction);

			if (denominator === 0) {
				// line is coplanar, return origin
				if (plane.distanceToPoint(this.origin) === 0) {
					return 0;
				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;
			}

			const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t : null;
		},

		intersectPlane(plane, target) {
			const t = this.distanceToPlane(plane);

			if (t === null) {
				return null;
			}

			return this.at(t, target);
		},

		intersectsPlane(plane) {
			// check if the ray lies on the plane first

			const distToPoint = plane.distanceToPoint(this.origin);

			if (distToPoint === 0) {
				return true;
			}

			const denominator = plane.normal.dot(this.direction);

			if (denominator * distToPoint < 0) {
				return true;
			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;
		},

		intersectBox(box, target) {
			let tmin; let tmax; let tymin; let tymax; let tzmin; let
				tzmax;

			const invdirx = 1 / this.direction.x;
			const invdiry = 1 / this.direction.y;
			const invdirz = 1 / this.direction.z;

			const { origin } = this;

			if (invdirx >= 0) {
				tmin = (box.min.x - origin.x) * invdirx;
				tmax = (box.max.x - origin.x) * invdirx;
			} else {
				tmin = (box.max.x - origin.x) * invdirx;
				tmax = (box.min.x - origin.x) * invdirx;
			}

			if (invdiry >= 0) {
				tymin = (box.min.y - origin.y) * invdiry;
				tymax = (box.max.y - origin.y) * invdiry;
			} else {
				tymin = (box.max.y - origin.y) * invdiry;
				tymax = (box.min.y - origin.y) * invdiry;
			}

			if ((tmin > tymax) || (tymin > tmax)) return null;

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if (tymin > tmin || tmin !== tmin) tmin = tymin;

			if (tymax < tmax || tmax !== tmax) tmax = tymax;

			if (invdirz >= 0) {
				tzmin = (box.min.z - origin.z) * invdirz;
				tzmax = (box.max.z - origin.z) * invdirz;
			} else {
				tzmin = (box.max.z - origin.z) * invdirz;
				tzmax = (box.min.z - origin.z) * invdirz;
			}

			if ((tmin > tzmax) || (tzmin > tmax)) return null;

			if (tzmin > tmin || tmin !== tmin) tmin = tzmin;

			if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

			// return point closest to the ray (positive side)

			if (tmax < 0) return null;

			return this.at(tmin >= 0 ? tmin : tmax, target);
		},

		intersectsBox: (function () {
			const v = new Vector3();

			return function intersectsBox(box) {
				return this.intersectBox(box, v) !== null;
			};
		}()),

		intersectTriangle: (function () {
			// Compute the offset origin, edges, and normal.
			const diff = new Vector3();
			const edge1 = new Vector3();
			const edge2 = new Vector3();
			const normal = new Vector3();

			return function intersectTriangle(a, b, c, backfaceCulling, target) {
				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

				edge1.subVectors(b, a);
				edge2.subVectors(c, a);
				normal.crossVectors(edge1, edge2);

				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				let DdN = this.direction.dot(normal);
				let sign;

				if (DdN > 0) {
					if (backfaceCulling) return null;
					sign = 1;
				} else if (DdN < 0) {
					sign = -1;
					DdN = -DdN;
				} else {
					return null;
				}

				diff.subVectors(this.origin, a);
				const DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));

				// b1 < 0, no intersection
				if (DdQxE2 < 0) {
					return null;
				}

				const DdE1xQ = sign * this.direction.dot(edge1.cross(diff));

				// b2 < 0, no intersection
				if (DdE1xQ < 0) {
					return null;
				}

				// b1+b2 > 1, no intersection
				if (DdQxE2 + DdE1xQ > DdN) {
					return null;
				}

				// Line intersects triangle, check if ray does.
				const QdN = -sign * diff.dot(normal);

				// t < 0, no intersection
				if (QdN < 0) {
					return null;
				}

				// Ray intersects triangle.
				return this.at(QdN / DdN, target);
			};
		}()),

		applyMatrix4(matrix4) {
			this.origin.applyMatrix4(matrix4);
			this.direction.transformDirection(matrix4);

			return this;
		},

		equals(ray) {
			return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
		},

	});

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Triangle(a, b, c) {
		this.a = (a !== undefined) ? a : new Vector3();
		this.b = (b !== undefined) ? b : new Vector3();
		this.c = (c !== undefined) ? c : new Vector3();
	}

	Object.assign(Triangle, {

		getNormal: (function () {
			const v0 = new Vector3();

			return function getNormal(a, b, c, target) {
				if (target === undefined) {
					console.warn('THREE.Triangle: .getNormal() target is now required');
					target = new Vector3();
				}

				target.subVectors(c, b);
				v0.subVectors(a, b);
				target.cross(v0);

				const targetLengthSq = target.lengthSq();
				if (targetLengthSq > 0) {
					return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
				}

				return target.set(0, 0, 0);
			};
		}()),

		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		getBarycoord: (function () {
			const v0 = new Vector3();
			const v1 = new Vector3();
			const v2 = new Vector3();

			return function getBarycoord(point, a, b, c, target) {
				v0.subVectors(c, a);
				v1.subVectors(b, a);
				v2.subVectors(point, a);

				const dot00 = v0.dot(v0);
				const dot01 = v0.dot(v1);
				const dot02 = v0.dot(v2);
				const dot11 = v1.dot(v1);
				const dot12 = v1.dot(v2);

				const denom = (dot00 * dot11 - dot01 * dot01);

				if (target === undefined) {
					console.warn('THREE.Triangle: .getBarycoord() target is now required');
					target = new Vector3();
				}

				// collinear or singular triangle
				if (denom === 0) {
					// arbitrary location outside of triangle?
					// not sure if this is the best idea, maybe should be returning undefined
					return target.set(-2, -1, -1);
				}

				const invDenom = 1 / denom;
				const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
				const v = (dot00 * dot12 - dot01 * dot02) * invDenom;

				// barycentric coordinates must always sum to 1
				return target.set(1 - u - v, v, u);
			};
		}()),

		containsPoint: (function () {
			const v1 = new Vector3();

			return function containsPoint(point, a, b, c) {
				Triangle.getBarycoord(point, a, b, c, v1);

				return (v1.x >= 0) && (v1.y >= 0) && ((v1.x + v1.y) <= 1);
			};
		}()),

		getUV: (function () {
			const barycoord = new Vector3();

			return function getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
				this.getBarycoord(point, p1, p2, p3, barycoord);

				target.set(0, 0);
				target.addScaledVector(uv1, barycoord.x);
				target.addScaledVector(uv2, barycoord.y);
				target.addScaledVector(uv3, barycoord.z);

				return target;
			};
		}()),

	});

	Object.assign(Triangle.prototype, {

		set(a, b, c) {
			this.a.copy(a);
			this.b.copy(b);
			this.c.copy(c);

			return this;
		},

		setFromPointsAndIndices(points, i0, i1, i2) {
			this.a.copy(points[i0]);
			this.b.copy(points[i1]);
			this.c.copy(points[i2]);

			return this;
		},

		clone() {
			return new this.constructor().copy(this);
		},

		copy(triangle) {
			this.a.copy(triangle.a);
			this.b.copy(triangle.b);
			this.c.copy(triangle.c);

			return this;
		},

		getArea: (function () {
			const v0 = new Vector3();
			const v1 = new Vector3();

			return function getArea() {
				v0.subVectors(this.c, this.b);
				v1.subVectors(this.a, this.b);

				return v0.cross(v1).length() * 0.5;
			};
		}()),

		getMidpoint(target) {
			if (target === undefined) {
				console.warn('THREE.Triangle: .getMidpoint() target is now required');
				target = new Vector3();
			}

			return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
		},

		getNormal(target) {
			return Triangle.getNormal(this.a, this.b, this.c, target);
		},

		getPlane(target) {
			if (target === undefined) {
				console.warn('THREE.Triangle: .getPlane() target is now required');
				target = new Vector3();
			}

			return target.setFromCoplanarPoints(this.a, this.b, this.c);
		},

		getBarycoord(point, target) {
			return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
		},

		containsPoint(point) {
			return Triangle.containsPoint(point, this.a, this.b, this.c);
		},

		getUV(point, uv1, uv2, uv3, result) {
			return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, result);
		},

		intersectsBox(box) {
			return box.intersectsTriangle(this);
		},

		closestPointToPoint: (function () {
			const vab = new Vector3();
			const vac = new Vector3();
			const vbc = new Vector3();
			const vap = new Vector3();
			const vbp = new Vector3();
			const vcp = new Vector3();

			return function closestPointToPoint(p, target) {
				if (target === undefined) {
					console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
					target = new Vector3();
				}

				const { a } = this;
				const { b } = this;
				const { c } = this;
				let v; let
					w;

				// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
				// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
				// under the accompanying license; see chapter 5.1.5 for detailed explanation.
				// basically, we're distinguishing which of the voronoi regions of the triangle
				// the point lies in with the minimum amount of redundant computation.

				vab.subVectors(b, a);
				vac.subVectors(c, a);
				vap.subVectors(p, a);
				const d1 = vab.dot(vap);
				const d2 = vac.dot(vap);
				if (d1 <= 0 && d2 <= 0) {
					// vertex region of A; barycentric coords (1, 0, 0)
					return target.copy(a);
				}

				vbp.subVectors(p, b);
				const d3 = vab.dot(vbp);
				const d4 = vac.dot(vbp);
				if (d3 >= 0 && d4 <= d3) {
					// vertex region of B; barycentric coords (0, 1, 0)
					return target.copy(b);
				}

				const vc = d1 * d4 - d3 * d2;
				if (vc <= 0 && d1 >= 0 && d3 <= 0) {
					v = d1 / (d1 - d3);
					// edge region of AB; barycentric coords (1-v, v, 0)
					return target.copy(a).addScaledVector(vab, v);
				}

				vcp.subVectors(p, c);
				const d5 = vab.dot(vcp);
				const d6 = vac.dot(vcp);
				if (d6 >= 0 && d5 <= d6) {
					// vertex region of C; barycentric coords (0, 0, 1)
					return target.copy(c);
				}

				const vb = d5 * d2 - d1 * d6;
				if (vb <= 0 && d2 >= 0 && d6 <= 0) {
					w = d2 / (d2 - d6);
					// edge region of AC; barycentric coords (1-w, 0, w)
					return target.copy(a).addScaledVector(vac, w);
				}

				const va = d3 * d6 - d5 * d4;
				if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {
					vbc.subVectors(c, b);
					w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
					// edge region of BC; barycentric coords (0, 1-w, w)
					return target.copy(b).addScaledVector(vbc, w); // edge region of BC
				}

				// face region
				const denom = 1 / (va + vb + vc);
				// u = va * denom
				v = vb * denom;
				w = vc * denom;
				return target.copy(a).addScaledVector(vab, v).addScaledVector(vac, w);
			};
		}()),

		equals(triangle) {
			return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>
	 * }
	 */

	function MeshBasicMaterial(parameters) {
		Material.call(this);

		this.type = 'MeshBasicMaterial';

		this.color = new Color(0xffffff); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;

		this.lights = false;

		this.setValues(parameters);
	}

	MeshBasicMaterial.prototype = Object.create(Material.prototype);
	MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

	MeshBasicMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);

		this.color.copy(source.color);

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		return this;
	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */

	function Mesh(geometry, material) {
		Object3D.call(this);

		this.type = 'Mesh';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new MeshBasicMaterial({ color: Math.random() * 0xffffff });

		this.drawMode = TrianglesDrawMode;

		this.updateMorphTargets();
	}

	Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {

		constructor: Mesh,

		isMesh: true,

		setDrawMode(value) {
			this.drawMode = value;
		},

		copy(source) {
			Object3D.prototype.copy.call(this, source);

			this.drawMode = source.drawMode;

			if (source.morphTargetInfluences !== undefined) {
				this.morphTargetInfluences = source.morphTargetInfluences.slice();
			}

			if (source.morphTargetDictionary !== undefined) {
				this.morphTargetDictionary = { ...source.morphTargetDictionary };
			}

			return this;
		},

		updateMorphTargets() {
			const { geometry } = this;
			let m; let ml; let
				name;

			if (geometry.isBufferGeometry) {
				const { morphAttributes } = geometry;
				const keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					const morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (m = 0, ml = morphAttribute.length; m < ml; m++) {
							name = morphAttribute[m].name || String(m);

							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				const { morphTargets } = geometry;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		},

		raycast: (function () {
			const inverseMatrix = new Matrix4();
			const ray = new Ray();
			const sphere = new Sphere();

			const vA = new Vector3();
			const vB = new Vector3();
			const vC = new Vector3();

			const tempA = new Vector3();
			const tempB = new Vector3();
			const tempC = new Vector3();

			const uvA = new Vector2();
			const uvB = new Vector2();
			const uvC = new Vector2();

			const intersectionPoint = new Vector3();
			const intersectionPointWorld = new Vector3();

			function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
				let intersect;

				if (material.side === BackSide) {
					intersect = ray.intersectTriangle(pC, pB, pA, true, point);
				} else {
					intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
				}

				if (intersect === null) return null;

				intersectionPointWorld.copy(point);
				intersectionPointWorld.applyMatrix4(object.matrixWorld);

				const distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);

				if (distance < raycaster.near || distance > raycaster.far) return null;

				return {
					distance,
					point: intersectionPointWorld.clone(),
					object,
				};
			}

			function checkBufferGeometryIntersection(object, material, raycaster, ray, position, uv, a, b, c) {
				vA.fromBufferAttribute(position, a);
				vB.fromBufferAttribute(position, b);
				vC.fromBufferAttribute(position, c);

				const intersection = checkIntersection(object, material, raycaster, ray, vA, vB, vC, intersectionPoint);

				if (intersection) {
					if (uv) {
						uvA.fromBufferAttribute(uv, a);
						uvB.fromBufferAttribute(uv, b);
						uvC.fromBufferAttribute(uv, c);

						intersection.uv = Triangle.getUV(intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2());
					}

					const face = new Face3(a, b, c);
					Triangle.getNormal(vA, vB, vC, face.normal);

					intersection.face = face;
				}

				return intersection;
			}

			return function raycast(raycaster, intersects) {
				const { geometry } = this;
				const { material } = this;
				const { matrixWorld } = this;

				if (material === undefined) return;

				// Checking boundingSphere distance to ray

				if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

				sphere.copy(geometry.boundingSphere);
				sphere.applyMatrix4(matrixWorld);

				if (raycaster.ray.intersectsSphere(sphere) === false) return;

				//

				inverseMatrix.getInverse(matrixWorld);
				ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

				// Check boundingBox before continuing

				if (geometry.boundingBox !== null) {
					if (ray.intersectsBox(geometry.boundingBox) === false) return;
				}

				let intersection;

				if (geometry.isBufferGeometry) {
					let a; let b; let
						c;
					const { index } = geometry;
					const { position } = geometry.attributes;
					const { uv } = geometry.attributes;
					const { groups } = geometry;
					const { drawRange } = geometry;
					let i; let j; let il; let
						jl;
					let group; let
						groupMaterial;
					let start; let
						end;

					if (index !== null) {
						// indexed buffer geometry

						if (Array.isArray(material)) {
							for (i = 0, il = groups.length; i < il; i++) {
								group = groups[i];
								groupMaterial = material[group.materialIndex];

								start = Math.max(group.start, drawRange.start);
								end = Math.min((group.start + group.count), (drawRange.start + drawRange.count));

								for (j = start, jl = end; j < jl; j += 3) {
									a = index.getX(j);
									b = index.getX(j + 1);
									c = index.getX(j + 2);

									intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, ray, position, uv, a, b, c);

									if (intersection) {
										intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
										intersects.push(intersection);
									}
								}
							}
						} else {
							start = Math.max(0, drawRange.start);
							end = Math.min(index.count, (drawRange.start + drawRange.count));

							for (i = start, il = end; i < il; i += 3) {
								a = index.getX(i);
								b = index.getX(i + 1);
								c = index.getX(i + 2);

								intersection = checkBufferGeometryIntersection(this, material, raycaster, ray, position, uv, a, b, c);

								if (intersection) {
									intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics
									intersects.push(intersection);
								}
							}
						}
					} else if (position !== undefined) {
						// non-indexed buffer geometry

						if (Array.isArray(material)) {
							for (i = 0, il = groups.length; i < il; i++) {
								group = groups[i];
								groupMaterial = material[group.materialIndex];

								start = Math.max(group.start, drawRange.start);
								end = Math.min((group.start + group.count), (drawRange.start + drawRange.count));

								for (j = start, jl = end; j < jl; j += 3) {
									a = j;
									b = j + 1;
									c = j + 2;

									intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, ray, position, uv, a, b, c);

									if (intersection) {
										intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics
										intersects.push(intersection);
									}
								}
							}
						} else {
							start = Math.max(0, drawRange.start);
							end = Math.min(position.count, (drawRange.start + drawRange.count));

							for (i = start, il = end; i < il; i += 3) {
								a = i;
								b = i + 1;
								c = i + 2;

								intersection = checkBufferGeometryIntersection(this, material, raycaster, ray, position, uv, a, b, c);

								if (intersection) {
									intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics
									intersects.push(intersection);
								}
							}
						}
					}
				} else if (geometry.isGeometry) {
					let fvA; let fvB; let
						fvC;
					const isMultiMaterial = Array.isArray(material);

					const { vertices } = geometry;
					const { faces } = geometry;
					let uvs;

					const faceVertexUvs = geometry.faceVertexUvs[0];
					if (faceVertexUvs.length > 0) uvs = faceVertexUvs;

					for (let f = 0, fl = faces.length; f < fl; f++) {
						const face = faces[f];
						const faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;

						if (faceMaterial === undefined) continue;

						fvA = vertices[face.a];
						fvB = vertices[face.b];
						fvC = vertices[face.c];

						if (faceMaterial.morphTargets === true) {
							const { morphTargets } = geometry;
							const morphInfluences = this.morphTargetInfluences;

							vA.set(0, 0, 0);
							vB.set(0, 0, 0);
							vC.set(0, 0, 0);

							for (let t = 0, tl = morphTargets.length; t < tl; t++) {
								const influence = morphInfluences[t];

								if (influence === 0) continue;

								const targets = morphTargets[t].vertices;

								vA.addScaledVector(tempA.subVectors(targets[face.a], fvA), influence);
								vB.addScaledVector(tempB.subVectors(targets[face.b], fvB), influence);
								vC.addScaledVector(tempC.subVectors(targets[face.c], fvC), influence);
							}

							vA.add(fvA);
							vB.add(fvB);
							vC.add(fvC);

							fvA = vA;
							fvB = vB;
							fvC = vC;
						}

						intersection = checkIntersection(this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint);

						if (intersection) {
							if (uvs && uvs[f]) {
								const uvs_f = uvs[f];
								uvA.copy(uvs_f[0]);
								uvB.copy(uvs_f[1]);
								uvC.copy(uvs_f[2]);

								intersection.uv = Triangle.getUV(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2());
							}

							intersection.face = face;
							intersection.faceIndex = f;
							intersects.push(intersection);
						}
					}
				}
			};
		}()),

		clone() {
			return new this.constructor(this.geometry, this.material).copy(this);
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLBackground(renderer, state, objects, premultipliedAlpha) {
		const clearColor = new Color(0x000000);
		let clearAlpha = 0;

		let planeMesh;
		let boxMesh;
		// Store the current background texture and its `version`
		// so we can recompile the material accordingly.
		let currentBackground = null;
		let currentBackgroundVersion = 0;

		function render(renderList, scene, camera, forceClear) {
			const { background } = scene;

			if (background === null) {
				setClear(clearColor, clearAlpha);
				currentBackground = null;
				currentBackgroundVersion = 0;
			} else if (background && background.isColor) {
				setClear(background, 1);
				forceClear = true;
				currentBackground = null;
				currentBackgroundVersion = 0;
			}

			if (renderer.autoClear || forceClear) {
				renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
			}

			if (background && (background.isCubeTexture || background.isWebGLRenderTargetCube)) {
				if (boxMesh === undefined) {
					boxMesh = new Mesh(
						new BoxBufferGeometry(1, 1, 1),
						new ShaderMaterial({
							type: 'BackgroundCubeMaterial',
							uniforms: cloneUniforms(ShaderLib.cube.uniforms),
							vertexShader: ShaderLib.cube.vertexShader,
							fragmentShader: ShaderLib.cube.fragmentShader,
							side: BackSide,
							depthTest: true,
							depthWrite: false,
							fog: false,
						}),
					);

					boxMesh.geometry.removeAttribute('normal');
					boxMesh.geometry.removeAttribute('uv');

					boxMesh.onBeforeRender = function (renderer, scene, camera) {
						this.matrixWorld.copyPosition(camera.matrixWorld);
					};

					// enable code injection for non-built-in material
					Object.defineProperty(boxMesh.material, 'map', {

						get() {
							return this.uniforms.tCube.value;
						},

					});

					objects.update(boxMesh);
				}

				const texture = background.isWebGLRenderTargetCube ? background.texture : background;
				boxMesh.material.uniforms.tCube.value = texture;
				boxMesh.material.uniforms.tFlip.value = (background.isWebGLRenderTargetCube) ? 1 : -1;

				if (currentBackground !== background
				     || currentBackgroundVersion !== texture.version) {
					boxMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = texture.version;
				}

				// push to the pre-sorted opaque render list
				renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, null);
			} else if (background && background.isTexture) {
				if (planeMesh === undefined) {
					planeMesh = new Mesh(
						new PlaneBufferGeometry(2, 2),
						new ShaderMaterial({
							type: 'BackgroundMaterial',
							uniforms: cloneUniforms(ShaderLib.background.uniforms),
							vertexShader: ShaderLib.background.vertexShader,
							fragmentShader: ShaderLib.background.fragmentShader,
							side: FrontSide,
							depthTest: false,
							depthWrite: false,
							fog: false,
						}),
					);

					planeMesh.geometry.removeAttribute('normal');

					// enable code injection for non-built-in material
					Object.defineProperty(planeMesh.material, 'map', {

						get() {
							return this.uniforms.t2D.value;
						},

					});

					objects.update(planeMesh);
				}

				planeMesh.material.uniforms.t2D.value = background;

				if (background.matrixAutoUpdate === true) {
					background.updateMatrix();
				}

				planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

				if (currentBackground !== background
					   || currentBackgroundVersion !== background.version) {
					planeMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;
				}


				// push to the pre-sorted opaque render list
				renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, null);
			}
		}

		function setClear(color, alpha) {
			state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
		}

		return {

			getClearColor() {
				return clearColor;
			},
			setClearColor(color, alpha) {
				clearColor.set(color);
				clearAlpha = alpha !== undefined ? alpha : 1;
				setClear(clearColor, clearAlpha);
			},
			getClearAlpha() {
				return clearAlpha;
			},
			setClearAlpha(alpha) {
				clearAlpha = alpha;
				setClear(clearColor, clearAlpha);
			},
			render,

		};
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLBufferRenderer(gl, extensions, info, capabilities) {
		let mode;

		function setMode(value) {
			mode = value;
		}

		function render(start, count) {
			gl.drawArrays(mode, start, count);

			info.update(count, mode);
		}

		function renderInstances(geometry, start, count) {
			let extension;

			if (capabilities.isWebGL2) {
				extension = gl;
			} else {
				extension = extensions.get('ANGLE_instanced_arrays');

				if (extension === null) {
					console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
					return;
				}
			}

			extension[capabilities.isWebGL2 ? 'drawArraysInstanced' : 'drawArraysInstancedANGLE'](mode, start, count, geometry.maxInstancedCount);

			info.update(count, mode, geometry.maxInstancedCount);
		}

		//

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLCapabilities(gl, extensions, parameters) {
		let maxAnisotropy;

		function getMaxAnisotropy() {
			if (maxAnisotropy !== undefined) return maxAnisotropy;

			const extension = extensions.get('EXT_texture_filter_anisotropic');

			if (extension !== null) {
				maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
			} else {
				maxAnisotropy = 0;
			}

			return maxAnisotropy;
		}

		function getMaxPrecision(precision) {
			if (precision === 'highp') {
				if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0
				     && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
					return 'highp';
				}

				precision = 'mediump';
			}

			if (precision === 'mediump') {
				if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0
				     && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
					return 'mediump';
				}
			}

			return 'lowp';
		}

		const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;

		let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		const maxPrecision = getMaxPrecision(precision);

		if (maxPrecision !== precision) {
			console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
			precision = maxPrecision;
		}

		const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

		const maxTextures = gl.getParameter(34930);
		const maxVertexTextures = gl.getParameter(35660);
		const maxTextureSize = gl.getParameter(3379);
		const maxCubemapSize = gl.getParameter(34076);

		const maxAttributes = gl.getParameter(34921);
		const maxVertexUniforms = gl.getParameter(36347);
		const maxVaryings = gl.getParameter(36348);
		const maxFragmentUniforms = gl.getParameter(36349);

		const vertexTextures = maxVertexTextures > 0;
		const floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
		const floatVertexTextures = vertexTextures && floatFragmentTextures;

		return {

			isWebGL2,

			getMaxAnisotropy,
			getMaxPrecision,

			precision,
			logarithmicDepthBuffer,

			maxTextures,
			maxVertexTextures,
			maxTextureSize,
			maxCubemapSize,

			maxAttributes,
			maxVertexUniforms,
			maxVaryings,
			maxFragmentUniforms,

			vertexTextures,
			floatFragmentTextures,
			floatVertexTextures,

		};
	}

	/**
	 * @author tschw
	 */

	function WebGLClipping() {
		const scope = this;

		let globalState = null;
		let numGlobalPlanes = 0;
		let localClippingEnabled = false;
		let renderingShadows = false;

		const plane = new Plane();
		const viewNormalMatrix = new Matrix3();

		const uniform = { value: null, needsUpdate: false };

		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function (planes, enableLocalClipping, camera) {
			const enabled =				planes.length !== 0
				|| enableLocalClipping
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				|| numGlobalPlanes !== 0
				|| localClippingEnabled;

			localClippingEnabled = enableLocalClipping;

			globalState = projectPlanes(planes, camera, 0);
			numGlobalPlanes = planes.length;

			return enabled;
		};

		this.beginShadows = function () {
			renderingShadows = true;
			projectPlanes(null);
		};

		this.endShadows = function () {
			renderingShadows = false;
			resetGlobalState();
		};

		this.setState = function (planes, clipIntersection, clipShadows, camera, cache, fromCache) {
			if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
				// there's no local clipping

				if (renderingShadows) {
					// there's no global clipping

					projectPlanes(null);
				} else {
					resetGlobalState();
				}
			} else {
				const nGlobal = renderingShadows ? 0 : numGlobalPlanes;
				const lGlobal = nGlobal * 4;

				let dstArray = cache.clippingState || null;

				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes(planes, camera, lGlobal, fromCache);

				for (let i = 0; i !== lGlobal; ++i) {
					dstArray[i] = globalState[i];
				}

				cache.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;
			}
		};

		function resetGlobalState() {
			if (uniform.value !== globalState) {
				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;
			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;
		}

		function projectPlanes(planes, camera, dstOffset, skipTransform) {
			const nPlanes = planes !== null ? planes.length : 0;
			let dstArray = null;

			if (nPlanes !== 0) {
				dstArray = uniform.value;

				if (skipTransform !== true || dstArray === null) {
					const flatSize = dstOffset + nPlanes * 4;
					const viewMatrix = camera.matrixWorldInverse;

					viewNormalMatrix.getNormalMatrix(viewMatrix);

					if (dstArray === null || dstArray.length < flatSize) {
						dstArray = new Float32Array(flatSize);
					}

					for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
						plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);

						plane.normal.toArray(dstArray, i4);
						dstArray[i4 + 3] = plane.constant;
					}
				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;
			}

			scope.numPlanes = nPlanes;

			return dstArray;
		}
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLExtensions(gl) {
		const extensions = {};

		return {

			get(name) {
				if (extensions[name] !== undefined) {
					return extensions[name];
				}

				let extension;

				switch (name) {
				case 'WEBGL_depth_texture':
					extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
					break;

				default:
					extension = gl.getExtension(name);
				}

				if (extension === null) {
					console.warn(`THREE.WebGLRenderer: ${name} extension not supported.`);
				}

				extensions[name] = extension;

				return extension;
			},

		};
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLGeometries(gl, attributes, info) {
		const geometries = {};
		const wireframeAttributes = {};

		function onGeometryDispose(event) {
			const geometry = event.target;
			const buffergeometry = geometries[geometry.id];

			if (buffergeometry.index !== null) {
				attributes.remove(buffergeometry.index);
			}

			for (const name in buffergeometry.attributes) {
				attributes.remove(buffergeometry.attributes[name]);
			}

			geometry.removeEventListener('dispose', onGeometryDispose);

			delete geometries[geometry.id];

			const attribute = wireframeAttributes[buffergeometry.id];

			if (attribute) {
				attributes.remove(attribute);
				delete wireframeAttributes[buffergeometry.id];
			}

			//

			info.memory.geometries--;
		}

		function get(object, geometry) {
			let buffergeometry = geometries[geometry.id];

			if (buffergeometry) return buffergeometry;

			geometry.addEventListener('dispose', onGeometryDispose);

			if (geometry.isBufferGeometry) {
				buffergeometry = geometry;
			} else if (geometry.isGeometry) {
				if (geometry._bufferGeometry === undefined) {
					geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
				}

				buffergeometry = geometry._bufferGeometry;
			}

			geometries[geometry.id] = buffergeometry;

			info.memory.geometries++;

			return buffergeometry;
		}

		function update(geometry) {
			const { index } = geometry;
			const geometryAttributes = geometry.attributes;

			if (index !== null) {
				attributes.update(index, 34963);
			}

			for (var name in geometryAttributes) {
				attributes.update(geometryAttributes[name], 34962);
			}

			// morph targets

			const { morphAttributes } = geometry;

			for (var name in morphAttributes) {
				const array = morphAttributes[name];

				for (let i = 0, l = array.length; i < l; i++) {
					attributes.update(array[i], 34962);
				}
			}
		}

		function getWireframeAttribute(geometry) {
			let attribute = wireframeAttributes[geometry.id];

			if (attribute) return attribute;

			const indices = [];

			const geometryIndex = geometry.index;
			const geometryAttributes = geometry.attributes;

			// console.time( 'wireframe' );

			if (geometryIndex !== null) {
				var { array } = geometryIndex;

				for (var i = 0, l = array.length; i < l; i += 3) {
					var a = array[i + 0];
					var b = array[i + 1];
					var c = array[i + 2];

					indices.push(a, b, b, c, c, a);
				}
			} else {
				var { array } = geometryAttributes.position;

				for (var i = 0, l = (array.length / 3) - 1; i < l; i += 3) {
					var a = i + 0;
					var b = i + 1;
					var c = i + 2;

					indices.push(a, b, b, c, c, a);
				}
			}

			// console.timeEnd( 'wireframe' );

			attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);

			attributes.update(attribute, 34963);

			wireframeAttributes[geometry.id] = attribute;

			return attribute;
		}

		return {

			get,
			update,

			getWireframeAttribute,

		};
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
		let mode;

		function setMode(value) {
			mode = value;
		}

		let type; let
			bytesPerElement;

		function setIndex(value) {
			type = value.type;
			bytesPerElement = value.bytesPerElement;
		}

		function render(start, count) {
			gl.drawElements(mode, count, type, start * bytesPerElement);

			info.update(count, mode);
		}

		function renderInstances(geometry, start, count) {
			var extension;

			if (capabilities.isWebGL2) {
				extension = gl;
			} else {
				var extension = extensions.get('ANGLE_instanced_arrays');

				if (extension === null) {
					console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
					return;
				}
			}

			extension[capabilities.isWebGL2 ? 'drawElementsInstanced' : 'drawElementsInstancedANGLE'](mode, count, type, start * bytesPerElement, geometry.maxInstancedCount);

			info.update(count, mode, geometry.maxInstancedCount);
		}

		//

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;
	}

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WebGLInfo(gl) {
		const memory = {
			geometries: 0,
			textures: 0,
		};

		const render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0,
		};

		function update(count, mode, instanceCount) {
			instanceCount = instanceCount || 1;

			render.calls++;

			switch (mode) {
			case 4:
				render.triangles += instanceCount * (count / 3);
				break;

			case 5:
			case 6:
				render.triangles += instanceCount * (count - 2);
				break;

			case 1:
				render.lines += instanceCount * (count / 2);
				break;

			case 3:
				render.lines += instanceCount * (count - 1);
				break;

			case 2:
				render.lines += instanceCount * count;
				break;

			case 0:
				render.points += instanceCount * count;
				break;

			default:
				console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
				break;
			}
		}

		function reset() {
			render.frame++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;
		}

		return {
			memory,
			render,
			programs: null,
			autoReset: true,
			reset,
			update,
		};
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function absNumericalSort(a, b) {
		return Math.abs(b[1]) - Math.abs(a[1]);
	}

	function WebGLMorphtargets(gl) {
		const influencesList = {};
		const morphInfluences = new Float32Array(8);

		function update(object, geometry, material, program) {
			const objectInfluences = object.morphTargetInfluences;

			const { length } = objectInfluences;

			let influences = influencesList[geometry.id];

			if (influences === undefined) {
				// initialise list

				influences = [];

				for (var i = 0; i < length; i++) {
					influences[i] = [i, 0];
				}

				influencesList[geometry.id] = influences;
			}

			const morphTargets = material.morphTargets && geometry.morphAttributes.position;
			const morphNormals = material.morphNormals && geometry.morphAttributes.normal;

			// Remove current morphAttributes

			for (var i = 0; i < length; i++) {
				var influence = influences[i];

				if (influence[1] !== 0) {
					if (morphTargets) geometry.removeAttribute(`morphTarget${i}`);
					if (morphNormals) geometry.removeAttribute(`morphNormal${i}`);
				}
			}

			// Collect influences

			for (var i = 0; i < length; i++) {
				var influence = influences[i];

				influence[0] = i;
				influence[1] = objectInfluences[i];
			}

			influences.sort(absNumericalSort);

			// Add morphAttributes

			for (var i = 0; i < 8; i++) {
				var influence = influences[i];

				if (influence) {
					const index = influence[0];
					const value = influence[1];

					if (value) {
						if (morphTargets) geometry.addAttribute(`morphTarget${i}`, morphTargets[index]);
						if (morphNormals) geometry.addAttribute(`morphNormal${i}`, morphNormals[index]);

						morphInfluences[i] = value;
						continue;
					}
				}

				morphInfluences[i] = 0;
			}

			program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
		}

		return {

			update,

		};
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLObjects(geometries, info) {
		let updateList = {};

		function update(object) {
			const { frame } = info.render;

			const { geometry } = object;
			const buffergeometry = geometries.get(object, geometry);

			// Update once per frame

			if (updateList[buffergeometry.id] !== frame) {
				if (geometry.isGeometry) {
					buffergeometry.updateFromObject(object);
				}

				geometries.update(buffergeometry);

				updateList[buffergeometry.id] = frame;
			}

			return buffergeometry;
		}

		function dispose() {
			updateList = {};
		}

		return {

			update,
			dispose,

		};
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

		Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

		this.flipY = false;
	}

	CubeTexture.prototype = Object.create(Texture.prototype);
	CubeTexture.prototype.constructor = CubeTexture;

	CubeTexture.prototype.isCubeTexture = true;

	Object.defineProperty(CubeTexture.prototype, 'images', {

		get() {
			return this.image;
		},

		set(value) {
			this.image = value;
		},

	});

	/**
	 * @author Artur Trzesiok
	 */

	function DataTexture3D(data, width, height, depth) {
		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in DataTexture3D directly.
		//
		//	var texture = new THREE.DataTexture3D( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839

		Texture.call(this, null);

		this.image = {
			data, width, height, depth,
		};

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.generateMipmaps = false;
		this.flipY = false;
	}

	DataTexture3D.prototype = Object.create(Texture.prototype);
	DataTexture3D.prototype.constructor = DataTexture3D;
	DataTexture3D.prototype.isDataTexture3D = true;

	/**
	 * @author tschw
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [renderer] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'renderer' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (renderer factorizations):
	 *
	 * .upload( gl, seq, values, renderer )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (renderer factorizations):
	 *
	 * .setValue( gl, name, value )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .set( gl, obj, prop )
	 *
	 * 		sets uniform from object and property with same name than uniform
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */

	const emptyTexture = new Texture();
	const emptyTexture3d = new DataTexture3D();
	const emptyCubeTexture = new CubeTexture();

	// --- Base for inner nodes (including the root) ---

	function UniformContainer() {
		this.seq = [];
		this.map = {};
	}

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

	const arrayCacheF32 = [];
	const arrayCacheI32 = [];

	// Float32Array caches used for uploading Matrix uniforms

	const mat4array = new Float32Array(16);
	const mat3array = new Float32Array(9);
	const mat2array = new Float32Array(4);

	// Flattening for arrays of vectors and matrices

	function flatten(array, nBlocks, blockSize) {
		const firstElem = array[0];

		if (firstElem <= 0 || firstElem > 0) return array;
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		const n = nBlocks * blockSize;
		let r = arrayCacheF32[n];

		if (r === undefined) {
			r = new Float32Array(n);
			arrayCacheF32[n] = r;
		}

		if (nBlocks !== 0) {
			firstElem.toArray(r, 0);

			for (let i = 1, offset = 0; i !== nBlocks; ++i) {
				offset += blockSize;
				array[i].toArray(r, offset);
			}
		}

		return r;
	}

	function arraysEqual(a, b) {
		if (a.length !== b.length) return false;

		for (let i = 0, l = a.length; i < l; i++) {
			if (a[i] !== b[i]) return false;
		}

		return true;
	}

	function copyArray(a, b) {
		for (let i = 0, l = b.length; i < l; i++) {
			a[i] = b[i];
		}
	}

	// Texture unit allocation

	function allocTexUnits(renderer, n) {
		let r = arrayCacheI32[n];

		if (r === undefined) {
			r = new Int32Array(n);
			arrayCacheI32[n] = r;
		}

		for (let i = 0; i !== n; ++i) r[i] = renderer.allocTextureUnit();

		return r;
	}

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

	// Single scalar

	function setValue1f(gl, v) {
		const { cache } = this;

		if (cache[0] === v) return;

		gl.uniform1f(this.addr, v);

		cache[0] = v;
	}

	function setValue1i(gl, v) {
		const { cache } = this;

		if (cache[0] === v) return;

		gl.uniform1i(this.addr, v);

		cache[0] = v;
	}

	// Single float vector (from flat array or THREE.VectorN)

	function setValue2fv(gl, v) {
		const { cache } = this;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y) {
				gl.uniform2f(this.addr, v.x, v.y);

				cache[0] = v.x;
				cache[1] = v.y;
			}
		} else {
			if (arraysEqual(cache, v)) return;

			gl.uniform2fv(this.addr, v);

			copyArray(cache, v);
		}
	}

	function setValue3fv(gl, v) {
		const { cache } = this;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
				gl.uniform3f(this.addr, v.x, v.y, v.z);

				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
			}
		} else if (v.r !== undefined) {
			if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
				gl.uniform3f(this.addr, v.r, v.g, v.b);

				cache[0] = v.r;
				cache[1] = v.g;
				cache[2] = v.b;
			}
		} else {
			if (arraysEqual(cache, v)) return;

			gl.uniform3fv(this.addr, v);

			copyArray(cache, v);
		}
	}

	function setValue4fv(gl, v) {
		const { cache } = this;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
				gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);

				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
				cache[3] = v.w;
			}
		} else {
			if (arraysEqual(cache, v)) return;

			gl.uniform4fv(this.addr, v);

			copyArray(cache, v);
		}
	}

	// Single matrix (from flat array or MatrixN)

	function setValue2fm(gl, v) {
		const { cache } = this;
		const { elements } = v;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;

			gl.uniformMatrix2fv(this.addr, false, v);

			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;

			mat2array.set(elements);

			gl.uniformMatrix2fv(this.addr, false, mat2array);

			copyArray(cache, elements);
		}
	}

	function setValue3fm(gl, v) {
		const { cache } = this;
		const { elements } = v;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;

			gl.uniformMatrix3fv(this.addr, false, v);

			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;

			mat3array.set(elements);

			gl.uniformMatrix3fv(this.addr, false, mat3array);

			copyArray(cache, elements);
		}
	}

	function setValue4fm(gl, v) {
		const { cache } = this;
		const { elements } = v;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;

			gl.uniformMatrix4fv(this.addr, false, v);

			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;

			mat4array.set(elements);

			gl.uniformMatrix4fv(this.addr, false, mat4array);

			copyArray(cache, elements);
		}
	}

	// Single texture (2D / Cube)

	function setValueT1(gl, v, renderer) {
		const { cache } = this;
		const unit = renderer.allocTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		renderer.setTexture2D(v || emptyTexture, unit);
	}

	function setValueT3D1(gl, v, renderer) {
		const { cache } = this;
		const unit = renderer.allocTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		renderer.setTexture3D(v || emptyTexture3d, unit);
	}

	function setValueT6(gl, v, renderer) {
		const { cache } = this;
		const unit = renderer.allocTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		renderer.setTextureCube(v || emptyCubeTexture, unit);
	}

	// Integer / Boolean vectors or arrays thereof (always flat arrays)

	function setValue2iv(gl, v) {
		const { cache } = this;

		if (arraysEqual(cache, v)) return;

		gl.uniform2iv(this.addr, v);

		copyArray(cache, v);
	}

	function setValue3iv(gl, v) {
		const { cache } = this;

		if (arraysEqual(cache, v)) return;

		gl.uniform3iv(this.addr, v);

		copyArray(cache, v);
	}

	function setValue4iv(gl, v) {
		const { cache } = this;

		if (arraysEqual(cache, v)) return;

		gl.uniform4iv(this.addr, v);

		copyArray(cache, v);
	}

	// Helper to pick the right setter for the singular case

	function getSingularSetter(type) {
		switch (type) {
		case 0x1406: return setValue1f; // FLOAT
		case 0x8b50: return setValue2fv; // _VEC2
		case 0x8b51: return setValue3fv; // _VEC3
		case 0x8b52: return setValue4fv; // _VEC4

		case 0x8b5a: return setValue2fm; // _MAT2
		case 0x8b5b: return setValue3fm; // _MAT3
		case 0x8b5c: return setValue4fm; // _MAT4

		case 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
		case 0x8B5F: return setValueT3D1; // SAMPLER_3D
		case 0x8b60: return setValueT6; // SAMPLER_CUBE

		case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4
		}
	}

	// Array of scalars

	function setValue1fv(gl, v) {
		const { cache } = this;

		if (arraysEqual(cache, v)) return;

		gl.uniform1fv(this.addr, v);

		copyArray(cache, v);
	}
	function setValue1iv(gl, v) {
		const { cache } = this;

		if (arraysEqual(cache, v)) return;

		gl.uniform1iv(this.addr, v);

		copyArray(cache, v);
	}

	// Array of vectors (flat or from THREE classes)

	function setValueV2a(gl, v) {
		const { cache } = this;
		const data = flatten(v, this.size, 2);

		if (arraysEqual(cache, data)) return;

		gl.uniform2fv(this.addr, data);

		this.updateCache(data);
	}

	function setValueV3a(gl, v) {
		const { cache } = this;
		const data = flatten(v, this.size, 3);

		if (arraysEqual(cache, data)) return;

		gl.uniform3fv(this.addr, data);

		this.updateCache(data);
	}

	function setValueV4a(gl, v) {
		const { cache } = this;
		const data = flatten(v, this.size, 4);

		if (arraysEqual(cache, data)) return;

		gl.uniform4fv(this.addr, data);

		this.updateCache(data);
	}

	// Array of matrices (flat or from THREE clases)

	function setValueM2a(gl, v) {
		const { cache } = this;
		const data = flatten(v, this.size, 4);

		if (arraysEqual(cache, data)) return;

		gl.uniformMatrix2fv(this.addr, false, data);

		this.updateCache(data);
	}

	function setValueM3a(gl, v) {
		const { cache } = this;
		const data = flatten(v, this.size, 9);

		if (arraysEqual(cache, data)) return;

		gl.uniformMatrix3fv(this.addr, false, data);

		this.updateCache(data);
	}

	function setValueM4a(gl, v) {
		const { cache } = this;
		const data = flatten(v, this.size, 16);

		if (arraysEqual(cache, data)) return;

		gl.uniformMatrix4fv(this.addr, false, data);

		this.updateCache(data);
	}

	// Array of textures (2D / Cube)

	function setValueT1a(gl, v, renderer) {
		const { cache } = this;
		const n = v.length;

		const units = allocTexUnits(renderer, n);

		if (arraysEqual(cache, units) === false) {
			gl.uniform1iv(this.addr, units);
			copyArray(cache, units);
		}

		for (let i = 0; i !== n; ++i) {
			renderer.setTexture2D(v[i] || emptyTexture, units[i]);
		}
	}

	function setValueT6a(gl, v, renderer) {
		const { cache } = this;
		const n = v.length;

		const units = allocTexUnits(renderer, n);

		if (arraysEqual(cache, units) === false) {
			gl.uniform1iv(this.addr, units);
			copyArray(cache, units);
		}

		for (let i = 0; i !== n; ++i) {
			renderer.setTextureCube(v[i] || emptyCubeTexture, units[i]);
		}
	}

	// Helper to pick the right setter for a pure (bottom-level) array

	function getPureArraySetter(type) {
		switch (type) {
		case 0x1406: return setValue1fv; // FLOAT
		case 0x8b50: return setValueV2a; // _VEC2
		case 0x8b51: return setValueV3a; // _VEC3
		case 0x8b52: return setValueV4a; // _VEC4

		case 0x8b5a: return setValueM2a; // _MAT2
		case 0x8b5b: return setValueM3a; // _MAT3
		case 0x8b5c: return setValueM4a; // _MAT4

		case 0x8b5e: return setValueT1a; // SAMPLER_2D
		case 0x8b60: return setValueT6a; // SAMPLER_CUBE

		case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4
		}
	}

	// --- Uniform Classes ---

	function SingleUniform(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter(activeInfo.type);

		// this.path = activeInfo.name; // DEBUG
	}

	function PureArrayUniform(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter(activeInfo.type);

		// this.path = activeInfo.name; // DEBUG
	}

	PureArrayUniform.prototype.updateCache = function (data) {
		const { cache } = this;

		if (data instanceof Float32Array && cache.length !== data.length) {
			this.cache = new Float32Array(data.length);
		}

		copyArray(cache, data);
	};

	function StructuredUniform(id) {
		this.id = id;

		UniformContainer.call(this); // mix-in
	}

	StructuredUniform.prototype.setValue = function (gl, value, renderer) {
		const { seq } = this;

		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i];
			u.setValue(gl, value[u.id], renderer);
		}
	};

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	const RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform(container, uniformObject) {
		container.seq.push(uniformObject);
		container.map[uniformObject.id] = uniformObject;
	}

	function parseUniform(activeInfo, addr, container) {
		const path = activeInfo.name;
		const pathLength = path.length;

		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;

		while (true) {
			const match = RePathPart.exec(path);
			const matchEnd = RePathPart.lastIndex;

			let id = match[1];
			const idIsIndex = match[2] === ']';
			const subscript = match[3];

			if (idIsIndex) id |= 0; // convert to integer

			if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
				// bare name or "pure" bottom-level array "[0]" suffix

				addUniform(container, subscript === undefined
					? new SingleUniform(id, activeInfo, addr)
					: new PureArrayUniform(id, activeInfo, addr));

				break;
			} else {
				// step into inner node / create it in case it doesn't exist

				const { map } = container;
				let next = map[id];

				if (next === undefined) {
					next = new StructuredUniform(id);
					addUniform(container, next);
				}

				container = next;
			}
		}
	}

	// Root Container

	function WebGLUniforms(gl, program, renderer) {
		UniformContainer.call(this);

		this.renderer = renderer;

		const n = gl.getProgramParameter(program, 35718);

		for (let i = 0; i < n; ++i) {
			const info = gl.getActiveUniform(program, i);
			const addr = gl.getUniformLocation(program, info.name);

			parseUniform(info, addr, this);
		}
	}

	WebGLUniforms.prototype.setValue = function (gl, name, value) {
		const u = this.map[name];

		if (u !== undefined) u.setValue(gl, value, this.renderer);
	};

	WebGLUniforms.prototype.setOptional = function (gl, object, name) {
		const v = object[name];

		if (v !== undefined) this.setValue(gl, name, v);
	};


	// Static interface

	WebGLUniforms.upload = function (gl, seq, values, renderer) {
		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i];
			const v = values[u.id];

			if (v.needsUpdate !== false) {
				// note: always updating when .needsUpdate is undefined
				u.setValue(gl, v.value, renderer);
			}
		}
	};

	WebGLUniforms.seqWithValue = function (seq, values) {
		const r = [];

		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i];
			if (u.id in values) r.push(u);
		}

		return r;
	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function addLineNumbers(string) {
		const lines = string.split('\n');

		for (let i = 0; i < lines.length; i++) {
			lines[i] = `${i + 1}: ${lines[i]}`;
		}

		return lines.join('\n');
	}

	function WebGLShader(gl, type, string) {
		const shader = gl.createShader(type);

		gl.shaderSource(shader, string);
		gl.compileShader(shader);

		if (gl.getShaderParameter(shader, 35713) === false) {
			console.error('THREE.WebGLShader: Shader couldn\'t compile.');
		}

		if (gl.getShaderInfoLog(shader) !== '') {
			console.warn('THREE.WebGLShader: gl.getShaderInfoLog()', type === 35633 ? 'vertex' : 'fragment', gl.getShaderInfoLog(shader), addLineNumbers(string));
		}

		// --enable-privileged-webgl-extension
		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return shader;
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	let programIdCount = 0;

	function getEncodingComponents(encoding) {
		switch (encoding) {
		case LinearEncoding:
			return ['Linear', '( value )'];
		case sRGBEncoding:
			return ['sRGB', '( value )'];
		case RGBEEncoding:
			return ['RGBE', '( value )'];
		case RGBM7Encoding:
			return ['RGBM', '( value, 7.0 )'];
		case RGBM16Encoding:
			return ['RGBM', '( value, 16.0 )'];
		case RGBDEncoding:
			return ['RGBD', '( value, 256.0 )'];
		case GammaEncoding:
			return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
		default:
			throw new Error(`unsupported encoding: ${encoding}`);
		}
	}

	function getTexelDecodingFunction(functionName, encoding) {
		const components = getEncodingComponents(encoding);
		return `vec4 ${functionName}( vec4 value ) { return ${components[0]}ToLinear${components[1]}; }`;
	}

	function getTexelEncodingFunction(functionName, encoding) {
		const components = getEncodingComponents(encoding);
		return `vec4 ${functionName}( vec4 value ) { return LinearTo${components[0]}${components[1]}; }`;
	}

	function getToneMappingFunction(functionName, toneMapping) {
		let toneMappingName;

		switch (toneMapping) {
		case LinearToneMapping:
			toneMappingName = 'Linear';
			break;

		case ReinhardToneMapping:
			toneMappingName = 'Reinhard';
			break;

		case Uncharted2ToneMapping:
			toneMappingName = 'Uncharted2';
			break;

		case CineonToneMapping:
			toneMappingName = 'OptimizedCineon';
			break;

		case ACESFilmicToneMapping:
			toneMappingName = 'ACESFilmic';
			break;

		default:
			throw new Error(`unsupported toneMapping: ${toneMapping}`);
		}

		return `vec3 ${functionName}( vec3 color ) { return ${toneMappingName}ToneMapping( color ); }`;
	}

	function generateExtensions(extensions, parameters, rendererExtensions) {
		extensions = extensions || {};

		const chunks = [
			(extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || (parameters.normalMap && !parameters.objectSpaceNormalMap) || parameters.flatShading) ? '#extension GL_OES_standard_derivatives : enable' : '',
			(extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get('EXT_frag_depth') ? '#extension GL_EXT_frag_depth : enable' : '',
			(extensions.drawBuffers) && rendererExtensions.get('WEBGL_draw_buffers') ? '#extension GL_EXT_draw_buffers : require' : '',
			(extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get('EXT_shader_texture_lod') ? '#extension GL_EXT_shader_texture_lod : enable' : '',
		];

		return chunks.filter(filterEmptyLine).join('\n');
	}

	function generateDefines(defines) {
		const chunks = [];

		for (const name in defines) {
			const value = defines[name];

			if (value === false) continue;

			chunks.push(`#define ${name} ${value}`);
		}

		return chunks.join('\n');
	}

	function fetchAttributeLocations(gl, program) {
		const attributes = {};

		const n = gl.getProgramParameter(program, 35721);

		for (let i = 0; i < n; i++) {
			const info = gl.getActiveAttrib(program, i);
			const { name } = info;

			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[name] = gl.getAttribLocation(program, name);
		}

		return attributes;
	}

	function filterEmptyLine(string) {
		return string !== '';
	}

	function replaceLightNums(string, parameters) {
		return string
			.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights)
			.replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights)
			.replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights)
			.replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights)
			.replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
	}

	function replaceClippingPlaneNums(string, parameters) {
		return string
			.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes)
			.replace(/UNION_CLIPPING_PLANES/g, (parameters.numClippingPlanes - parameters.numClipIntersection));
	}

	function parseIncludes(string) {
		const pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

		function replace(match, include) {
			const replace = ShaderChunk[include];

			if (replace === undefined) {
				throw new Error(`Can not resolve #include <${include}>`);
			}

			return parseIncludes(replace);
		}

		return string.replace(pattern, replace);
	}

	function unrollLoops(string) {
		const pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

		function replace(match, start, end, snippet) {
			let unroll = '';

			for (let i = parseInt(start); i < parseInt(end); i++) {
				unroll += snippet.replace(/\[ i \]/g, `[ ${i} ]`);
			}

			return unroll;
		}

		return string.replace(pattern, replace);
	}

	function WebGLProgram(renderer, extensions, code, material, shader, parameters, capabilities) {
		const gl = renderer.context;

		const { defines } = material;

		let { vertexShader } = shader;
		let { fragmentShader } = shader;

		let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if (parameters.shadowMapType === PCFShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
		} else if (parameters.shadowMapType === PCFSoftShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
		}

		let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
		let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
		let envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

		if (parameters.envMap) {
			switch (material.envMap.mapping) {
			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case CubeUVReflectionMapping:
			case CubeUVRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

			case EquirectangularReflectionMapping:
			case EquirectangularRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
				break;

			case SphericalReflectionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
				break;
			}

			switch (material.envMap.mapping) {
			case CubeRefractionMapping:
			case EquirectangularRefractionMapping:
				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;
			}

			switch (material.combine) {
			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;
			}
		}

		const gammaFactorDefine = (renderer.gammaFactor > 0) ? renderer.gammaFactor : 1.0;

		// console.log( 'building new program ' );

		//

		const customExtensions = capabilities.isWebGL2 ? '' : generateExtensions(material.extensions, parameters, extensions);

		const customDefines = generateDefines(defines);

		//

		const program = gl.createProgram();

		let prefixVertex; let
			prefixFragment;

		if (material.isRawShaderMaterial) {
			prefixVertex = [

				customDefines,

			].filter(filterEmptyLine).join('\n');

			if (prefixVertex.length > 0) {
				prefixVertex += '\n';
			}

			prefixFragment = [

				customExtensions,
				customDefines,

			].filter(filterEmptyLine).join('\n');

			if (prefixFragment.length > 0) {
				prefixFragment += '\n';
			}
		} else {
			prefixVertex = [

				`precision ${parameters.precision} float;`,
				`precision ${parameters.precision} int;`,

				`#define SHADER_NAME ${shader.name}`,

				customDefines,

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				`#define GAMMA_FACTOR ${gammaFactorDefine}`,

				`#define MAX_BONES ${parameters.maxBones}`,
				(parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
				(parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? `#define ${envMapModeDefine}` : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				(parameters.normalMap && parameters.objectSpaceNormalMap) ? '#define OBJECTSPACE_NORMALMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? `#define ${shadowMapTypeDefine}` : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get('EXT_frag_depth')) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_COLOR',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_MORPHTARGETS',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n',

			].filter(filterEmptyLine).join('\n');

			prefixFragment = [

				customExtensions,

				`precision ${parameters.precision} float;`,
				`precision ${parameters.precision} int;`,

				`#define SHADER_NAME ${shader.name}`,

				customDefines,

				parameters.alphaTest ? `#define ALPHATEST ${parameters.alphaTest}${parameters.alphaTest % 1 ? '' : '.0'}` : '', // add '.0' if integer

				`#define GAMMA_FACTOR ${gammaFactorDefine}`,

				(parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
				(parameters.useFog && parameters.fogExp) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.matcap ? '#define USE_MATCAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? `#define ${envMapTypeDefine}` : '',
				parameters.envMap ? `#define ${envMapModeDefine}` : '',
				parameters.envMap ? `#define ${envMapBlendingDefine}` : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				(parameters.normalMap && parameters.objectSpaceNormalMap) ? '#define OBJECTSPACE_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? `#define ${shadowMapTypeDefine}` : '',

				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

				parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get('EXT_frag_depth')) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				parameters.envMap && (capabilities.isWebGL2 || extensions.get('EXT_shader_texture_lod')) ? '#define TEXTURE_LOD_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',

				(parameters.toneMapping !== NoToneMapping) ? '#define TONE_MAPPING' : '',
				(parameters.toneMapping !== NoToneMapping) ? ShaderChunk.tonemapping_pars_fragment : '', // this code is required here because it is used by the toneMapping() function defined below
				(parameters.toneMapping !== NoToneMapping) ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '',

				parameters.dithering ? '#define DITHERING' : '',

				(parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding)
					? ShaderChunk.encodings_pars_fragment : '', // this code is required here because it is used by the various encoding/decoding function defined below
				parameters.mapEncoding ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
				parameters.matcapEncoding ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '',
				parameters.envMapEncoding ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
				parameters.emissiveMapEncoding ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
				parameters.outputEncoding ? getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding) : '',

				parameters.depthPacking ? `#define DEPTH_PACKING ${material.depthPacking}` : '',

				'\n',

			].filter(filterEmptyLine).join('\n');
		}

		vertexShader = parseIncludes(vertexShader);
		vertexShader = replaceLightNums(vertexShader, parameters);
		vertexShader = replaceClippingPlaneNums(vertexShader, parameters);

		fragmentShader = parseIncludes(fragmentShader);
		fragmentShader = replaceLightNums(fragmentShader, parameters);
		fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);

		vertexShader = unrollLoops(vertexShader);
		fragmentShader = unrollLoops(fragmentShader);

		if (capabilities.isWebGL2 && !material.isRawShaderMaterial) {
			let isGLSL3ShaderMaterial = false;

			const versionRegex = /^\s*#version\s+300\s+es\s*\n/;

			if (material.isShaderMaterial
				&& vertexShader.match(versionRegex) !== null
				&& fragmentShader.match(versionRegex) !== null) {
				isGLSL3ShaderMaterial = true;

				vertexShader = vertexShader.replace(versionRegex, '');
				fragmentShader = fragmentShader.replace(versionRegex, '');
			}

			// GLSL 3.0 conversion
			prefixVertex = `${[
				'#version 300 es\n',
				'#define attribute in',
				'#define varying out',
				'#define texture2D texture',
			].join('\n')}\n${prefixVertex}`;

			prefixFragment = `${[
				'#version 300 es\n',
				'#define varying in',
				isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',
				isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',
				'#define gl_FragDepthEXT gl_FragDepth',
				'#define texture2D texture',
				'#define textureCube texture',
				'#define texture2DProj textureProj',
				'#define texture2DLodEXT textureLod',
				'#define texture2DProjLodEXT textureProjLod',
				'#define textureCubeLodEXT textureLod',
				'#define texture2DGradEXT textureGrad',
				'#define texture2DProjGradEXT textureProjGrad',
				'#define textureCubeGradEXT textureGrad',
			].join('\n')}\n${prefixFragment}`;
		}

		const vertexGlsl = prefixVertex + vertexShader;
		const fragmentGlsl = prefixFragment + fragmentShader;

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
		const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);

		gl.attachShader(program, glVertexShader);
		gl.attachShader(program, glFragmentShader);

		// Force a particular attribute to index 0.

		if (material.index0AttributeName !== undefined) {
			gl.bindAttribLocation(program, 0, material.index0AttributeName);
		} else if (parameters.morphTargets === true) {
			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation(program, 0, 'position');
		}

		gl.linkProgram(program);

		const programLog = gl.getProgramInfoLog(program).trim();
		const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
		const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();

		let runnable = true;
		let haveDiagnostics = true;

		// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
		// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

		if (gl.getProgramParameter(program, 35714) === false) {
			runnable = false;

			console.error('THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter(program, 35715), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog);
		} else if (programLog !== '') {
			console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
		} else if (vertexLog === '' || fragmentLog === '') {
			haveDiagnostics = false;
		}

		if (haveDiagnostics) {
			this.diagnostics = {

				runnable,
				material,

				programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex,

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment,

				},

			};
		}

		// clean up

		gl.deleteShader(glVertexShader);
		gl.deleteShader(glFragmentShader);

		// set up caching for uniform locations

		let cachedUniforms;

		this.getUniforms = function () {
			if (cachedUniforms === undefined) {
				cachedUniforms = new WebGLUniforms(gl, program, renderer);
			}

			return cachedUniforms;
		};

		// set up caching for attribute locations

		let cachedAttributes;

		this.getAttributes = function () {
			if (cachedAttributes === undefined) {
				cachedAttributes = fetchAttributeLocations(gl, program);
			}

			return cachedAttributes;
		};

		// free resource

		this.destroy = function () {
			gl.deleteProgram(program);
			this.program = undefined;
		};

		// DEPRECATED

		Object.defineProperties(this, {

			uniforms: {
				get() {
					console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');
					return this.getUniforms();
				},
			},

			attributes: {
				get() {
					console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');
					return this.getAttributes();
				},
			},

		});


		//

		this.name = shader.name;
		this.id = programIdCount++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLPrograms(renderer, extensions, capabilities) {
		const programs = [];

		const shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'phong',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite',
		};

		const parameterNames = [
			'precision', 'supportsVertexTextures', 'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding',
			'lightMap', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'displacementMap', 'specularMap',
			'roughnessMap', 'metalnessMap', 'gradientMap',
			'alphaMap', 'combine', 'vertexColors', 'fog', 'useFog', 'fogExp',
			'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning',
			'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals',
			'maxMorphTargets', 'maxMorphNormals', 'premultipliedAlpha',
			'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights',
			'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights',
			'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering',
		];


		function allocateBones(object) {
			const { skeleton } = object;
			const { bones } = skeleton;

			if (capabilities.floatVertexTextures) {
				return 1024;
			}

			// default for when object is not specified
			// ( for example when prebuilding shader to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			const nVertexUniforms = capabilities.maxVertexUniforms;
			const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);

			const maxBones = Math.min(nVertexMatrices, bones.length);

			if (maxBones < bones.length) {
				console.warn(`THREE.WebGLRenderer: Skeleton has ${bones.length} bones. This GPU supports ${maxBones}.`);
				return 0;
			}

			return maxBones;
		}

		function getTextureEncodingFromMap(map, gammaOverrideLinear) {
			let encoding;

			if (!map) {
				encoding = LinearEncoding;
			} else if (map.isTexture) {
				encoding = map.encoding;
			} else if (map.isWebGLRenderTarget) {
				console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
				encoding = map.texture.encoding;
			}

			// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
			if (encoding === LinearEncoding && gammaOverrideLinear) {
				encoding = GammaEncoding;
			}

			return encoding;
		}

		this.getParameters = function (material, lights, shadows, fog, nClipPlanes, nClipIntersection, object) {
			const shaderID = shaderIDs[material.type];

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			const maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
			let { precision } = capabilities;

			if (material.precision !== null) {
				precision = capabilities.getMaxPrecision(material.precision);

				if (precision !== material.precision) {
					console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
				}
			}

			const currentRenderTarget = renderer.getRenderTarget();

			const parameters = {

				shaderID,

				precision,
				supportsVertexTextures: capabilities.vertexTextures,
				outputEncoding: getTextureEncodingFromMap((!currentRenderTarget) ? null : currentRenderTarget.texture, renderer.gammaOutput),
				map: !!material.map,
				mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
				matcap: !!material.matcap,
				matcapEncoding: getTextureEncodingFromMap(material.matcap, renderer.gammaInput),
				envMap: !!material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
				envMapCubeUV: (!!material.envMap) && ((material.envMap.mapping === CubeUVReflectionMapping) || (material.envMap.mapping === CubeUVRefractionMapping)),
				lightMap: !!material.lightMap,
				aoMap: !!material.aoMap,
				emissiveMap: !!material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
				bumpMap: !!material.bumpMap,
				normalMap: !!material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				displacementMap: !!material.displacementMap,
				roughnessMap: !!material.roughnessMap,
				metalnessMap: !!material.metalnessMap,
				specularMap: !!material.specularMap,
				alphaMap: !!material.alphaMap,

				gradientMap: !!material.gradientMap,

				combine: material.combine,

				vertexColors: material.vertexColors,

				fog: !!fog,
				useFog: material.fog,
				fogExp: (fog && fog.isFogExp2),

				flatShading: material.flatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

				skinning: material.skinning && maxBones > 0,
				maxBones,
				useVertexTexture: capabilities.floatVertexTextures,

				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,

				numClippingPlanes: nClipPlanes,
				numClipIntersection: nClipIntersection,

				dithering: material.dithering,

				shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: renderer.toneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,

				premultipliedAlpha: material.premultipliedAlpha,

				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,

				depthPacking: (material.depthPacking !== undefined) ? material.depthPacking : false,

			};

			return parameters;
		};

		this.getProgramCode = function (material, parameters) {
			const array = [];

			if (parameters.shaderID) {
				array.push(parameters.shaderID);
			} else {
				array.push(material.fragmentShader);
				array.push(material.vertexShader);
			}

			if (material.defines !== undefined) {
				for (const name in material.defines) {
					array.push(name);
					array.push(material.defines[name]);
				}
			}

			for (let i = 0; i < parameterNames.length; i++) {
				array.push(parameters[parameterNames[i]]);
			}

			array.push(material.onBeforeCompile.toString());

			array.push(renderer.gammaOutput);

			array.push(renderer.gammaFactor);

			return array.join();
		};

		this.acquireProgram = function (material, shader, parameters, code) {
			let program;

			// Check if code has been already compiled
			for (let p = 0, pl = programs.length; p < pl; p++) {
				const programInfo = programs[p];

				if (programInfo.code === code) {
					program = programInfo;
					++program.usedTimes;

					break;
				}
			}

			if (program === undefined) {
				program = new WebGLProgram(renderer, extensions, code, material, shader, parameters, capabilities);
				programs.push(program);
			}

			return program;
		};

		this.releaseProgram = function (program) {
			if (--program.usedTimes === 0) {
				// Remove from unordered set
				const i = programs.indexOf(program);
				programs[i] = programs[programs.length - 1];
				programs.pop();

				// Free WebGL resources
				program.destroy();
			}
		};

		// Exposed for resource monitoring & error feedback via renderer.info:
		this.programs = programs;
	}

	/**
	 * @author fordacious / fordacious.github.io
	 */

	function WebGLProperties() {
		let properties = new WeakMap();

		function get(object) {
			let map = properties.get(object);

			if (map === undefined) {
				map = {};
				properties.set(object, map);
			}

			return map;
		}

		function remove(object) {
			properties.delete(object);
		}

		function update(object, key, value) {
			properties.get(object)[key] = value;
		}

		function dispose() {
			properties = new WeakMap();
		}

		return {
			get,
			remove,
			update,
			dispose,
		};
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function painterSortStable(a, b) {
		if (a.renderOrder !== b.renderOrder) {
			return a.renderOrder - b.renderOrder;
		} if (a.program && b.program && a.program !== b.program) {
			return a.program.id - b.program.id;
		} if (a.material.id !== b.material.id) {
			return a.material.id - b.material.id;
		} if (a.z !== b.z) {
			return a.z - b.z;
		}

		return a.id - b.id;
	}

	function reversePainterSortStable(a, b) {
		if (a.renderOrder !== b.renderOrder) {
			return a.renderOrder - b.renderOrder;
		} if (a.z !== b.z) {
			return b.z - a.z;
		}

		return a.id - b.id;
	}


	function WebGLRenderList() {
		const renderItems = [];
		let renderItemsIndex = 0;

		const opaque = [];
		const transparent = [];

		function init() {
			renderItemsIndex = 0;

			opaque.length = 0;
			transparent.length = 0;
		}

		function getNextRenderItem(object, geometry, material, z, group) {
			let renderItem = renderItems[renderItemsIndex];

			if (renderItem === undefined) {
				renderItem = {
					id: object.id,
					object,
					geometry,
					material,
					program: material.program,
					renderOrder: object.renderOrder,
					z,
					group,
				};

				renderItems[renderItemsIndex] = renderItem;
			} else {
				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = material.program;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;
			}

			renderItemsIndex++;

			return renderItem;
		}

		function push(object, geometry, material, z, group) {
			const renderItem = getNextRenderItem(object, geometry, material, z, group);

			(material.transparent === true ? transparent : opaque).push(renderItem);
		}

		function unshift(object, geometry, material, z, group) {
			const renderItem = getNextRenderItem(object, geometry, material, z, group);

			(material.transparent === true ? transparent : opaque).unshift(renderItem);
		}

		function sort() {
			if (opaque.length > 1) opaque.sort(painterSortStable);
			if (transparent.length > 1) transparent.sort(reversePainterSortStable);
		}

		return {
			opaque,
			transparent,

			init,
			push,
			unshift,

			sort,
		};
	}

	function WebGLRenderLists() {
		let lists = {};

		function get(scene, camera) {
			const cameras = lists[scene.id];
			let list;
			if (cameras === undefined) {
				list = new WebGLRenderList();
				lists[scene.id] = {};
				lists[scene.id][camera.id] = list;
			} else {
				list = cameras[camera.id];
				if (list === undefined) {
					list = new WebGLRenderList();
					cameras[camera.id] = list;
				}
			}

			return list;
		}

		function dispose() {
			lists = {};
		}

		return {
			get,
			dispose,
		};
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function UniformsCache() {
		const lights = {};

		return {

			get(light) {
				if (lights[light.id] !== undefined) {
					return lights[light.id];
				}

				let uniforms;

				switch (light.type) {
				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color(),

						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0,

						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color(),
						distance: 0,
						decay: 0,

						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
						shadowCameraNear: 1,
						shadowCameraFar: 1000,
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color(),
						groundColor: new Color(),
					};
					break;

				case 'RectAreaLight':
					uniforms = {
						color: new Color(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3(),
						// TODO (abelnation): set RectAreaLight shadow uniforms
					};
					break;
				}

				lights[light.id] = uniforms;

				return uniforms;
			},

		};
	}

	let count = 0;

	function WebGLLights() {
		const cache = new UniformsCache();

		const state = {

			id: count++,

			hash: {
				stateID: -1,
				directionalLength: -1,
				pointLength: -1,
				spotLength: -1,
				rectAreaLength: -1,
				hemiLength: -1,
				shadowsLength: -1,
			},

			ambient: [0, 0, 0],
			directional: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			point: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: [],

		};

		const vector3 = new Vector3();
		const matrix4 = new Matrix4();
		const matrix42 = new Matrix4();

		function setup(lights, shadows, camera) {
			let r = 0; let g = 0; let
				b = 0;

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;

			const viewMatrix = camera.matrixWorldInverse;

			for (let i = 0, l = lights.length; i < l; i++) {
				const light = lights[i];

				const { color } = light;
				const { intensity } = light;
				const { distance } = light;

				const shadowMap = (light.shadow && light.shadow.map) ? light.shadow.map.texture : null;

				if (light.isAmbientLight) {
					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;
				} else if (light.isDirectionalLight) {
					var uniforms = cache.get(light);

					uniforms.color.copy(light.color).multiplyScalar(light.intensity);
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					vector3.setFromMatrixPosition(light.target.matrixWorld);
					uniforms.direction.sub(vector3);
					uniforms.direction.transformDirection(viewMatrix);

					uniforms.shadow = light.castShadow;

					if (light.castShadow) {
						var { shadow } = light;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;
					}

					state.directionalShadowMap[directionalLength] = shadowMap;
					state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
					state.directional[directionalLength] = uniforms;

					directionalLength++;
				} else if (light.isSpotLight) {
					var uniforms = cache.get(light);

					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix);

					uniforms.color.copy(color).multiplyScalar(intensity);
					uniforms.distance = distance;

					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					vector3.setFromMatrixPosition(light.target.matrixWorld);
					uniforms.direction.sub(vector3);
					uniforms.direction.transformDirection(viewMatrix);

					uniforms.coneCos = Math.cos(light.angle);
					uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
					uniforms.decay = light.decay;

					uniforms.shadow = light.castShadow;

					if (light.castShadow) {
						var { shadow } = light;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;
					}

					state.spotShadowMap[spotLength] = shadowMap;
					state.spotShadowMatrix[spotLength] = light.shadow.matrix;
					state.spot[spotLength] = uniforms;

					spotLength++;
				} else if (light.isRectAreaLight) {
					var uniforms = cache.get(light);

					// (a) intensity is the total visible light emitted
					// uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

					// (b) intensity is the brightness of the light
					uniforms.color.copy(color).multiplyScalar(intensity);

					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix);

					// extract local rotation of light to derive width/height half vectors
					matrix42.identity();
					matrix4.copy(light.matrixWorld);
					matrix4.premultiply(viewMatrix);
					matrix42.extractRotation(matrix4);

					uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
					uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);

					uniforms.halfWidth.applyMatrix4(matrix42);
					uniforms.halfHeight.applyMatrix4(matrix42);

					// TODO (abelnation): RectAreaLight distance?
					// uniforms.distance = distance;

					state.rectArea[rectAreaLength] = uniforms;

					rectAreaLength++;
				} else if (light.isPointLight) {
					var uniforms = cache.get(light);

					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix);

					uniforms.color.copy(light.color).multiplyScalar(light.intensity);
					uniforms.distance = light.distance;
					uniforms.decay = light.decay;

					uniforms.shadow = light.castShadow;

					if (light.castShadow) {
						var { shadow } = light;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;
						uniforms.shadowCameraNear = shadow.camera.near;
						uniforms.shadowCameraFar = shadow.camera.far;
					}

					state.pointShadowMap[pointLength] = shadowMap;
					state.pointShadowMatrix[pointLength] = light.shadow.matrix;
					state.point[pointLength] = uniforms;

					pointLength++;
				} else if (light.isHemisphereLight) {
					var uniforms = cache.get(light);

					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					uniforms.direction.transformDirection(viewMatrix);
					uniforms.direction.normalize();

					uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
					uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);

					state.hemi[hemiLength] = uniforms;

					hemiLength++;
				}
			}

			state.ambient[0] = r;
			state.ambient[1] = g;
			state.ambient[2] = b;

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.hash.stateID = state.id;
			state.hash.directionalLength = directionalLength;
			state.hash.pointLength = pointLength;
			state.hash.spotLength = spotLength;
			state.hash.rectAreaLength = rectAreaLength;
			state.hash.hemiLength = hemiLength;
			state.hash.shadowsLength = shadows.length;
		}

		return {
			setup,
			state,
		};
	}

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WebGLRenderState() {
		const lights = new WebGLLights();

		const lightsArray = [];
		const shadowsArray = [];

		function init() {
			lightsArray.length = 0;
			shadowsArray.length = 0;
		}

		function pushLight(light) {
			lightsArray.push(light);
		}

		function pushShadow(shadowLight) {
			shadowsArray.push(shadowLight);
		}

		function setupLights(camera) {
			lights.setup(lightsArray, shadowsArray, camera);
		}

		const state = {
			lightsArray,
			shadowsArray,

			lights,
		};

		return {
			init,
			state,
			setupLights,

			pushLight,
			pushShadow,
		};
	}

	function WebGLRenderStates() {
		let renderStates = {};

		function get(scene, camera) {
			let renderState;

			if (renderStates[scene.id] === undefined) {
				renderState = new WebGLRenderState();
				renderStates[scene.id] = {};
				renderStates[scene.id][camera.id] = renderState;
			} else if (renderStates[scene.id][camera.id] === undefined) {
				renderState = new WebGLRenderState();
				renderStates[scene.id][camera.id] = renderState;
			} else {
				renderState = renderStates[scene.id][camera.id];
			}

			return renderState;
		}

		function dispose() {
			renderStates = {};
		}

		return {
			get,
			dispose,
		};
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / https://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	function MeshDepthMaterial(parameters) {
		Material.call(this);

		this.type = 'MeshDepthMaterial';

		this.depthPacking = BasicDepthPacking;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;
		this.lights = false;

		this.setValues(parameters);
	}

	MeshDepthMaterial.prototype = Object.create(Material.prototype);
	MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

	MeshDepthMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);

		this.depthPacking = source.depthPacking;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;
	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  referencePosition: <float>,
	 *  nearDistance: <float>,
	 *  farDistance: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>
	 *
	 * }
	 */

	function MeshDistanceMaterial(parameters) {
		Material.call(this);

		this.type = 'MeshDistanceMaterial';

		this.referencePosition = new Vector3();
		this.nearDistance = 1;
		this.farDistance = 1000;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.fog = false;
		this.lights = false;

		this.setValues(parameters);
	}

	MeshDistanceMaterial.prototype = Object.create(Material.prototype);
	MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

	MeshDistanceMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);

		this.referencePosition.copy(source.referencePosition);
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;
	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
		const _frustum = new Frustum();
		const _projScreenMatrix = new Matrix4();

		const _shadowMapSize = new Vector2();
		const _maxShadowMapSize = new Vector2(maxTextureSize, maxTextureSize);

		const _lookTarget = new Vector3();
		const _lightPositionWorld = new Vector3();

		const _MorphingFlag = 1;
		const _SkinningFlag = 2;

		const _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1;

		const _depthMaterials = new Array(_NumberOfMaterialVariants);
		const _distanceMaterials = new Array(_NumberOfMaterialVariants);

		const _materialCache = {};

		const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

		const cubeDirections = [
			new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1),
			new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0),
		];

		const cubeUps = [
			new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0),
			new Vector3(0, 1, 0), new Vector3(0, 0, 1),	new Vector3(0, 0, -1),
		];

		const cube2DViewPorts = [
			new Vector4(), new Vector4(), new Vector4(),
			new Vector4(), new Vector4(), new Vector4(),
		];

		// init

		for (let i = 0; i !== _NumberOfMaterialVariants; ++i) {
			const useMorphing = (i & _MorphingFlag) !== 0;
			const useSkinning = (i & _SkinningFlag) !== 0;

			const depthMaterial = new MeshDepthMaterial({

				depthPacking: RGBADepthPacking,

				morphTargets: useMorphing,
				skinning: useSkinning,

			});

			_depthMaterials[i] = depthMaterial;

			//

			const distanceMaterial = new MeshDistanceMaterial({

				morphTargets: useMorphing,
				skinning: useSkinning,

			});

			_distanceMaterials[i] = distanceMaterial;
		}

		//

		const scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = PCFShadowMap;

		this.render = function (lights, scene, camera) {
			if (scope.enabled === false) return;
			if (scope.autoUpdate === false && scope.needsUpdate === false) return;

			if (lights.length === 0) return;

			// TODO Clean up (needed in case of contextlost)
			const _gl = _renderer.context;
			const _state = _renderer.state;

			// Set GL state for depth map.
			_state.disable(3042);
			_state.buffers.color.setClear(1, 1, 1, 1);
			_state.buffers.depth.setTest(true);
			_state.setScissorTest(false);

			// render depth map

			let faceCount;

			for (let i = 0, il = lights.length; i < il; i++) {
				const light = lights[i];
				const { shadow } = light;
				const isPointLight = light && light.isPointLight;

				if (shadow === undefined) {
					console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
					continue;
				}

				const shadowCamera = shadow.camera;

				_shadowMapSize.copy(shadow.mapSize);
				_shadowMapSize.min(_maxShadowMapSize);

				if (isPointLight) {
					const vpWidth = _shadowMapSize.x;
					const vpHeight = _shadowMapSize.y;

					// These viewports map a cube-map onto a 2D texture with the
					// following orientation:
					//
					//  xzXZ
					//   y Y
					//
					// X - Positive x direction
					// x - Negative x direction
					// Y - Positive y direction
					// y - Negative y direction
					// Z - Positive z direction
					// z - Negative z direction

					// positive X
					cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
					// negative X
					cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
					// positive Z
					cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
					// negative Z
					cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
					// positive Y
					cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
					// negative Y
					cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);

					_shadowMapSize.x *= 4.0;
					_shadowMapSize.y *= 2.0;
				}

				if (shadow.map === null) {
					const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

					shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
					shadow.map.texture.name = `${light.name}.shadowMap`;

					shadowCamera.updateProjectionMatrix();
				}

				if (shadow.isSpotLightShadow) {
					shadow.update(light);
				}

				const shadowMap = shadow.map;
				const shadowMatrix = shadow.matrix;

				_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
				shadowCamera.position.copy(_lightPositionWorld);

				if (isPointLight) {
					faceCount = 6;

					// for point lights we set the shadow matrix to be a translation-only matrix
					// equal to inverse of the light's position

					shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
				} else {
					faceCount = 1;

					_lookTarget.setFromMatrixPosition(light.target.matrixWorld);
					shadowCamera.lookAt(_lookTarget);
					shadowCamera.updateMatrixWorld();

					// compute shadow matrix

					shadowMatrix.set(
						0.5, 0.0, 0.0, 0.5,
						0.0, 0.5, 0.0, 0.5,
						0.0, 0.0, 0.5, 0.5,
						0.0, 0.0, 0.0, 1.0,
					);

					shadowMatrix.multiply(shadowCamera.projectionMatrix);
					shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
				}

				_renderer.setRenderTarget(shadowMap);
				_renderer.clear();

				// render shadow map for each cube face (if omni-directional) or
				// run a single pass if not

				for (let face = 0; face < faceCount; face++) {
					if (isPointLight) {
						_lookTarget.copy(shadowCamera.position);
						_lookTarget.add(cubeDirections[face]);
						shadowCamera.up.copy(cubeUps[face]);
						shadowCamera.lookAt(_lookTarget);
						shadowCamera.updateMatrixWorld();

						const vpDimensions = cube2DViewPorts[face];
						_state.viewport(vpDimensions);
					}

					// update camera matrices and frustum

					_projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
					_frustum.setFromMatrix(_projScreenMatrix);

					// set object matrices & frustum culling

					renderObject(scene, camera, shadowCamera, isPointLight);
				}
			}

			scope.needsUpdate = false;
		};

		function getDepthMaterial(object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar) {
			const { geometry } = object;

			let result = null;

			let materialVariants = _depthMaterials;
			let customMaterial = object.customDepthMaterial;

			if (isPointLight) {
				materialVariants = _distanceMaterials;
				customMaterial = object.customDistanceMaterial;
			}

			if (!customMaterial) {
				let useMorphing = false;

				if (material.morphTargets) {
					if (geometry && geometry.isBufferGeometry) {
						useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
					} else if (geometry && geometry.isGeometry) {
						useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
					}
				}

				if (object.isSkinnedMesh && material.skinning === false) {
					console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
				}

				const useSkinning = object.isSkinnedMesh && material.skinning;

				let variantIndex = 0;

				if (useMorphing) variantIndex |= _MorphingFlag;
				if (useSkinning) variantIndex |= _SkinningFlag;

				result = materialVariants[variantIndex];
			} else {
				result = customMaterial;
			}

			if (_renderer.localClippingEnabled
					&& material.clipShadows === true
					&& material.clippingPlanes.length !== 0) {
				// in this case we need a unique material instance reflecting the
				// appropriate state

				const keyA = result.uuid; const
					keyB = material.uuid;

				let materialsForVariant = _materialCache[keyA];

				if (materialsForVariant === undefined) {
					materialsForVariant = {};
					_materialCache[keyA] = materialsForVariant;
				}

				let cachedMaterial = materialsForVariant[keyB];

				if (cachedMaterial === undefined) {
					cachedMaterial = result.clone();
					materialsForVariant[keyB] = cachedMaterial;
				}

				result = cachedMaterial;
			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			result.side = (material.shadowSide != null) ? material.shadowSide : shadowSide[material.side];

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;

			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if (isPointLight && result.isMeshDistanceMaterial) {
				result.referencePosition.copy(lightPositionWorld);
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;
			}

			return result;
		}

		function renderObject(object, camera, shadowCamera, isPointLight) {
			if (object.visible === false) return;

			const visible = object.layers.test(camera.layers);

			if (visible && (object.isMesh || object.isLine || object.isPoints)) {
				if (object.castShadow && (!object.frustumCulled || _frustum.intersectsObject(object))) {
					object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

					const geometry = _objects.update(object);
					const { material } = object;

					if (Array.isArray(material)) {
						const { groups } = geometry;

						for (let k = 0, kl = groups.length; k < kl; k++) {
							const group = groups[k];
							const groupMaterial = material[group.materialIndex];

							if (groupMaterial && groupMaterial.visible) {
								var depthMaterial = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
								_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
							}
						}
					} else if (material.visible) {
						var depthMaterial = getDepthMaterial(object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
						_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
					}
				}
			}

			const { children } = object;

			for (let i = 0, l = children.length; i < l; i++) {
				renderObject(children[i], camera, shadowCamera, isPointLight);
			}
		}
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLState(gl, extensions, utils, capabilities) {
		function ColorBuffer() {
			let locked = false;

			const color = new Vector4();
			let currentColorMask = null;
			const currentColorClear = new Vector4(0, 0, 0, 0);

			return {

				setMask(colorMask) {
					if (currentColorMask !== colorMask && !locked) {
						gl.colorMask(colorMask, colorMask, colorMask, colorMask);
						currentColorMask = colorMask;
					}
				},

				setLocked(lock) {
					locked = lock;
				},

				setClear(r, g, b, a, premultipliedAlpha) {
					if (premultipliedAlpha === true) {
						r *= a; g *= a; b *= a;
					}

					color.set(r, g, b, a);

					if (currentColorClear.equals(color) === false) {
						gl.clearColor(r, g, b, a);
						currentColorClear.copy(color);
					}
				},

				reset() {
					locked = false;

					currentColorMask = null;
					currentColorClear.set(-1, 0, 0, 0); // set to invalid state
				},

			};
		}

		function DepthBuffer() {
			let locked = false;

			let currentDepthMask = null;
			let currentDepthFunc = null;
			let currentDepthClear = null;

			return {

				setTest(depthTest) {
					if (depthTest) {
						enable(2929);
					} else {
						disable(2929);
					}
				},

				setMask(depthMask) {
					if (currentDepthMask !== depthMask && !locked) {
						gl.depthMask(depthMask);
						currentDepthMask = depthMask;
					}
				},

				setFunc(depthFunc) {
					if (currentDepthFunc !== depthFunc) {
						if (depthFunc) {
							switch (depthFunc) {
							case NeverDepth:

								gl.depthFunc(512);
								break;

							case AlwaysDepth:

								gl.depthFunc(519);
								break;

							case LessDepth:

								gl.depthFunc(513);
								break;

							case LessEqualDepth:

								gl.depthFunc(515);
								break;

							case EqualDepth:

								gl.depthFunc(514);
								break;

							case GreaterEqualDepth:

								gl.depthFunc(518);
								break;

							case GreaterDepth:

								gl.depthFunc(516);
								break;

							case NotEqualDepth:

								gl.depthFunc(517);
								break;

							default:

								gl.depthFunc(515);
							}
						} else {
							gl.depthFunc(515);
						}

						currentDepthFunc = depthFunc;
					}
				},

				setLocked(lock) {
					locked = lock;
				},

				setClear(depth) {
					if (currentDepthClear !== depth) {
						gl.clearDepth(depth);
						currentDepthClear = depth;
					}
				},

				reset() {
					locked = false;

					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;
				},

			};
		}

		function StencilBuffer() {
			let locked = false;

			let currentStencilMask = null;
			let currentStencilFunc = null;
			let currentStencilRef = null;
			let currentStencilFuncMask = null;
			let currentStencilFail = null;
			let currentStencilZFail = null;
			let currentStencilZPass = null;
			let currentStencilClear = null;

			return {

				setTest(stencilTest) {
					if (stencilTest) {
						enable(2960);
					} else {
						disable(2960);
					}
				},

				setMask(stencilMask) {
					if (currentStencilMask !== stencilMask && !locked) {
						gl.stencilMask(stencilMask);
						currentStencilMask = stencilMask;
					}
				},

				setFunc(stencilFunc, stencilRef, stencilMask) {
					if (currentStencilFunc !== stencilFunc
					     || currentStencilRef 	!== stencilRef
					     || 	currentStencilFuncMask !== stencilMask) {
						gl.stencilFunc(stencilFunc, stencilRef, stencilMask);

						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;
					}
				},

				setOp(stencilFail, stencilZFail, stencilZPass) {
					if (currentStencilFail	 !== stencilFail
					     || 	currentStencilZFail !== stencilZFail
					     || currentStencilZPass !== stencilZPass) {
						gl.stencilOp(stencilFail, stencilZFail, stencilZPass);

						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;
					}
				},

				setLocked(lock) {
					locked = lock;
				},

				setClear(stencil) {
					if (currentStencilClear !== stencil) {
						gl.clearStencil(stencil);
						currentStencilClear = stencil;
					}
				},

				reset() {
					locked = false;

					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;
				},

			};
		}

		//

		const colorBuffer = new ColorBuffer();
		const depthBuffer = new DepthBuffer();
		const stencilBuffer = new StencilBuffer();

		const maxVertexAttributes = gl.getParameter(34921);
		const newAttributes = new Uint8Array(maxVertexAttributes);
		const enabledAttributes = new Uint8Array(maxVertexAttributes);
		const attributeDivisors = new Uint8Array(maxVertexAttributes);

		let enabledCapabilities = {};

		let compressedTextureFormats = null;

		let currentProgram = null;

		let currentBlendingEnabled = null;
		let currentBlending = null;
		let currentBlendEquation = null;
		let currentBlendSrc = null;
		let currentBlendDst = null;
		let currentBlendEquationAlpha = null;
		let currentBlendSrcAlpha = null;
		let currentBlendDstAlpha = null;
		let currentPremultipledAlpha = false;

		let currentFlipSided = null;
		let currentCullFace = null;

		let currentLineWidth = null;

		let currentPolygonOffsetFactor = null;
		let currentPolygonOffsetUnits = null;

		const maxTextures = gl.getParameter(35661);

		let lineWidthAvailable = false;
		let version = 0;
		const glVersion = gl.getParameter(7938);

		if (glVersion.indexOf('WebGL') !== -1) {
			version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
			lineWidthAvailable = (version >= 1.0);
		} else if (glVersion.indexOf('OpenGL ES') !== -1) {
			version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
			lineWidthAvailable = (version >= 2.0);
		}

		let currentTextureSlot = null;
		let currentBoundTextures = {};

		const currentScissor = new Vector4();
		const currentViewport = new Vector4();

		function createTexture(type, target, count) {
			const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
			const texture = gl.createTexture();

			gl.bindTexture(type, texture);
			gl.texParameteri(type, 10241, 9728);
			gl.texParameteri(type, 10240, 9728);

			for (let i = 0; i < count; i++) {
				gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
			}

			return texture;
		}

		const emptyTextures = {};
		emptyTextures[3553] = createTexture(3553, 3553, 1);
		emptyTextures[34067] = createTexture(34067, 34069, 6);

		// init

		colorBuffer.setClear(0, 0, 0, 1);
		depthBuffer.setClear(1);
		stencilBuffer.setClear(0);

		enable(2929);
		depthBuffer.setFunc(LessEqualDepth);

		setFlipSided(false);
		setCullFace(CullFaceBack);
		enable(2884);

		setBlending(NoBlending);

		//

		function initAttributes() {
			for (let i = 0, l = newAttributes.length; i < l; i++) {
				newAttributes[i] = 0;
			}
		}

		function enableAttribute(attribute) {
			enableAttributeAndDivisor(attribute, 0);
		}

		function enableAttributeAndDivisor(attribute, meshPerAttribute) {
			newAttributes[attribute] = 1;

			if (enabledAttributes[attribute] === 0) {
				gl.enableVertexAttribArray(attribute);
				enabledAttributes[attribute] = 1;
			}

			if (attributeDivisors[attribute] !== meshPerAttribute) {
				const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');

				extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
				attributeDivisors[attribute] = meshPerAttribute;
			}
		}

		function disableUnusedAttributes() {
			for (let i = 0, l = enabledAttributes.length; i !== l; ++i) {
				if (enabledAttributes[i] !== newAttributes[i]) {
					gl.disableVertexAttribArray(i);
					enabledAttributes[i] = 0;
				}
			}
		}

		function enable(id) {
			if (enabledCapabilities[id] !== true) {
				gl.enable(id);
				enabledCapabilities[id] = true;
			}
		}

		function disable(id) {
			if (enabledCapabilities[id] !== false) {
				gl.disable(id);
				enabledCapabilities[id] = false;
			}
		}

		function getCompressedTextureFormats() {
			if (compressedTextureFormats === null) {
				compressedTextureFormats = [];

				if (extensions.get('WEBGL_compressed_texture_pvrtc')
				     || extensions.get('WEBGL_compressed_texture_s3tc')
				     || extensions.get('WEBGL_compressed_texture_etc1')
				     || extensions.get('WEBGL_compressed_texture_astc')) {
					const formats = gl.getParameter(34467);

					for (let i = 0; i < formats.length; i++) {
						compressedTextureFormats.push(formats[i]);
					}
				}
			}

			return compressedTextureFormats;
		}

		function useProgram(program) {
			if (currentProgram !== program) {
				gl.useProgram(program);

				currentProgram = program;

				return true;
			}

			return false;
		}

		function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
			if (blending === NoBlending) {
				if (currentBlendingEnabled) {
					disable(3042);
					currentBlendingEnabled = false;
				}

				return;
			}

			if (!currentBlendingEnabled) {
				enable(3042);
				currentBlendingEnabled = true;
			}

			if (blending !== CustomBlending) {
				if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
					if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
						gl.blendEquation(32774);

						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;
					}

					if (premultipliedAlpha) {
						switch (blending) {
						case NormalBlending:
							gl.blendFuncSeparate(1, 771, 1, 771);
							break;

						case AdditiveBlending:
							gl.blendFunc(1, 1);
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate(0, 0, 769, 771);
							break;

						case MultiplyBlending:
							gl.blendFuncSeparate(0, 768, 0, 770);
							break;

						default:
							console.error('THREE.WebGLState: Invalid blending: ', blending);
							break;
						}
					} else {
						switch (blending) {
						case NormalBlending:
							gl.blendFuncSeparate(770, 771, 1, 771);
							break;

						case AdditiveBlending:
							gl.blendFunc(770, 1);
							break;

						case SubtractiveBlending:
							gl.blendFunc(0, 769);
							break;

						case MultiplyBlending:
							gl.blendFunc(0, 768);
							break;

						default:
							console.error('THREE.WebGLState: Invalid blending: ', blending);
							break;
						}
					}

					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;

					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;
				}

				return;
			}

			// custom blending

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
				gl.blendEquationSeparate(utils.convert(blendEquation), utils.convert(blendEquationAlpha));

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;
			}

			if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
				gl.blendFuncSeparate(utils.convert(blendSrc), utils.convert(blendDst), utils.convert(blendSrcAlpha), utils.convert(blendDstAlpha));

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;
			}

			currentBlending = blending;
			currentPremultipledAlpha = null;
		}

		function setMaterial(material, frontFaceCW) {
			material.side === DoubleSide
				? disable(2884)
				: enable(2884);

			let flipSided = (material.side === BackSide);
			if (frontFaceCW) flipSided = !flipSided;

			setFlipSided(flipSided);

			(material.blending === NormalBlending && material.transparent === false)
				? setBlending(NoBlending)
				: setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);

			depthBuffer.setFunc(material.depthFunc);
			depthBuffer.setTest(material.depthTest);
			depthBuffer.setMask(material.depthWrite);
			colorBuffer.setMask(material.colorWrite);

			setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
		}

		//

		function setFlipSided(flipSided) {
			if (currentFlipSided !== flipSided) {
				if (flipSided) {
					gl.frontFace(2304);
				} else {
					gl.frontFace(2305);
				}

				currentFlipSided = flipSided;
			}
		}

		function setCullFace(cullFace) {
			if (cullFace !== CullFaceNone) {
				enable(2884);

				if (cullFace !== currentCullFace) {
					if (cullFace === CullFaceBack) {
						gl.cullFace(1029);
					} else if (cullFace === CullFaceFront) {
						gl.cullFace(1028);
					} else {
						gl.cullFace(1032);
					}
				}
			} else {
				disable(2884);
			}

			currentCullFace = cullFace;
		}

		function setLineWidth(width) {
			if (width !== currentLineWidth) {
				if (lineWidthAvailable) gl.lineWidth(width);

				currentLineWidth = width;
			}
		}

		function setPolygonOffset(polygonOffset, factor, units) {
			if (polygonOffset) {
				enable(32823);

				if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
					gl.polygonOffset(factor, units);

					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;
				}
			} else {
				disable(32823);
			}
		}

		function setScissorTest(scissorTest) {
			if (scissorTest) {
				enable(3089);
			} else {
				disable(3089);
			}
		}

		// texture

		function activeTexture(webglSlot) {
			if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;

			if (currentTextureSlot !== webglSlot) {
				gl.activeTexture(webglSlot);
				currentTextureSlot = webglSlot;
			}
		}

		function bindTexture(webglType, webglTexture) {
			if (currentTextureSlot === null) {
				activeTexture();
			}

			let boundTexture = currentBoundTextures[currentTextureSlot];

			if (boundTexture === undefined) {
				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[currentTextureSlot] = boundTexture;
			}

			if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
				gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;
			}
		}

		function compressedTexImage2D() {
			try {
				gl.compressedTexImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texImage2D() {
			try {
				gl.texImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texImage3D() {
			try {
				gl.texImage3D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		//

		function scissor(scissor) {
			if (currentScissor.equals(scissor) === false) {
				gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
				currentScissor.copy(scissor);
			}
		}

		function viewport(viewport) {
			if (currentViewport.equals(viewport) === false) {
				gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
				currentViewport.copy(viewport);
			}
		}

		//

		function reset() {
			for (let i = 0; i < enabledAttributes.length; i++) {
				if (enabledAttributes[i] === 1) {
					gl.disableVertexAttribArray(i);
					enabledAttributes[i] = 0;
				}
			}

			enabledCapabilities = {};

			compressedTextureFormats = null;

			currentTextureSlot = null;
			currentBoundTextures = {};

			currentProgram = null;

			currentBlending = null;

			currentFlipSided = null;
			currentCullFace = null;

			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();
		}

		return {

			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer,
			},

			initAttributes,
			enableAttribute,
			enableAttributeAndDivisor,
			disableUnusedAttributes,
			enable,
			disable,
			getCompressedTextureFormats,

			useProgram,

			setBlending,
			setMaterial,

			setFlipSided,
			setCullFace,

			setLineWidth,
			setPolygonOffset,

			setScissorTest,

			activeTexture,
			bindTexture,
			compressedTexImage2D,
			texImage2D,
			texImage3D,

			scissor,
			viewport,

			reset,

		};
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
		const _videoTextures = {};
		let _canvas;

		//

		function clampToMaxSize(image, maxSize) {
			if (image.width > maxSize || image.height > maxSize) {
				if ('data' in image) {
					console.warn(`THREE.WebGLRenderer: image in DataTexture is too big (${image.width}x${image.height}).`);
					return;
				}

				// Warning: Scaling through the canvas will only work with images that use
				// premultiplied alpha.

				const scale = maxSize / Math.max(image.width, image.height);

				const canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
				canvas.width = Math.floor(image.width * scale);
				canvas.height = Math.floor(image.height * scale);

				const context = canvas.getContext('2d');
				context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);

				console.warn(`THREE.WebGLRenderer: image is too big (${image.width}x${image.height}). Resized to ${canvas.width}x${canvas.height}`);

				return canvas;
			}

			return image;
		}

		function isPowerOfTwo(image) {
			return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);
		}

		function makePowerOfTwo(image) {
			if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap) {
				if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');

				_canvas.width = _Math.floorPowerOfTwo(image.width);
				_canvas.height = _Math.floorPowerOfTwo(image.height);

				const context = _canvas.getContext('2d');
				context.drawImage(image, 0, 0, _canvas.width, _canvas.height);

				console.warn(`THREE.WebGLRenderer: image is not power of two (${image.width}x${image.height}). Resized to ${_canvas.width}x${_canvas.height}`);

				return _canvas;
			}

			return image;
		}

		function textureNeedsPowerOfTwo(texture) {
			if (capabilities.isWebGL2) return false;

			return (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping)
				|| (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter);
		}

		function textureNeedsGenerateMipmaps(texture, isPowerOfTwo) {
			return texture.generateMipmaps && isPowerOfTwo
				&& texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
		}

		function generateMipmap(target, texture, width, height) {
			_gl.generateMipmap(target);

			const textureProperties = properties.get(texture);

			// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
			textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
		}

		function getInternalFormat(glFormat, glType) {
			if (!capabilities.isWebGL2) return glFormat;

			if (glFormat === 6403) {
				if (glType === 5126) return 33326;
				if (glType === 5131) return 33325;
				if (glType === 5121) return 33321;
			}

			if (glFormat === 6407) {
				if (glType === 5126) return 34837;
				if (glType === 5131) return 34843;
				if (glType === 5121) return 32849;
			}

			if (glFormat === 6408) {
				if (glType === 5126) return 34836;
				if (glType === 5131) return 34842;
				if (glType === 5121) return 32856;
			}

			return glFormat;
		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback(f) {
			if (f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter) {
				return 9728;
			}

			return 9729;
		}

		//

		function onTextureDispose(event) {
			const texture = event.target;

			texture.removeEventListener('dispose', onTextureDispose);

			deallocateTexture(texture);

			if (texture.isVideoTexture) {
				delete _videoTextures[texture.id];
			}

			info.memory.textures--;
		}

		function onRenderTargetDispose(event) {
			const renderTarget = event.target;

			renderTarget.removeEventListener('dispose', onRenderTargetDispose);

			deallocateRenderTarget(renderTarget);

			info.memory.textures--;
		}

		//

		function deallocateTexture(texture) {
			const textureProperties = properties.get(texture);

			if (texture.image && textureProperties.__image__webglTextureCube) {
				// cube texture

				_gl.deleteTexture(textureProperties.__image__webglTextureCube);
			} else {
				// 2D texture

				if (textureProperties.__webglInit === undefined) return;

				_gl.deleteTexture(textureProperties.__webglTexture);
			}

			// remove all webgl properties
			properties.remove(texture);
		}

		function deallocateRenderTarget(renderTarget) {
			const renderTargetProperties = properties.get(renderTarget);
			const textureProperties = properties.get(renderTarget.texture);

			if (!renderTarget) return;

			if (textureProperties.__webglTexture !== undefined) {
				_gl.deleteTexture(textureProperties.__webglTexture);
			}

			if (renderTarget.depthTexture) {
				renderTarget.depthTexture.dispose();
			}

			if (renderTarget.isWebGLRenderTargetCube) {
				for (let i = 0; i < 6; i++) {
					_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
					if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
				}
			} else {
				_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
				if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
			}

			properties.remove(renderTarget.texture);
			properties.remove(renderTarget);
		}

		//


		function setTexture2D(texture, slot) {
			const textureProperties = properties.get(texture);

			if (texture.isVideoTexture) updateVideoTexture(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				const { image } = texture;

				if (image === undefined) {
					console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
				} else if (image.complete === false) {
					console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
				} else {
					uploadTexture(textureProperties, texture, slot);
					return;
				}
			}

			state.activeTexture(33984 + slot);
			state.bindTexture(3553, textureProperties.__webglTexture);
		}

		function setTexture3D(texture, slot) {
			const textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(33984 + slot);
			state.bindTexture(32879, textureProperties.__webglTexture);
		}


		function setTextureCube(texture, slot) {
			const textureProperties = properties.get(texture);

			if (texture.image.length === 6) {
				if (texture.version > 0 && textureProperties.__version !== texture.version) {
					if (!textureProperties.__image__webglTextureCube) {
						texture.addEventListener('dispose', onTextureDispose);

						textureProperties.__image__webglTextureCube = _gl.createTexture();

						info.memory.textures++;
					}

					state.activeTexture(33984 + slot);
					state.bindTexture(34067, textureProperties.__image__webglTextureCube);

					_gl.pixelStorei(37440, texture.flipY);

					const isCompressed = (texture && texture.isCompressedTexture);
					const isDataTexture = (texture.image[0] && texture.image[0].isDataTexture);

					const cubeImage = [];

					for (var i = 0; i < 6; i++) {
						if (!isCompressed && !isDataTexture) {
							cubeImage[i] = clampToMaxSize(texture.image[i], capabilities.maxCubemapSize);
						} else {
							cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
						}
					}

					const image = cubeImage[0];
					const isPowerOfTwoImage = isPowerOfTwo(image);
					const glFormat = utils.convert(texture.format);
					const glType = utils.convert(texture.type);
					const glInternalFormat = getInternalFormat(glFormat, glType);

					setTextureParameters(34067, texture, isPowerOfTwoImage);

					for (var i = 0; i < 6; i++) {
						if (!isCompressed) {
							if (isDataTexture) {
								state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
							} else {
								state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
							}
						} else {
							var mipmap; var
								{ mipmaps } = cubeImage[i];

							for (let j = 0, jl = mipmaps.length; j < jl; j++) {
								mipmap = mipmaps[j];

								if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
									if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
										state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
									} else {
										console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
									}
								} else {
									state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
								}
							}
						}
					}

					if (!isCompressed) {
						textureProperties.__maxMipLevel = 0;
					} else {
						textureProperties.__maxMipLevel = mipmaps.length - 1;
					}

					if (textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) {
						// We assume images for cube map have the same size.
						generateMipmap(34067, texture, image.width, image.height);
					}

					textureProperties.__version = texture.version;

					if (texture.onUpdate) texture.onUpdate(texture);
				} else {
					state.activeTexture(33984 + slot);
					state.bindTexture(34067, textureProperties.__image__webglTextureCube);
				}
			}
		}

		function setTextureCubeDynamic(texture, slot) {
			state.activeTexture(33984 + slot);
			state.bindTexture(34067, properties.get(texture).__webglTexture);
		}

		function setTextureParameters(textureType, texture, isPowerOfTwoImage) {
			let extension;

			if (isPowerOfTwoImage) {
				_gl.texParameteri(textureType, 10242, utils.convert(texture.wrapS));
				_gl.texParameteri(textureType, 10243, utils.convert(texture.wrapT));

				_gl.texParameteri(textureType, 10240, utils.convert(texture.magFilter));
				_gl.texParameteri(textureType, 10241, utils.convert(texture.minFilter));
			} else {
				_gl.texParameteri(textureType, 10242, 33071);
				_gl.texParameteri(textureType, 10243, 33071);

				if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
				}

				_gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
				_gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));

				if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
				}
			}

			extension = extensions.get('EXT_texture_filter_anisotropic');

			if (extension) {
				if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null) return;
				if (texture.type === HalfFloatType && (capabilities.isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null) return;

				if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
					_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
					properties.get(texture).__currentAnisotropy = texture.anisotropy;
				}
			}
		}

		function uploadTexture(textureProperties, texture, slot) {
			let textureType;

			if (texture.isDataTexture3D) {
				textureType = 32879;
			} else {
				textureType = 3553;
			}


			if (textureProperties.__webglInit === undefined) {
				textureProperties.__webglInit = true;

				texture.addEventListener('dispose', onTextureDispose);

				textureProperties.__webglTexture = _gl.createTexture();

				info.memory.textures++;
			}
			state.activeTexture(33984 + slot);


			state.bindTexture(textureType, textureProperties.__webglTexture);


			_gl.pixelStorei(37440, texture.flipY);
			_gl.pixelStorei(37441, texture.premultiplyAlpha);
			_gl.pixelStorei(3317, texture.unpackAlignment);

			let image = clampToMaxSize(texture.image, capabilities.maxTextureSize);

			if (textureNeedsPowerOfTwo(texture) && isPowerOfTwo(image) === false) {
				image = makePowerOfTwo(image);
			}

			const isPowerOfTwoImage = isPowerOfTwo(image);
			const glFormat = utils.convert(texture.format);
			let glType = utils.convert(texture.type);
			let glInternalFormat = getInternalFormat(glFormat, glType);

			setTextureParameters(textureType, texture, isPowerOfTwoImage);

			let mipmap; const
				{ mipmaps } = texture;

			if (texture.isDepthTexture) {
				// populate depth texture with dummy data

				glInternalFormat = 6402;

				if (texture.type === FloatType) {
					if (!capabilities.isWebGL2) throw new Error('Float Depth Texture only supported in WebGL2.0');
					glInternalFormat = 36012;
				} else if (capabilities.isWebGL2) {
					// WebGL 2.0 requires signed internalformat for glTexImage2D
					glInternalFormat = 33189;
				}

				if (texture.format === DepthFormat && glInternalFormat === 6402) {
					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
						console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');

						texture.type = UnsignedShortType;
						glType = utils.convert(texture.type);
					}
				}

				// Depth stencil textures need the DEPTH_STENCIL internal format
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if (texture.format === DepthStencilFormat) {
					glInternalFormat = 34041;

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if (texture.type !== UnsignedInt248Type) {
						console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');

						texture.type = UnsignedInt248Type;
						glType = utils.convert(texture.type);
					}
				}

				state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
			} else if (texture.isDataTexture) {
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if (mipmaps.length > 0 && isPowerOfTwoImage) {
					for (var i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;
				} else {
					state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
					textureProperties.__maxMipLevel = 0;
				}
			} else if (texture.isCompressedTexture) {
				for (var i = 0, il = mipmaps.length; i < il; i++) {
					mipmap = mipmaps[i];

					if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
						if (state.getCompressedTextureFormats().indexOf(glFormat) > -1) {
							state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
						} else {
							console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
						}
					} else {
						state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;
			} else if (texture.isDataTexture3D) {
				state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
				textureProperties.__maxMipLevel = 0;
			} else {
				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if (mipmaps.length > 0 && isPowerOfTwoImage) {
					for (var i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;
				} else {
					state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
					textureProperties.__maxMipLevel = 0;
				}
			}

			if (textureNeedsGenerateMipmaps(texture, isPowerOfTwoImage)) {
				generateMipmap(3553, texture, image.width, image.height);
			}

			textureProperties.__version = texture.version;

			if (texture.onUpdate) texture.onUpdate(texture);
		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
			const glFormat = utils.convert(renderTarget.texture.format);
			const glType = utils.convert(renderTarget.texture.type);
			const glInternalFormat = getInternalFormat(glFormat, glType);
			state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
			_gl.bindFramebuffer(36160, framebuffer);
			_gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
			_gl.bindFramebuffer(36160, null);
		}

		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage(renderbuffer, renderTarget) {
			_gl.bindRenderbuffer(36161, renderbuffer);

			if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
				_gl.renderbufferStorage(36161, 33189, renderTarget.width, renderTarget.height);
				_gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
			} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
				_gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
				_gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
			} else {
				// FIXME: We don't support !depth !stencil
				_gl.renderbufferStorage(36161, 32854, renderTarget.width, renderTarget.height);
			}

			_gl.bindRenderbuffer(36161, null);
		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture(framebuffer, renderTarget) {
			const isCube = (renderTarget && renderTarget.isWebGLRenderTargetCube);
			if (isCube) throw new Error('Depth Texture with cube render targets is not supported');

			_gl.bindFramebuffer(36160, framebuffer);

			if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
				throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
			}

			// upload an empty depth texture with framebuffer size
			if (!properties.get(renderTarget.depthTexture).__webglTexture
					|| renderTarget.depthTexture.image.width !== renderTarget.width
					|| renderTarget.depthTexture.image.height !== renderTarget.height) {
				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;
			}

			setTexture2D(renderTarget.depthTexture, 0);

			const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

			if (renderTarget.depthTexture.format === DepthFormat) {
				_gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
			} else if (renderTarget.depthTexture.format === DepthStencilFormat) {
				_gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
			} else {
				throw new Error('Unknown depthTexture format');
			}
		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer(renderTarget) {
			const renderTargetProperties = properties.get(renderTarget);

			const isCube = (renderTarget.isWebGLRenderTargetCube === true);

			if (renderTarget.depthTexture) {
				if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');

				setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
			} else if (isCube) {
				renderTargetProperties.__webglDepthbuffer = [];

				for (let i = 0; i < 6; i++) {
					_gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
					renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
					setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
				}
			} else {
				_gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
			}

			_gl.bindFramebuffer(36160, null);
		}

		// Set up GL resources for the render target
		function setupRenderTarget(renderTarget) {
			const renderTargetProperties = properties.get(renderTarget);
			const textureProperties = properties.get(renderTarget.texture);

			renderTarget.addEventListener('dispose', onRenderTargetDispose);

			textureProperties.__webglTexture = _gl.createTexture();

			info.memory.textures++;

			const isCube = (renderTarget.isWebGLRenderTargetCube === true);
			const isTargetPowerOfTwo = isPowerOfTwo(renderTarget);

			// Setup framebuffer

			if (isCube) {
				renderTargetProperties.__webglFramebuffer = [];

				for (var i = 0; i < 6; i++) {
					renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
				}
			} else {
				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
			}

			// Setup color buffer

			if (isCube) {
				state.bindTexture(34067, textureProperties.__webglTexture);
				setTextureParameters(34067, renderTarget.texture, isTargetPowerOfTwo);

				for (var i = 0; i < 6; i++) {
					setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);
				}

				if (textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) {
					generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);
				}

				state.bindTexture(34067, null);
			} else {
				state.bindTexture(3553, textureProperties.__webglTexture);
				setTextureParameters(3553, renderTarget.texture, isTargetPowerOfTwo);
				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);

				if (textureNeedsGenerateMipmaps(renderTarget.texture, isTargetPowerOfTwo)) {
					generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);
				}

				state.bindTexture(3553, null);
			}

			// Setup depth and stencil buffers

			if (renderTarget.depthBuffer) {
				setupDepthRenderbuffer(renderTarget);
			}
		}

		function updateRenderTargetMipmap(renderTarget) {
			const { texture } = renderTarget;
			const isTargetPowerOfTwo = isPowerOfTwo(renderTarget);

			if (textureNeedsGenerateMipmaps(texture, isTargetPowerOfTwo)) {
				const target = renderTarget.isWebGLRenderTargetCube ? 34067 : 3553;
				const webglTexture = properties.get(texture).__webglTexture;

				state.bindTexture(target, webglTexture);
				generateMipmap(target, texture, renderTarget.width, renderTarget.height);
				state.bindTexture(target, null);
			}
		}

		function updateVideoTexture(texture) {
			const { id } = texture;
			const { frame } = info.render;

			// Check the last frame we updated the VideoTexture

			if (_videoTextures[id] !== frame) {
				_videoTextures[id] = frame;
				texture.update();
			}
		}

		this.setTexture2D = setTexture2D;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.setTextureCubeDynamic = setTextureCubeDynamic;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	}

	/**
	 * @author thespite / http://www.twitter.com/thespite
	 */

	function WebGLUtils(gl, extensions, capabilities) {
		function convert(p) {
			let extension;

			if (p === RepeatWrapping) return 10497;
			if (p === ClampToEdgeWrapping) return 33071;
			if (p === MirroredRepeatWrapping) return 33648;

			if (p === NearestFilter) return 9728;
			if (p === NearestMipMapNearestFilter) return 9984;
			if (p === NearestMipMapLinearFilter) return 9986;

			if (p === LinearFilter) return 9729;
			if (p === LinearMipMapNearestFilter) return 9985;
			if (p === LinearMipMapLinearFilter) return 9987;

			if (p === UnsignedByteType) return 5121;
			if (p === UnsignedShort4444Type) return 32819;
			if (p === UnsignedShort5551Type) return 32820;
			if (p === UnsignedShort565Type) return 33635;

			if (p === ByteType) return 5120;
			if (p === ShortType) return 5122;
			if (p === UnsignedShortType) return 5123;
			if (p === IntType) return 5124;
			if (p === UnsignedIntType) return 5125;
			if (p === FloatType) return 5126;

			if (p === HalfFloatType) {
				if (capabilities.isWebGL2) return 5131;

				extension = extensions.get('OES_texture_half_float');

				if (extension !== null) return extension.HALF_FLOAT_OES;
			}

			if (p === AlphaFormat) return 6406;
			if (p === RGBFormat) return 6407;
			if (p === RGBAFormat) return 6408;
			if (p === LuminanceFormat) return 6409;
			if (p === LuminanceAlphaFormat) return 6410;
			if (p === DepthFormat) return 6402;
			if (p === DepthStencilFormat) return 34041;
			if (p === RedFormat) return 6403;

			if (p === AddEquation) return 32774;
			if (p === SubtractEquation) return 32778;
			if (p === ReverseSubtractEquation) return 32779;

			if (p === ZeroFactor) return 0;
			if (p === OneFactor) return 1;
			if (p === SrcColorFactor) return 768;
			if (p === OneMinusSrcColorFactor) return 769;
			if (p === SrcAlphaFactor) return 770;
			if (p === OneMinusSrcAlphaFactor) return 771;
			if (p === DstAlphaFactor) return 772;
			if (p === OneMinusDstAlphaFactor) return 773;

			if (p === DstColorFactor) return 774;
			if (p === OneMinusDstColorFactor) return 775;
			if (p === SrcAlphaSaturateFactor) return 776;

			if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format
				|| p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
				extension = extensions.get('WEBGL_compressed_texture_s3tc');

				if (extension !== null) {
					if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
				}
			}

			if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format
				|| p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
				extension = extensions.get('WEBGL_compressed_texture_pvrtc');

				if (extension !== null) {
					if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
				}
			}

			if (p === RGB_ETC1_Format) {
				extension = extensions.get('WEBGL_compressed_texture_etc1');

				if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
			}

			if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format
				|| p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format
				|| p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format
				|| p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format
				|| p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
				extension = extensions.get('WEBGL_compressed_texture_astc');

				if (extension !== null) {
					return p;
				}
			}

			if (p === MinEquation || p === MaxEquation) {
				if (capabilities.isWebGL2) {
					if (p === MinEquation) return 32775;
					if (p === MaxEquation) return 32776;
				}

				extension = extensions.get('EXT_blend_minmax');

				if (extension !== null) {
					if (p === MinEquation) return extension.MIN_EXT;
					if (p === MaxEquation) return extension.MAX_EXT;
				}
			}

			if (p === UnsignedInt248Type) {
				if (capabilities.isWebGL2) return 34042;

				extension = extensions.get('WEBGL_depth_texture');

				if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
			}

			return 0;
		}

		return { convert };
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Group() {
		Object3D.call(this);

		this.type = 'Group';
	}

	Group.prototype = Object.assign(Object.create(Object3D.prototype), {

		constructor: Group,

		isGroup: true,

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	function Camera() {
		Object3D.call(this);

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();

		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();
	}

	Camera.prototype = Object.assign(Object.create(Object3D.prototype), {

		constructor: Camera,

		isCamera: true,

		copy(source, recursive) {
			Object3D.prototype.copy.call(this, source, recursive);

			this.matrixWorldInverse.copy(source.matrixWorldInverse);

			this.projectionMatrix.copy(source.projectionMatrix);
			this.projectionMatrixInverse.copy(source.projectionMatrixInverse);

			return this;
		},

		getWorldDirection(target) {
			if (target === undefined) {
				console.warn('THREE.Camera: .getWorldDirection() target is now required');
				target = new Vector3();
			}

			this.updateMatrixWorld(true);

			const e = this.matrixWorld.elements;

			return target.set(-e[8], -e[9], -e[10]).normalize();
		},

		updateMatrixWorld(force) {
			Object3D.prototype.updateMatrixWorld.call(this, force);

			this.matrixWorldInverse.getInverse(this.matrixWorld);
		},

		clone() {
			return new this.constructor().copy(this);
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author tschw
	 */

	function PerspectiveCamera(fov, aspect, near, far) {
		Camera.call(this);

		this.type = 'PerspectiveCamera';

		this.fov = fov !== undefined ? fov : 50;
		this.zoom = 1;

		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
		this.focus = 10;

		this.aspect = aspect !== undefined ? aspect : 1;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();
	}

	PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {

		constructor: PerspectiveCamera,

		isPerspectiveCamera: true,

		copy(source, recursive) {
			Camera.prototype.copy.call(this, source, recursive);

			this.fov = source.fov;
			this.zoom = source.zoom;

			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;

			this.aspect = source.aspect;
			this.view = source.view === null ? null : ({ ...source.view });

			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;

			return this;
		},

		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength(focalLength) {
			// see http://www.bobatkins.com/photography/technical/field_of_view.html
			const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

			this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
			this.updateProjectionMatrix();
		},

		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength() {
			const vExtentSlope = Math.tan(_Math.DEG2RAD * 0.5 * this.fov);

			return 0.5 * this.getFilmHeight() / vExtentSlope;
		},

		getEffectiveFOV() {
			return _Math.RAD2DEG * 2 * Math.atan(
				Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom,
			);
		},

		getFilmWidth() {
			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min(this.aspect, 1);
		},

		getFilmHeight() {
			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max(this.aspect, 1);
		},

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   var w = 1920;
		 *   var h = 1080;
		 *   var fullWidth = w * 3;
		 *   var fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset(fullWidth, fullHeight, x, y, width, height) {
			this.aspect = fullWidth / fullHeight;

			if (this.view === null) {
				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1,
				};
			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();
		},

		clearViewOffset() {
			if (this.view !== null) {
				this.view.enabled = false;
			}

			this.updateProjectionMatrix();
		},

		updateProjectionMatrix() {
			const { near } = this;
			let top = near * Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom;
			let height = 2 * top;
			let width = this.aspect * height;
			let left = -0.5 * width;
			const { view } = this;

			if (this.view !== null && this.view.enabled) {
				const { fullWidth } = view;
				const { fullHeight } = view;

				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;
			}

			const skew = this.filmOffset;
			if (skew !== 0) left += near * skew / this.getFilmWidth();

			this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);

			this.projectionMatrixInverse.getInverse(this.projectionMatrix);
		},

		toJSON(meta) {
			const data = Object3D.prototype.toJSON.call(this, meta);

			data.object.fov = this.fov;
			data.object.zoom = this.zoom;

			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;

			data.object.aspect = this.aspect;

			if (this.view !== null) data.object.view = { ...this.view };

			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;

			return data;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function ArrayCamera(array) {
		PerspectiveCamera.call(this);

		this.cameras = array || [];
	}

	ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {

		constructor: ArrayCamera,

		isArrayCamera: true,

	});

	/**
	 * @author jsantell / https://www.jsantell.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	const cameraLPos = new Vector3();
	const cameraRPos = new Vector3();

	/**
	 * Assumes 2 cameras that are parallel and share an X-axis, and that
	 * the cameras' projection and world matrices have already been set.
	 * And that near and far planes are identical for both cameras.
	 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
	 */
	function setProjectionFromUnion(camera, cameraL, cameraR) {
		cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
		cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);

		const ipd = cameraLPos.distanceTo(cameraRPos);

		const projL = cameraL.projectionMatrix.elements;
		const projR = cameraR.projectionMatrix.elements;

		// VR systems will have identical far and near planes, and
		// most likely identical top and bottom frustum extents.
		// Use the left camera for these values.
		const near = projL[14] / (projL[10] - 1);
		const far = projL[14] / (projL[10] + 1);
		const topFov = (projL[9] + 1) / projL[5];
		const bottomFov = (projL[9] - 1) / projL[5];

		const leftFov = (projL[8] - 1) / projL[0];
		const rightFov = (projR[8] + 1) / projR[0];
		const left = near * leftFov;
		const right = near * rightFov;

		// Calculate the new camera's position offset from the
		// left camera. xOffset should be roughly half `ipd`.
		const zOffset = ipd / (-leftFov + rightFov);
		const xOffset = zOffset * -leftFov;

		// TODO: Better way to apply this offset?
		cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
		camera.translateX(xOffset);
		camera.translateZ(zOffset);
		camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
		camera.matrixWorldInverse.getInverse(camera.matrixWorld);

		// Find the union of the frustum values of the cameras and scale
		// the values so that the near plane's position does not change in world space,
		// although must now be relative to the new union camera.
		const near2 = near + zOffset;
		const far2 = far + zOffset;
		const left2 = left - xOffset;
		const right2 = right + (ipd - xOffset);
		const top2 = topFov * far / far2 * near2;
		const bottom2 = bottomFov * far / far2 * near2;

		camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebVRManager(renderer) {
		const scope = this;

		let device = null;
		let frameData = null;

		let poseTarget = null;

		const controllers = [];
		const standingMatrix = new Matrix4();
		const standingMatrixInverse = new Matrix4();

		let framebufferScaleFactor = 1.0;

		let frameOfReferenceType = 'stage';

		if (typeof window !== 'undefined' && 'VRFrameData' in window) {
			frameData = new window.VRFrameData();
			window.addEventListener('vrdisplaypresentchange', onVRDisplayPresentChange, false);
		}

		const matrixWorldInverse = new Matrix4();
		const tempQuaternion = new Quaternion();
		const tempPosition = new Vector3();

		const cameraL = new PerspectiveCamera();
		cameraL.bounds = new Vector4(0.0, 0.0, 0.5, 1.0);
		cameraL.layers.enable(1);

		const cameraR = new PerspectiveCamera();
		cameraR.bounds = new Vector4(0.5, 0.0, 0.5, 1.0);
		cameraR.layers.enable(2);

		const cameraVR = new ArrayCamera([cameraL, cameraR]);
		cameraVR.layers.enable(1);
		cameraVR.layers.enable(2);

		//

		function isPresenting() {
			return device !== null && device.isPresenting === true;
		}

		let currentSize; let
			currentPixelRatio;

		function onVRDisplayPresentChange() {
			if (isPresenting()) {
				const eyeParameters = device.getEyeParameters('left');
				const renderWidth = eyeParameters.renderWidth * framebufferScaleFactor;
				const renderHeight = eyeParameters.renderHeight * framebufferScaleFactor;

				currentPixelRatio = renderer.getPixelRatio();
				currentSize = renderer.getSize();

				renderer.setDrawingBufferSize(renderWidth * 2, renderHeight, 1);

				animation.start();
			} else {
				if (scope.enabled) {
					renderer.setDrawingBufferSize(currentSize.width, currentSize.height, currentPixelRatio);
				}

				animation.stop();
			}
		}

		//

		const triggers = [];

		function findGamepad(id) {
			const gamepads = navigator.getGamepads && navigator.getGamepads();

			for (let i = 0, j = 0, l = gamepads.length; i < l; i++) {
				const gamepad = gamepads[i];

				if (gamepad && (gamepad.id === 'Daydream Controller'
					|| gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller'
					|| gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith('Oculus Touch')
					|| gamepad.id.startsWith('Spatial Controller'))) {
					if (j === id) return gamepad;

					j++;
				}
			}
		}

		function updateControllers() {
			for (let i = 0; i < controllers.length; i++) {
				const controller = controllers[i];

				const gamepad = findGamepad(i);

				if (gamepad !== undefined && gamepad.pose !== undefined) {
					if (gamepad.pose === null) return;

					//  Pose

					const { pose } = gamepad;

					if (pose.hasPosition === false) controller.position.set(0.2, -0.6, -0.05);

					if (pose.position !== null) controller.position.fromArray(pose.position);
					if (pose.orientation !== null) controller.quaternion.fromArray(pose.orientation);
					controller.matrix.compose(controller.position, controller.quaternion, controller.scale);
					controller.matrix.premultiply(standingMatrix);
					controller.matrix.decompose(controller.position, controller.quaternion, controller.scale);
					controller.matrixWorldNeedsUpdate = true;
					controller.visible = true;

					//  Trigger

					const buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;

					if (triggers[i] !== gamepad.buttons[buttonId].pressed) {
						triggers[i] = gamepad.buttons[buttonId].pressed;

						if (triggers[i] === true) {
							controller.dispatchEvent({ type: 'selectstart' });
						} else {
							controller.dispatchEvent({ type: 'selectend' });
							controller.dispatchEvent({ type: 'select' });
						}
					}
				} else {
					controller.visible = false;
				}
			}
		}

		//

		this.enabled = false;

		this.getController = function (id) {
			let controller = controllers[id];

			if (controller === undefined) {
				controller = new Group();
				controller.matrixAutoUpdate = false;
				controller.visible = false;

				controllers[id] = controller;
			}

			return controller;
		};

		this.getDevice = function () {
			return device;
		};

		this.setDevice = function (value) {
			if (value !== undefined) device = value;

			animation.setContext(value);
		};

		this.setFramebufferScaleFactor = function (value) {
			framebufferScaleFactor = value;
		};

		this.setFrameOfReferenceType = function (value) {
			frameOfReferenceType = value;
		};

		this.setPoseTarget = function (object) {
			if (object !== undefined) poseTarget = object;
		};

		this.getCamera = function (camera) {
			const userHeight = frameOfReferenceType === 'stage' ? 1.6 : 0;

			if (device === null) {
				camera.position.set(0, userHeight, 0);
				return camera;
			}

			device.depthNear = camera.near;
			device.depthFar = camera.far;

			device.getFrameData(frameData);

			//

			if (frameOfReferenceType === 'stage') {
				const { stageParameters } = device;

				if (stageParameters) {
					standingMatrix.fromArray(stageParameters.sittingToStandingTransform);
				} else {
					standingMatrix.makeTranslation(0, userHeight, 0);
				}
			}


			const { pose } = frameData;
			const poseObject = poseTarget !== null ? poseTarget : camera;

			// We want to manipulate poseObject by its position and quaternion components since users may rely on them.
			poseObject.matrix.copy(standingMatrix);
			poseObject.matrix.decompose(poseObject.position, poseObject.quaternion, poseObject.scale);

			if (pose.orientation !== null) {
				tempQuaternion.fromArray(pose.orientation);
				poseObject.quaternion.multiply(tempQuaternion);
			}

			if (pose.position !== null) {
				tempQuaternion.setFromRotationMatrix(standingMatrix);
				tempPosition.fromArray(pose.position);
				tempPosition.applyQuaternion(tempQuaternion);
				poseObject.position.add(tempPosition);
			}

			poseObject.updateMatrixWorld();

			if (device.isPresenting === false) return camera;

			//

			cameraL.near = camera.near;
			cameraR.near = camera.near;

			cameraL.far = camera.far;
			cameraR.far = camera.far;

			cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix);
			cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix);

			// TODO (mrdoob) Double check this code

			standingMatrixInverse.getInverse(standingMatrix);

			if (frameOfReferenceType === 'stage') {
				cameraL.matrixWorldInverse.multiply(standingMatrixInverse);
				cameraR.matrixWorldInverse.multiply(standingMatrixInverse);
			}

			const { parent } = poseObject;

			if (parent !== null) {
				matrixWorldInverse.getInverse(parent.matrixWorld);

				cameraL.matrixWorldInverse.multiply(matrixWorldInverse);
				cameraR.matrixWorldInverse.multiply(matrixWorldInverse);
			}

			// envMap and Mirror needs camera.matrixWorld

			cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse);
			cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse);

			cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix);
			cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix);

			setProjectionFromUnion(cameraVR, cameraL, cameraR);

			//

			const layers = device.getLayers();

			if (layers.length) {
				const layer = layers[0];

				if (layer.leftBounds !== null && layer.leftBounds.length === 4) {
					cameraL.bounds.fromArray(layer.leftBounds);
				}

				if (layer.rightBounds !== null && layer.rightBounds.length === 4) {
					cameraR.bounds.fromArray(layer.rightBounds);
				}
			}

			updateControllers();

			return cameraVR;
		};

		this.getStandingMatrix = function () {
			return standingMatrix;
		};

		this.isPresenting = isPresenting;

		// Animation Loop

		var animation = new WebGLAnimation();

		this.setAnimationLoop = function (callback) {
			animation.setAnimationLoop(callback);
		};

		this.submitFrame = function () {
			if (isPresenting()) device.submitFrame();
		};

		this.dispose = function () {
			if (typeof window !== 'undefined') {
				window.removeEventListener('vrdisplaypresentchange', onVRDisplayPresentChange);
			}
		};
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebXRManager(renderer) {
		const gl = renderer.context;

		let device = null;
		let session = null;

		let framebufferScaleFactor = 1.0;

		let frameOfReference = null;
		let frameOfReferenceType = 'stage';

		let pose = null;

		const controllers = [];
		let inputSources = [];

		function isPresenting() {
			return session !== null && frameOfReference !== null;
		}

		//

		const cameraL = new PerspectiveCamera();
		cameraL.layers.enable(1);
		cameraL.viewport = new Vector4();

		const cameraR = new PerspectiveCamera();
		cameraR.layers.enable(2);
		cameraR.viewport = new Vector4();

		const cameraVR = new ArrayCamera([cameraL, cameraR]);
		cameraVR.layers.enable(1);
		cameraVR.layers.enable(2);

		//

		this.enabled = false;

		this.getController = function (id) {
			let controller = controllers[id];

			if (controller === undefined) {
				controller = new Group();
				controller.matrixAutoUpdate = false;
				controller.visible = false;

				controllers[id] = controller;
			}

			return controller;
		};

		this.getDevice = function () {
			return device;
		};

		this.setDevice = function (value) {
			if (value !== undefined) device = value;
			if (value instanceof XRDevice) gl.setCompatibleXRDevice(value);
		};

		//

		function onSessionEvent(event) {
			const controller = controllers[inputSources.indexOf(event.inputSource)];
			if (controller) controller.dispatchEvent({ type: event.type });
		}

		function onSessionEnd() {
			renderer.setFramebuffer(null);
			animation.stop();
		}

		this.setFramebufferScaleFactor = function (value) {
			framebufferScaleFactor = value;
		};

		this.setFrameOfReferenceType = function (value) {
			frameOfReferenceType = value;
		};

		this.setSession = function (value) {
			session = value;

			if (session !== null) {
				session.addEventListener('select', onSessionEvent);
				session.addEventListener('selectstart', onSessionEvent);
				session.addEventListener('selectend', onSessionEvent);
				session.addEventListener('end', onSessionEnd);

				session.baseLayer = new XRWebGLLayer(session, gl, { framebufferScaleFactor });
				session.requestFrameOfReference(frameOfReferenceType).then((value) => {
					frameOfReference = value;

					renderer.setFramebuffer(session.baseLayer.framebuffer);

					animation.setContext(session);
					animation.start();
				});

				//

				inputSources = session.getInputSources();

				session.addEventListener('inputsourceschange', () => {
					inputSources = session.getInputSources();
					console.log(inputSources);

					for (let i = 0; i < controllers.length; i++) {
						const controller = controllers[i];
						controller.userData.inputSource = inputSources[i];
					}
				});
			}
		};

		function updateCamera(camera, parent) {
			if (parent === null) {
				camera.matrixWorld.copy(camera.matrix);
			} else {
				camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
			}

			camera.matrixWorldInverse.getInverse(camera.matrixWorld);
		}

		this.getCamera = function (camera) {
			if (isPresenting()) {
				const { parent } = camera;
				const { cameras } = cameraVR;

				updateCamera(cameraVR, parent);

				for (var i = 0; i < cameras.length; i++) {
					updateCamera(cameras[i], parent);
				}

				// update camera and its children

				camera.matrixWorld.copy(cameraVR.matrixWorld);

				const { children } = camera;

				for (var i = 0, l = children.length; i < l; i++) {
					children[i].updateMatrixWorld(true);
				}

				setProjectionFromUnion(cameraVR, cameraL, cameraR);

				return cameraVR;
			}

			return camera;
		};

		this.isPresenting = isPresenting;

		// Animation Loop

		let onAnimationFrameCallback = null;

		function onAnimationFrame(time, frame) {
			pose = frame.getDevicePose(frameOfReference);

			if (pose !== null) {
				const layer = session.baseLayer;
				const { views } = frame;

				for (var i = 0; i < views.length; i++) {
					const view = views[i];
					const viewport = layer.getViewport(view);
					const viewMatrix = pose.getViewMatrix(view);

					const camera = cameraVR.cameras[i];
					camera.matrix.fromArray(viewMatrix).getInverse(camera.matrix);
					camera.projectionMatrix.fromArray(view.projectionMatrix);
					camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

					if (i === 0) {
						cameraVR.matrix.copy(camera.matrix);
					}
				}
			}

			//

			for (var i = 0; i < controllers.length; i++) {
				const controller = controllers[i];

				const inputSource = inputSources[i];

				if (inputSource) {
					const inputPose = frame.getInputPose(inputSource, frameOfReference);

					if (inputPose !== null) {
						if ('targetRay' in inputPose) {
							controller.matrix.elements = inputPose.targetRay.transformMatrix;
						} else if ('pointerMatrix' in inputPose) {
							// DEPRECATED

							controller.matrix.elements = inputPose.pointerMatrix;
						}

						controller.matrix.decompose(controller.position, controller.rotation, controller.scale);
						controller.visible = true;

						continue;
					}
				}

				controller.visible = false;
			}

			if (onAnimationFrameCallback) onAnimationFrameCallback(time);
		}

		var animation = new WebGLAnimation();
		animation.setAnimationLoop(onAnimationFrame);

		this.setAnimationLoop = function (callback) {
			onAnimationFrameCallback = callback;
		};

		this.dispose = function () {};

		// DEPRECATED

		this.getStandingMatrix = function () {
			console.warn('THREE.WebXRManager: getStandingMatrix() is no longer needed.');
			return new THREE.Matrix4();
		};

		this.submitFrame = function () {};
	}

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 * @author tschw
	 */

	function WebGLRenderer(parameters) {
		console.log('THREE.WebGLRenderer', REVISION);

		parameters = parameters || {};

		const _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
		const _context = parameters.context !== undefined ? parameters.context : null;

		const _alpha = parameters.alpha !== undefined ? parameters.alpha : false;
		const _depth = parameters.depth !== undefined ? parameters.depth : true;
		const _stencil = parameters.stencil !== undefined ? parameters.stencil : true;
		const _antialias = parameters.antialias !== undefined ? parameters.antialias : false;
		const _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true;
		const _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
		const _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';

		let currentRenderList = null;
		let currentRenderState = null;

		// public properties

		this.domElement = _canvas;
		this.context = null;

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false;

		// physically based shading

		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;

		// physical lights

		this.physicallyCorrectLights = false;

		// tone mapping

		this.toneMapping = LinearToneMapping;
		this.toneMappingExposure = 1.0;
		this.toneMappingWhitePoint = 1.0;

		// morphs

		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;

		// internal properties

		const _this = this;

		let _isContextLost = false;

		// internal state cache

		let _framebuffer = null;

		let _currentRenderTarget = null;
		let _currentFramebuffer = null;
		let _currentMaterialId = -1;

		// geometry and program caching

		const _currentGeometryProgram = {
			geometry: null,
			program: null,
			wireframe: false,
		};

		let _currentCamera = null;
		let _currentArrayCamera = null;

		const _currentViewport = new Vector4();
		const _currentScissor = new Vector4();
		let _currentScissorTest = null;

		//

		let _usedTextureUnits = 0;

		//

		let _width = _canvas.width;
		let _height = _canvas.height;

		let _pixelRatio = 1;

		const _viewport = new Vector4(0, 0, _width, _height);
		const _scissor = new Vector4(0, 0, _width, _height);
		let _scissorTest = false;

		// frustum

		const _frustum = new Frustum();

		// clipping

		const _clipping = new WebGLClipping();
		let _clippingEnabled = false;
		let _localClippingEnabled = false;

		// camera matrices cache

		const _projScreenMatrix = new Matrix4();

		const _vector3 = new Vector3();

		function getTargetPixelRatio() {
			return _currentRenderTarget === null ? _pixelRatio : 1;
		}

		// initialize

		let _gl;

		try {
			const contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference,
			};

			// event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener('webglcontextlost', onContextLost, false);
			_canvas.addEventListener('webglcontextrestored', onContextRestore, false);

			_gl = _context || _canvas.getContext('webgl', contextAttributes) || _canvas.getContext('experimental-webgl', contextAttributes);

			if (_gl === null) {
				if (_canvas.getContext('webgl') !== null) {
					throw new Error('Error creating WebGL context with your selected attributes.');
				} else {
					throw new Error('Error creating WebGL context.');
				}
			}

			// Some experimental-webgl implementations do not have getShaderPrecisionFormat

			if (_gl.getShaderPrecisionFormat === undefined) {
				_gl.getShaderPrecisionFormat = function () {
					return { rangeMin: 1, rangeMax: 1, precision: 1 };
				};
			}
		} catch (error) {
			console.error(`THREE.WebGLRenderer: ${error.message}`);
		}

		let extensions; let capabilities; let state; let
			info;
		let properties; let textures; let attributes; let geometries; let
			objects;
		let programCache; let renderLists; let
			renderStates;

		let background; let morphtargets; let bufferRenderer; let
			indexedBufferRenderer;

		let utils;

		function initGLContext() {
			extensions = new WebGLExtensions(_gl);

			capabilities = new WebGLCapabilities(_gl, extensions, parameters);

			if (!capabilities.isWebGL2) {
				extensions.get('WEBGL_depth_texture');
				extensions.get('OES_texture_float');
				extensions.get('OES_texture_half_float');
				extensions.get('OES_texture_half_float_linear');
				extensions.get('OES_standard_derivatives');
				extensions.get('OES_element_index_uint');
				extensions.get('ANGLE_instanced_arrays');
			}

			extensions.get('OES_texture_float_linear');

			utils = new WebGLUtils(_gl, extensions, capabilities);

			state = new WebGLState(_gl, extensions, utils, capabilities);
			state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
			state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));

			info = new WebGLInfo(_gl);
			properties = new WebGLProperties();
			textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
			attributes = new WebGLAttributes(_gl);
			geometries = new WebGLGeometries(_gl, attributes, info);
			objects = new WebGLObjects(geometries, info);
			morphtargets = new WebGLMorphtargets(_gl);
			programCache = new WebGLPrograms(_this, extensions, capabilities);
			renderLists = new WebGLRenderLists();
			renderStates = new WebGLRenderStates();

			background = new WebGLBackground(_this, state, objects, _premultipliedAlpha);

			bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
			indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);

			info.programs = programCache.programs;

			_this.context = _gl;
			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.state = state;
			_this.info = info;
		}

		initGLContext();

		// vr

		let vr = null;

		if (typeof navigator !== 'undefined') {
			vr = ('xr' in navigator) ? new WebXRManager(_this) : new WebVRManager(_this);
		}

		this.vr = vr;

		// shadow map

		const shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);

		this.shadowMap = shadowMap;

		// API

		this.getContext = function () {
			return _gl;
		};

		this.getContextAttributes = function () {
			return _gl.getContextAttributes();
		};

		this.forceContextLoss = function () {
			const extension = extensions.get('WEBGL_lose_context');
			if (extension) extension.loseContext();
		};

		this.forceContextRestore = function () {
			const extension = extensions.get('WEBGL_lose_context');
			if (extension) extension.restoreContext();
		};

		this.getPixelRatio = function () {
			return _pixelRatio;
		};

		this.setPixelRatio = function (value) {
			if (value === undefined) return;

			_pixelRatio = value;

			this.setSize(_width, _height, false);
		};

		this.getSize = function () {
			return {
				width: _width,
				height: _height,
			};
		};

		this.setSize = function (width, height, updateStyle) {
			if (vr.isPresenting()) {
				console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
				return;
			}

			_width = width;
			_height = height;

			_canvas.width = width * _pixelRatio;
			_canvas.height = height * _pixelRatio;

			if (updateStyle !== false) {
				_canvas.style.width = `${width}px`;
				_canvas.style.height = `${height}px`;
			}

			this.setViewport(0, 0, width, height);
		};

		this.getDrawingBufferSize = function () {
			return {
				width: _width * _pixelRatio,
				height: _height * _pixelRatio,
			};
		};

		this.setDrawingBufferSize = function (width, height, pixelRatio) {
			_width = width;
			_height = height;

			_pixelRatio = pixelRatio;

			_canvas.width = width * pixelRatio;
			_canvas.height = height * pixelRatio;

			this.setViewport(0, 0, width, height);
		};

		this.getCurrentViewport = function () {
			return _currentViewport;
		};

		this.setViewport = function (x, y, width, height) {
			_viewport.set(x, _height - y - height, width, height);
			state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
		};

		this.setScissor = function (x, y, width, height) {
			_scissor.set(x, _height - y - height, width, height);
			state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
		};

		this.setScissorTest = function (boolean) {
			state.setScissorTest(_scissorTest = boolean);
		};

		// Clearing

		this.getClearColor = function () {
			return background.getClearColor();
		};

		this.setClearColor = function () {
			background.setClearColor.apply(background, arguments);
		};

		this.getClearAlpha = function () {
			return background.getClearAlpha();
		};

		this.setClearAlpha = function () {
			background.setClearAlpha.apply(background, arguments);
		};

		this.clear = function (color, depth, stencil) {
			let bits = 0;

			if (color === undefined || color) bits |= 16384;
			if (depth === undefined || depth) bits |= 256;
			if (stencil === undefined || stencil) bits |= 1024;

			_gl.clear(bits);
		};

		this.clearColor = function () {
			this.clear(true, false, false);
		};

		this.clearDepth = function () {
			this.clear(false, true, false);
		};

		this.clearStencil = function () {
			this.clear(false, false, true);
		};

		//

		this.dispose = function () {
			_canvas.removeEventListener('webglcontextlost', onContextLost, false);
			_canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			objects.dispose();

			vr.dispose();

			animation.stop();
		};

		// Events

		function onContextLost(event) {
			event.preventDefault();

			console.log('THREE.WebGLRenderer: Context Lost.');

			_isContextLost = true;
		}

		function onContextRestore(/* event */) {
			console.log('THREE.WebGLRenderer: Context Restored.');

			_isContextLost = false;

			initGLContext();
		}

		function onMaterialDispose(event) {
			const material = event.target;

			material.removeEventListener('dispose', onMaterialDispose);

			deallocateMaterial(material);
		}

		// Buffer deallocation

		function deallocateMaterial(material) {
			releaseMaterialProgramReference(material);

			properties.remove(material);
		}


		function releaseMaterialProgramReference(material) {
			const programInfo = properties.get(material).program;

			material.program = undefined;

			if (programInfo !== undefined) {
				programCache.releaseProgram(programInfo);
			}
		}

		// Buffer rendering

		function renderObjectImmediate(object, program) {
			object.render((object) => {
				_this.renderBufferImmediate(object, program);
			});
		}

		this.renderBufferImmediate = function (object, program) {
			state.initAttributes();

			const buffers = properties.get(object);

			if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
			if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
			if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
			if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();

			const programAttributes = program.getAttributes();

			if (object.hasPositions) {
				_gl.bindBuffer(34962, buffers.position);
				_gl.bufferData(34962, object.positionArray, 35048);

				state.enableAttribute(programAttributes.position);
				_gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
			}

			if (object.hasNormals) {
				_gl.bindBuffer(34962, buffers.normal);
				_gl.bufferData(34962, object.normalArray, 35048);

				state.enableAttribute(programAttributes.normal);
				_gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
			}

			if (object.hasUvs) {
				_gl.bindBuffer(34962, buffers.uv);
				_gl.bufferData(34962, object.uvArray, 35048);

				state.enableAttribute(programAttributes.uv);
				_gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
			}

			if (object.hasColors) {
				_gl.bindBuffer(34962, buffers.color);
				_gl.bufferData(34962, object.colorArray, 35048);

				state.enableAttribute(programAttributes.color);
				_gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
			}

			state.disableUnusedAttributes();

			_gl.drawArrays(4, 0, object.count);

			object.count = 0;
		};

		this.renderBufferDirect = function (camera, fog, geometry, material, object, group) {
			const frontFaceCW = (object.isMesh && object.normalMatrix.determinant() < 0);

			state.setMaterial(material, frontFaceCW);

			const program = setProgram(camera, fog, material, object);

			let updateBuffers = false;

			if (_currentGeometryProgram.geometry !== geometry.id
				|| _currentGeometryProgram.program !== program.id
				|| _currentGeometryProgram.wireframe !== (material.wireframe === true)) {
				_currentGeometryProgram.geometry = geometry.id;
				_currentGeometryProgram.program = program.id;
				_currentGeometryProgram.wireframe = material.wireframe === true;
				updateBuffers = true;
			}

			if (object.morphTargetInfluences) {
				morphtargets.update(object, geometry, material, program);

				updateBuffers = true;
			}

			//

			let { index } = geometry;
			const { position } = geometry.attributes;
			let rangeFactor = 1;

			if (material.wireframe === true) {
				index = geometries.getWireframeAttribute(geometry);
				rangeFactor = 2;
			}

			let attribute;
			let renderer = bufferRenderer;

			if (index !== null) {
				attribute = attributes.get(index);

				renderer = indexedBufferRenderer;
				renderer.setIndex(attribute);
			}

			if (updateBuffers) {
				setupVertexAttributes(material, program, geometry);

				if (index !== null) {
					_gl.bindBuffer(34963, attribute.buffer);
				}
			}

			//

			let dataCount = Infinity;

			if (index !== null) {
				dataCount = index.count;
			} else if (position !== undefined) {
				dataCount = position.count;
			}

			const rangeStart = geometry.drawRange.start * rangeFactor;
			const rangeCount = geometry.drawRange.count * rangeFactor;

			const groupStart = group !== null ? group.start * rangeFactor : 0;
			const groupCount = group !== null ? group.count * rangeFactor : Infinity;

			const drawStart = Math.max(rangeStart, groupStart);
			const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;

			const drawCount = Math.max(0, drawEnd - drawStart + 1);

			if (drawCount === 0) return;

			//

			if (object.isMesh) {
				if (material.wireframe === true) {
					state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
					renderer.setMode(1);
				} else {
					switch (object.drawMode) {
					case TrianglesDrawMode:
						renderer.setMode(4);
						break;

					case TriangleStripDrawMode:
						renderer.setMode(5);
						break;

					case TriangleFanDrawMode:
						renderer.setMode(6);
						break;
					}
				}
			} else if (object.isLine) {
				let lineWidth = material.linewidth;

				if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

				state.setLineWidth(lineWidth * getTargetPixelRatio());

				if (object.isLineSegments) {
					renderer.setMode(1);
				} else if (object.isLineLoop) {
					renderer.setMode(2);
				} else {
					renderer.setMode(3);
				}
			} else if (object.isPoints) {
				renderer.setMode(0);
			} else if (object.isSprite) {
				renderer.setMode(4);
			}

			if (geometry && geometry.isInstancedBufferGeometry) {
				if (geometry.maxInstancedCount > 0) {
					renderer.renderInstances(geometry, drawStart, drawCount);
				}
			} else {
				renderer.render(drawStart, drawCount);
			}
		};

		function setupVertexAttributes(material, program, geometry) {
			if (geometry && geometry.isInstancedBufferGeometry & !capabilities.isWebGL2) {
				if (extensions.get('ANGLE_instanced_arrays') === null) {
					console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
					return;
				}
			}

			state.initAttributes();

			const geometryAttributes = geometry.attributes;

			const programAttributes = program.getAttributes();

			const materialDefaultAttributeValues = material.defaultAttributeValues;

			for (const name in programAttributes) {
				const programAttribute = programAttributes[name];

				if (programAttribute >= 0) {
					const geometryAttribute = geometryAttributes[name];

					if (geometryAttribute !== undefined) {
						const { normalized } = geometryAttribute;
						const size = geometryAttribute.itemSize;

						const attribute = attributes.get(geometryAttribute);

						// TODO Attribute may not be available on context restore

						if (attribute === undefined) continue;

						const { buffer } = attribute;
						const { type } = attribute;
						const { bytesPerElement } = attribute;

						if (geometryAttribute.isInterleavedBufferAttribute) {
							const { data } = geometryAttribute;
							const { stride } = data;
							const { offset } = geometryAttribute;

							if (data && data.isInstancedInterleavedBuffer) {
								state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);

								if (geometry.maxInstancedCount === undefined) {
									geometry.maxInstancedCount = data.meshPerAttribute * data.count;
								}
							} else {
								state.enableAttribute(programAttribute);
							}

							_gl.bindBuffer(34962, buffer);
							_gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
						} else {
							if (geometryAttribute.isInstancedBufferAttribute) {
								state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);

								if (geometry.maxInstancedCount === undefined) {
									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
								}
							} else {
								state.enableAttribute(programAttribute);
							}

							_gl.bindBuffer(34962, buffer);
							_gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
						}
					} else if (materialDefaultAttributeValues !== undefined) {
						const value = materialDefaultAttributeValues[name];

						if (value !== undefined) {
							switch (value.length) {
							case 2:
								_gl.vertexAttrib2fv(programAttribute, value);
								break;

							case 3:
								_gl.vertexAttrib3fv(programAttribute, value);
								break;

							case 4:
								_gl.vertexAttrib4fv(programAttribute, value);
								break;

							default:
								_gl.vertexAttrib1fv(programAttribute, value);
							}
						}
					}
				}
			}

			state.disableUnusedAttributes();
		}

		// Compile

		this.compile = function (scene, camera) {
			currentRenderState = renderStates.get(scene, camera);
			currentRenderState.init();

			scene.traverse((object) => {
				if (object.isLight) {
					currentRenderState.pushLight(object);

					if (object.castShadow) {
						currentRenderState.pushShadow(object);
					}
				}
			});

			currentRenderState.setupLights(camera);

			scene.traverse((object) => {
				if (object.material) {
					if (Array.isArray(object.material)) {
						for (let i = 0; i < object.material.length; i++) {
							initMaterial(object.material[i], scene.fog, object);
						}
					} else {
						initMaterial(object.material, scene.fog, object);
					}
				}
			});
		};

		// Animation Loop

		let onAnimationFrameCallback = null;

		function onAnimationFrame(time) {
			if (vr.isPresenting()) return;
			if (onAnimationFrameCallback) onAnimationFrameCallback(time);
		}

		var animation = new WebGLAnimation();
		animation.setAnimationLoop(onAnimationFrame);

		if (typeof window !== 'undefined') animation.setContext(window);

		this.setAnimationLoop = function (callback) {
			onAnimationFrameCallback = callback;
			vr.setAnimationLoop(callback);

			animation.start();
		};

		// Rendering

		this.render = function (scene, camera, renderTarget, forceClear) {
			if (!(camera && camera.isCamera)) {
				console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
				return;
			}

			if (_isContextLost) return;

			// reset caching for this frame

			_currentGeometryProgram.geometry = null;
			_currentGeometryProgram.program = null;
			_currentGeometryProgram.wireframe = false;
			_currentMaterialId = -1;
			_currentCamera = null;

			// update scene graph

			if (scene.autoUpdate === true) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if (camera.parent === null) camera.updateMatrixWorld();

			if (vr.enabled) {
				camera = vr.getCamera(camera);
			}

			//

			currentRenderState = renderStates.get(scene, camera);
			currentRenderState.init();

			scene.onBeforeRender(_this, scene, camera, renderTarget);

			_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
			_frustum.setFromMatrix(_projScreenMatrix);

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);

			currentRenderList = renderLists.get(scene, camera);
			currentRenderList.init();

			projectObject(scene, camera, _this.sortObjects);

			if (_this.sortObjects === true) {
				currentRenderList.sort();
			}

			//

			if (_clippingEnabled) _clipping.beginShadows();

			const { shadowsArray } = currentRenderState.state;

			shadowMap.render(shadowsArray, scene, camera);

			currentRenderState.setupLights(camera);

			if (_clippingEnabled) _clipping.endShadows();

			//

			if (this.info.autoReset) this.info.reset();

			if (renderTarget === undefined) {
				renderTarget = null;
			}

			this.setRenderTarget(renderTarget);

			//

			background.render(currentRenderList, scene, camera, forceClear);

			// render scene

			const opaqueObjects = currentRenderList.opaque;
			const transparentObjects = currentRenderList.transparent;

			if (scene.overrideMaterial) {
				const { overrideMaterial } = scene;

				if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera, overrideMaterial);
				if (transparentObjects.length) renderObjects(transparentObjects, scene, camera, overrideMaterial);
			} else {
				// opaque pass (front-to-back order)

				if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera);

				// transparent pass (back-to-front order)

				if (transparentObjects.length) renderObjects(transparentObjects, scene, camera);
			}

			// Generate mipmap if we're using any kind of mipmap filtering

			if (renderTarget) {
				textures.updateRenderTargetMipmap(renderTarget);
			}

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest(true);
			state.buffers.depth.setMask(true);
			state.buffers.color.setMask(true);

			state.setPolygonOffset(false);

			scene.onAfterRender(_this, scene, camera);

			if (vr.enabled) {
				vr.submitFrame();
			}

			// _gl.finish();

			currentRenderList = null;
			currentRenderState = null;
		};

		function projectObject(object, camera, sortObjects) {
			if (object.visible === false) return;

			const visible = object.layers.test(camera.layers);

			if (visible) {
				if (object.isLight) {
					currentRenderState.pushLight(object);

					if (object.castShadow) {
						currentRenderState.pushShadow(object);
					}
				} else if (object.isSprite) {
					if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
						if (sortObjects) {
							_vector3.setFromMatrixPosition(object.matrixWorld)
								.applyMatrix4(_projScreenMatrix);
						}

						var geometry = objects.update(object);
						var { material } = object;

						currentRenderList.push(object, geometry, material, _vector3.z, null);
					}
				} else if (object.isImmediateRenderObject) {
					if (sortObjects) {
						_vector3.setFromMatrixPosition(object.matrixWorld)
							.applyMatrix4(_projScreenMatrix);
					}

					currentRenderList.push(object, null, object.material, _vector3.z, null);
				} else if (object.isMesh || object.isLine || object.isPoints) {
					if (object.isSkinnedMesh) {
						object.skeleton.update();
					}

					if (!object.frustumCulled || _frustum.intersectsObject(object)) {
						if (sortObjects) {
							_vector3.setFromMatrixPosition(object.matrixWorld)
								.applyMatrix4(_projScreenMatrix);
						}

						var geometry = objects.update(object);
						var { material } = object;

						if (Array.isArray(material)) {
							const { groups } = geometry;

							for (var i = 0, l = groups.length; i < l; i++) {
								const group = groups[i];
								const groupMaterial = material[group.materialIndex];

								if (groupMaterial && groupMaterial.visible) {
									currentRenderList.push(object, geometry, groupMaterial, _vector3.z, group);
								}
							}
						} else if (material.visible) {
							currentRenderList.push(object, geometry, material, _vector3.z, null);
						}
					}
				}
			}

			const { children } = object;

			for (var i = 0, l = children.length; i < l; i++) {
				projectObject(children[i], camera, sortObjects);
			}
		}

		function renderObjects(renderList, scene, camera, overrideMaterial) {
			for (let i = 0, l = renderList.length; i < l; i++) {
				const renderItem = renderList[i];

				const { object } = renderItem;
				const { geometry } = renderItem;
				const material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
				const { group } = renderItem;

				if (camera.isArrayCamera) {
					_currentArrayCamera = camera;

					const { cameras } = camera;

					for (let j = 0, jl = cameras.length; j < jl; j++) {
						const camera2 = cameras[j];

						if (object.layers.test(camera2.layers)) {
							if ('viewport' in camera2) { // XR
								state.viewport(_currentViewport.copy(camera2.viewport));
							} else {
								const { bounds } = camera2;

								const x = bounds.x * _width;
								const y = bounds.y * _height;
								const width = bounds.z * _width;
								const height = bounds.w * _height;

								state.viewport(_currentViewport.set(x, y, width, height).multiplyScalar(_pixelRatio));
							}

							currentRenderState.setupLights(camera2);

							renderObject(object, scene, camera2, geometry, material, group);
						}
					}
				} else {
					_currentArrayCamera = null;

					renderObject(object, scene, camera, geometry, material, group);
				}
			}
		}

		function renderObject(object, scene, camera, geometry, material, group) {
			object.onBeforeRender(_this, scene, camera, geometry, material, group);
			currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);

			object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
			object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

			if (object.isImmediateRenderObject) {
				state.setMaterial(material);

				const program = setProgram(camera, scene.fog, material, object);

				_currentGeometryProgram.geometry = null;
				_currentGeometryProgram.program = null;
				_currentGeometryProgram.wireframe = false;

				renderObjectImmediate(object, program);
			} else {
				_this.renderBufferDirect(camera, scene.fog, geometry, material, object, group);
			}

			object.onAfterRender(_this, scene, camera, geometry, material, group);
			currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
		}

		function initMaterial(material, fog, object) {
			const materialProperties = properties.get(material);

			const { lights } = currentRenderState.state;
			const { shadowsArray } = currentRenderState.state;

			let { lightsHash } = materialProperties;
			const lightsStateHash = lights.state.hash;

			const parameters = programCache.getParameters(
				material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object,
			);

			let code = programCache.getProgramCode(material, parameters);

			let { program } = materialProperties;
			let programChange = true;

			if (program === undefined) {
				// new material
				material.addEventListener('dispose', onMaterialDispose);
			} else if (program.code !== code) {
				// changed glsl or parameters
				releaseMaterialProgramReference(material);
			} else if (lightsHash.stateID !== lightsStateHash.stateID
				|| lightsHash.directionalLength !== lightsStateHash.directionalLength
				|| lightsHash.pointLength !== lightsStateHash.pointLength
				|| lightsHash.spotLength !== lightsStateHash.spotLength
				|| lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength
				|| lightsHash.hemiLength !== lightsStateHash.hemiLength
				|| lightsHash.shadowsLength !== lightsStateHash.shadowsLength) {
				lightsHash.stateID = lightsStateHash.stateID;
				lightsHash.directionalLength = lightsStateHash.directionalLength;
				lightsHash.pointLength = lightsStateHash.pointLength;
				lightsHash.spotLength = lightsStateHash.spotLength;
				lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
				lightsHash.hemiLength = lightsStateHash.hemiLength;
				lightsHash.shadowsLength = lightsStateHash.shadowsLength;

				programChange = false;
			} else if (parameters.shaderID !== undefined) {
				// same glsl and uniform list
				return;
			} else {
				// only rebuild uniform list
				programChange = false;
			}

			if (programChange) {
				if (parameters.shaderID) {
					const shader = ShaderLib[parameters.shaderID];

					materialProperties.shader = {
						name: material.type,
						uniforms: cloneUniforms(shader.uniforms),
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader,
					};
				} else {
					materialProperties.shader = {
						name: material.type,
						uniforms: material.uniforms,
						vertexShader: material.vertexShader,
						fragmentShader: material.fragmentShader,
					};
				}

				material.onBeforeCompile(materialProperties.shader, _this);

				// Computing code again as onBeforeCompile may have changed the shaders
				code = programCache.getProgramCode(material, parameters);

				program = programCache.acquireProgram(material, materialProperties.shader, parameters, code);

				materialProperties.program = program;
				material.program = program;
			}

			const programAttributes = program.getAttributes();

			if (material.morphTargets) {
				material.numSupportedMorphTargets = 0;

				for (var i = 0; i < _this.maxMorphTargets; i++) {
					if (programAttributes[`morphTarget${i}`] >= 0) {
						material.numSupportedMorphTargets++;
					}
				}
			}

			if (material.morphNormals) {
				material.numSupportedMorphNormals = 0;

				for (var i = 0; i < _this.maxMorphNormals; i++) {
					if (programAttributes[`morphNormal${i}`] >= 0) {
						material.numSupportedMorphNormals++;
					}
				}
			}

			const { uniforms } = materialProperties.shader;

			if (!material.isShaderMaterial
				&& !material.isRawShaderMaterial
				|| material.clipping === true) {
				materialProperties.numClippingPlanes = _clipping.numPlanes;
				materialProperties.numIntersection = _clipping.numIntersection;
				uniforms.clippingPlanes = _clipping.uniform;
			}

			materialProperties.fog = fog;

			// store the light setup it was created for
			if (lightsHash === undefined) {
				materialProperties.lightsHash = lightsHash = {};
			}

			lightsHash.stateID = lightsStateHash.stateID;
			lightsHash.directionalLength = lightsStateHash.directionalLength;
			lightsHash.pointLength = lightsStateHash.pointLength;
			lightsHash.spotLength = lightsStateHash.spotLength;
			lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
			lightsHash.hemiLength = lightsStateHash.hemiLength;
			lightsHash.shadowsLength = lightsStateHash.shadowsLength;

			if (material.lights) {
				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.pointLights.value = lights.state.point;
				uniforms.hemisphereLights.value = lights.state.hemi;

				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms
			}

			const progUniforms = materialProperties.program.getUniforms();
			const uniformsList =					WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);

			materialProperties.uniformsList = uniformsList;
		}

		function setProgram(camera, fog, material, object) {
			_usedTextureUnits = 0;

			const materialProperties = properties.get(material);
			const { lights } = currentRenderState.state;

			const { lightsHash } = materialProperties;
			const lightsStateHash = lights.state.hash;

			if (_clippingEnabled) {
				if (_localClippingEnabled || camera !== _currentCamera) {
					const useCache =						camera === _currentCamera
						&& material.id === _currentMaterialId;

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					_clipping.setState(
						material.clippingPlanes, material.clipIntersection, material.clipShadows,
						camera, materialProperties, useCache,
					);
				}
			}

			if (material.needsUpdate === false) {
				if (materialProperties.program === undefined) {
					material.needsUpdate = true;
				} else if (material.fog && materialProperties.fog !== fog) {
					material.needsUpdate = true;
				} else if (material.lights && (lightsHash.stateID !== lightsStateHash.stateID
					|| lightsHash.directionalLength !== lightsStateHash.directionalLength
					|| lightsHash.pointLength !== lightsStateHash.pointLength
					|| lightsHash.spotLength !== lightsStateHash.spotLength
					|| lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength
					|| lightsHash.hemiLength !== lightsStateHash.hemiLength
					|| lightsHash.shadowsLength !== lightsStateHash.shadowsLength)) {
					material.needsUpdate = true;
				} else if (materialProperties.numClippingPlanes !== undefined
					&& (materialProperties.numClippingPlanes !== _clipping.numPlanes
					|| materialProperties.numIntersection !== _clipping.numIntersection)) {
					material.needsUpdate = true;
				}
			}

			if (material.needsUpdate) {
				initMaterial(material, fog, object);
				material.needsUpdate = false;
			}

			let refreshProgram = false;
			let refreshMaterial = false;
			let refreshLights = false;

			const { program } = materialProperties;
			const p_uniforms = program.getUniforms();
			const m_uniforms = materialProperties.shader.uniforms;

			if (state.useProgram(program.program)) {
				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;
			}

			if (material.id !== _currentMaterialId) {
				_currentMaterialId = material.id;

				refreshMaterial = true;
			}

			if (refreshProgram || _currentCamera !== camera) {
				p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

				if (capabilities.logarithmicDepthBuffer) {
					p_uniforms.setValue(_gl, 'logDepthBufFC',
						2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
				}

				if (_currentCamera !== camera) {
					_currentCamera = camera;

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done
				}

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if (material.isShaderMaterial
					|| material.isMeshPhongMaterial
					|| material.isMeshStandardMaterial
					|| material.envMap) {
					const uCamPos = p_uniforms.map.cameraPosition;

					if (uCamPos !== undefined) {
						uCamPos.setValue(_gl,
							_vector3.setFromMatrixPosition(camera.matrixWorld));
					}
				}

				if (material.isMeshPhongMaterial
					|| material.isMeshLambertMaterial
					|| material.isMeshBasicMaterial
					|| material.isMeshStandardMaterial
					|| material.isShaderMaterial
					|| material.skinning) {
					p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
				}
			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen

			if (material.skinning) {
				p_uniforms.setOptional(_gl, object, 'bindMatrix');
				p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');

				const { skeleton } = object;

				if (skeleton) {
					const { bones } = skeleton;

					if (capabilities.floatVertexTextures) {
						if (skeleton.boneTexture === undefined) {
							// layout (1 matrix = 4 pixels)
							//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
							//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
							//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
							//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
							//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


							let size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix
							size = _Math.ceilPowerOfTwo(size);
							size = Math.max(size, 4);

							const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
							boneMatrices.set(skeleton.boneMatrices); // copy current values

							const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
							boneTexture.needsUpdate = true;

							skeleton.boneMatrices = boneMatrices;
							skeleton.boneTexture = boneTexture;
							skeleton.boneTextureSize = size;
						}

						p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture);
						p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
					} else {
						p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
					}
				}
			}

			if (refreshMaterial) {
				p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
				p_uniforms.setValue(_gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint);

				if (material.lights) {
					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
				}

				// refresh uniforms common to several materials

				if (fog && material.fog) {
					refreshUniformsFog(m_uniforms, fog);
				}

				if (material.isMeshBasicMaterial) {
					refreshUniformsCommon(m_uniforms, material);
				} else if (material.isMeshLambertMaterial) {
					refreshUniformsCommon(m_uniforms, material);
					refreshUniformsLambert(m_uniforms, material);
				} else if (material.isMeshPhongMaterial) {
					refreshUniformsCommon(m_uniforms, material);

					if (material.isMeshToonMaterial) {
						refreshUniformsToon(m_uniforms, material);
					} else {
						refreshUniformsPhong(m_uniforms, material);
					}
				} else if (material.isMeshStandardMaterial) {
					refreshUniformsCommon(m_uniforms, material);

					if (material.isMeshPhysicalMaterial) {
						refreshUniformsPhysical(m_uniforms, material);
					} else {
						refreshUniformsStandard(m_uniforms, material);
					}
				} else if (material.isMeshMatcapMaterial) {
					refreshUniformsCommon(m_uniforms, material);

					refreshUniformsMatcap(m_uniforms, material);
				} else if (material.isMeshDepthMaterial) {
					refreshUniformsCommon(m_uniforms, material);
					refreshUniformsDepth(m_uniforms, material);
				} else if (material.isMeshDistanceMaterial) {
					refreshUniformsCommon(m_uniforms, material);
					refreshUniformsDistance(m_uniforms, material);
				} else if (material.isMeshNormalMaterial) {
					refreshUniformsCommon(m_uniforms, material);
					refreshUniformsNormal(m_uniforms, material);
				} else if (material.isLineBasicMaterial) {
					refreshUniformsLine(m_uniforms, material);

					if (material.isLineDashedMaterial) {
						refreshUniformsDash(m_uniforms, material);
					}
				} else if (material.isPointsMaterial) {
					refreshUniformsPoints(m_uniforms, material);
				} else if (material.isSpriteMaterial) {
					refreshUniformsSprites(m_uniforms, material);
				} else if (material.isShadowMaterial) {
					m_uniforms.color.value = material.color;
					m_uniforms.opacity.value = material.opacity;
				}

				// RectAreaLight Texture
				// TODO (mrdoob): Find a nicer implementation

				if (m_uniforms.ltc_1 !== undefined) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
				if (m_uniforms.ltc_2 !== undefined) m_uniforms.ltc_2.value = UniformsLib.LTC_2;

				WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
			}

			if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
				WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, _this);
				material.uniformsNeedUpdate = false;
			}

			if (material.isSpriteMaterial) {
				p_uniforms.setValue(_gl, 'center', object.center);
			}

			// common matrices

			p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
			p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
			p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);

			return program;
		}

		// Uniforms (refresh uniforms objects)

		function refreshUniformsCommon(uniforms, material) {
			uniforms.opacity.value = material.opacity;

			if (material.color) {
				uniforms.diffuse.value = material.color;
			}

			if (material.emissive) {
				uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
			}

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			}

			if (material.specularMap) {
				uniforms.specularMap.value = material.specularMap;
			}

			if (material.envMap) {
				uniforms.envMap.value = material.envMap;

				// don't flip CubeTexture envMaps, flip everything else:
				//  WebGLRenderTargetCube will be flipped for backwards compatibility
				//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
				// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
				uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? -1 : 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

				uniforms.maxMipLevel.value = properties.get(material.envMap).__maxMipLevel;
			}

			if (material.lightMap) {
				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
			}

			if (material.aoMap) {
				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;
			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map

			let uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.specularMap) {
				uvScaleMap = material.specularMap;
			} else if (material.displacementMap) {
				uvScaleMap = material.displacementMap;
			} else if (material.normalMap) {
				uvScaleMap = material.normalMap;
			} else if (material.bumpMap) {
				uvScaleMap = material.bumpMap;
			} else if (material.roughnessMap) {
				uvScaleMap = material.roughnessMap;
			} else if (material.metalnessMap) {
				uvScaleMap = material.metalnessMap;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			} else if (material.emissiveMap) {
				uvScaleMap = material.emissiveMap;
			}

			if (uvScaleMap !== undefined) {
				// backwards compatibility
				if (uvScaleMap.isWebGLRenderTarget) {
					uvScaleMap = uvScaleMap.texture;
				}

				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			}
		}

		function refreshUniformsLine(uniforms, material) {
			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
		}

		function refreshUniformsDash(uniforms, material) {
			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;
		}

		function refreshUniformsPoints(uniforms, material) {
			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * _pixelRatio;
			uniforms.scale.value = _height * 0.5;

			uniforms.map.value = material.map;

			if (material.map !== null) {
				if (material.map.matrixAutoUpdate === true) {
					material.map.updateMatrix();
				}

				uniforms.uvTransform.value.copy(material.map.matrix);
			}
		}

		function refreshUniformsSprites(uniforms, material) {
			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;
			uniforms.map.value = material.map;

			if (material.map !== null) {
				if (material.map.matrixAutoUpdate === true) {
					material.map.updateMatrix();
				}

				uniforms.uvTransform.value.copy(material.map.matrix);
			}
		}

		function refreshUniformsFog(uniforms, fog) {
			uniforms.fogColor.value = fog.color;

			if (fog.isFog) {
				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;
			} else if (fog.isFogExp2) {
				uniforms.fogDensity.value = fog.density;
			}
		}

		function refreshUniformsLambert(uniforms, material) {
			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}
		}

		function refreshUniformsPhong(uniforms, material) {
			uniforms.specular.value = material.specular;
			uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsToon(uniforms, material) {
			refreshUniformsPhong(uniforms, material);

			if (material.gradientMap) {
				uniforms.gradientMap.value = material.gradientMap;
			}
		}

		function refreshUniformsStandard(uniforms, material) {
			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if (material.roughnessMap) {
				uniforms.roughnessMap.value = material.roughnessMap;
			}

			if (material.metalnessMap) {
				uniforms.metalnessMap.value = material.metalnessMap;
			}

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}

			if (material.envMap) {
				// uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;
			}
		}

		function refreshUniformsPhysical(uniforms, material) {
			refreshUniformsStandard(uniforms, material);

			uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

			uniforms.clearCoat.value = material.clearCoat;
			uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
		}

		function refreshUniformsMatcap(uniforms, material) {
			if (material.matcap) {
				uniforms.matcap.value = material.matcap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsDepth(uniforms, material) {
			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsDistance(uniforms, material) {
			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}

			uniforms.referencePosition.value.copy(material.referencePosition);
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;
		}

		function refreshUniformsNormal(uniforms, material) {
			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate(uniforms, value) {
			uniforms.ambientLightColor.needsUpdate = value;

			uniforms.directionalLights.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;
		}

		// Textures

		function allocTextureUnit() {
			const textureUnit = _usedTextureUnits;

			if (textureUnit >= capabilities.maxTextures) {
				console.warn(`THREE.WebGLRenderer: Trying to use ${textureUnit} texture units while this GPU supports only ${capabilities.maxTextures}`);
			}

			_usedTextureUnits += 1;

			return textureUnit;
		}

		this.allocTextureUnit = allocTextureUnit;

		// this.setTexture2D = setTexture2D;
		this.setTexture2D = (function () {
			let warned = false;

			// backwards compatibility: peel texture.texture
			return function setTexture2D(texture, slot) {
				if (texture && texture.isWebGLRenderTarget) {
					if (!warned) {
						console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");
						warned = true;
					}

					texture = texture.texture;
				}

				textures.setTexture2D(texture, slot);
			};
		}());

		this.setTexture3D = (function () {
			// backwards compatibility: peel texture.texture
			return function setTexture3D(texture, slot) {
				textures.setTexture3D(texture, slot);
			};
		}());

		this.setTexture = (function () {
			let warned = false;

			return function setTexture(texture, slot) {
				if (!warned) {
					console.warn('THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.');
					warned = true;
				}

				textures.setTexture2D(texture, slot);
			};
		}());

		this.setTextureCube = (function () {
			let warned = false;

			return function setTextureCube(texture, slot) {
				// backwards compatibility: peel texture.texture
				if (texture && texture.isWebGLRenderTargetCube) {
					if (!warned) {
						console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
						warned = true;
					}

					texture = texture.texture;
				}

				// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
				// TODO: unify these code paths
				if ((texture && texture.isCubeTexture)
					|| (Array.isArray(texture.image) && texture.image.length === 6)) {
					// CompressedTexture can have Array in image :/

					// this function alone should take care of cube textures
					textures.setTextureCube(texture, slot);
				} else {
					// assumed: texture property of THREE.WebGLRenderTargetCube

					textures.setTextureCubeDynamic(texture, slot);
				}
			};
		}());

		//

		this.setFramebuffer = function (value) {
			_framebuffer = value;
		};

		this.getRenderTarget = function () {
			return _currentRenderTarget;
		};

		this.setRenderTarget = function (renderTarget) {
			_currentRenderTarget = renderTarget;

			if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
				textures.setupRenderTarget(renderTarget);
			}

			let framebuffer = _framebuffer;
			let isCube = false;

			if (renderTarget) {
				const { __webglFramebuffer } = properties.get(renderTarget);

				if (renderTarget.isWebGLRenderTargetCube) {
					framebuffer = __webglFramebuffer[renderTarget.activeCubeFace];
					isCube = true;
				} else {
					framebuffer = __webglFramebuffer;
				}

				_currentViewport.copy(renderTarget.viewport);
				_currentScissor.copy(renderTarget.scissor);
				_currentScissorTest = renderTarget.scissorTest;
			} else {
				_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
				_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
				_currentScissorTest = _scissorTest;
			}

			if (_currentFramebuffer !== framebuffer) {
				_gl.bindFramebuffer(36160, framebuffer);
				_currentFramebuffer = framebuffer;
			}

			state.viewport(_currentViewport);
			state.scissor(_currentScissor);
			state.setScissorTest(_currentScissorTest);

			if (isCube) {
				const textureProperties = properties.get(renderTarget.texture);
				_gl.framebufferTexture2D(36160, 36064, 34069 + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel);
			}
		};

		this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer) {
			if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
				console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
				return;
			}

			const framebuffer = properties.get(renderTarget).__webglFramebuffer;

			if (framebuffer) {
				let restore = false;

				if (framebuffer !== _currentFramebuffer) {
					_gl.bindFramebuffer(36160, framebuffer);

					restore = true;
				}

				try {
					const { texture } = renderTarget;
					const textureFormat = texture.format;
					const textureType = texture.type;

					if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
						return;
					}

					if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) // IE11, Edge and Chrome Mac < 52 (#9513)
						&& !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) // Chrome Mac >= 52 and Firefox
						&& !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get('EXT_color_buffer_float') : extensions.get('EXT_color_buffer_half_float')))) {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
						return;
					}

					if (_gl.checkFramebufferStatus(36160) === 36053) {
						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

						if ((x >= 0 && x <= (renderTarget.width - width)) && (y >= 0 && y <= (renderTarget.height - height))) {
							_gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
						}
					} else {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
					}
				} finally {
					if (restore) {
						_gl.bindFramebuffer(36160, _currentFramebuffer);
					}
				}
			}
		};

		this.copyFramebufferToTexture = function (position, texture, level) {
			const { width } = texture.image;
			const { height } = texture.image;
			const glFormat = utils.convert(texture.format);

			this.setTexture2D(texture, 0);

			_gl.copyTexImage2D(3553, level || 0, glFormat, position.x, position.y, width, height, 0);
		};

		this.copyTextureToTexture = function (position, srcTexture, dstTexture, level) {
			const { width } = srcTexture.image;
			const { height } = srcTexture.image;
			const glFormat = utils.convert(dstTexture.format);
			const glType = utils.convert(dstTexture.type);

			this.setTexture2D(dstTexture, 0);

			if (srcTexture.isDataTexture) {
				_gl.texSubImage2D(3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
			} else {
				_gl.texSubImage2D(3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image);
			}
		};
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function FogExp2(color, density) {
		this.name = '';

		this.color = new Color(color);
		this.density = (density !== undefined) ? density : 0.00025;
	}

	FogExp2.prototype.isFogExp2 = true;

	FogExp2.prototype.clone = function () {
		return new FogExp2(this.color, this.density);
	};

	FogExp2.prototype.toJSON = function (/* meta */) {
		return {
			type: 'FogExp2',
			color: this.color.getHex(),
			density: this.density,
		};
	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Fog(color, near, far) {
		this.name = '';

		this.color = new Color(color);

		this.near = (near !== undefined) ? near : 1;
		this.far = (far !== undefined) ? far : 1000;
	}

	Fog.prototype.isFog = true;

	Fog.prototype.clone = function () {
		return new Fog(this.color, this.near, this.far);
	};

	Fog.prototype.toJSON = function (/* meta */) {
		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far,
		};
	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Scene() {
		Object3D.call(this);

		this.type = 'Scene';

		this.background = null;
		this.fog = null;
		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer
	}

	Scene.prototype = Object.assign(Object.create(Object3D.prototype), {

		constructor: Scene,

		copy(source, recursive) {
			Object3D.prototype.copy.call(this, source, recursive);

			if (source.background !== null) this.background = source.background.clone();
			if (source.fog !== null) this.fog = source.fog.clone();
			if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();

			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;
		},

		toJSON(meta) {
			const data = Object3D.prototype.toJSON.call(this, meta);

			if (this.background !== null) data.object.background = this.background.toJSON(meta);
			if (this.fog !== null) data.object.fog = this.fog.toJSON();

			return data;
		},

	});

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InterleavedBuffer(array, stride) {
		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: -1 };

		this.version = 0;
	}

	Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {

		set(value) {
			if (value === true) this.version++;
		},

	});

	Object.assign(InterleavedBuffer.prototype, {

		isInterleavedBuffer: true,

		onUploadCallback() {},

		setArray(array) {
			if (Array.isArray(array)) {
				throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
			}

			this.count = array !== undefined ? array.length / this.stride : 0;
			this.array = array;

			return this;
		},

		setDynamic(value) {
			this.dynamic = value;

			return this;
		},

		copy(source) {
			this.array = new source.array.constructor(source.array);
			this.count = source.count;
			this.stride = source.stride;
			this.dynamic = source.dynamic;

			return this;
		},

		copyAt(index1, attribute, index2) {
			index1 *= this.stride;
			index2 *= attribute.stride;

			for (let i = 0, l = this.stride; i < l; i++) {
				this.array[index1 + i] = attribute.array[index2 + i];
			}

			return this;
		},

		set(value, offset) {
			if (offset === undefined) offset = 0;

			this.array.set(value, offset);

			return this;
		},

		clone() {
			return new this.constructor().copy(this);
		},

		onUpload(callback) {
			this.onUploadCallback = callback;

			return this;
		},

	});

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized === true;
	}

	Object.defineProperties(InterleavedBufferAttribute.prototype, {

		count: {

			get() {
				return this.data.count;
			},

		},

		array: {

			get() {
				return this.data.array;
			},

		},

	});

	Object.assign(InterleavedBufferAttribute.prototype, {

		isInterleavedBufferAttribute: true,

		setX(index, x) {
			this.data.array[index * this.data.stride + this.offset] = x;

			return this;
		},

		setY(index, y) {
			this.data.array[index * this.data.stride + this.offset + 1] = y;

			return this;
		},

		setZ(index, z) {
			this.data.array[index * this.data.stride + this.offset + 2] = z;

			return this;
		},

		setW(index, w) {
			this.data.array[index * this.data.stride + this.offset + 3] = w;

			return this;
		},

		getX(index) {
			return this.data.array[index * this.data.stride + this.offset];
		},

		getY(index) {
			return this.data.array[index * this.data.stride + this.offset + 1];
		},

		getZ(index) {
			return this.data.array[index * this.data.stride + this.offset + 2];
		},

		getW(index) {
			return this.data.array[index * this.data.stride + this.offset + 3];
		},

		setXY(index, x, y) {
			index = index * this.data.stride + this.offset;

			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;

			return this;
		},

		setXYZ(index, x, y, z) {
			index = index * this.data.stride + this.offset;

			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			this.data.array[index + 2] = z;

			return this;
		},

		setXYZW(index, x, y, z, w) {
			index = index * this.data.stride + this.offset;

			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			this.data.array[index + 2] = z;
			this.data.array[index + 3] = w;

			return this;
		},

	});

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  map: new THREE.Texture( <Image> ),
	 *  rotation: <float>,
	 *  sizeAttenuation: <bool>
	 * }
	 */

	function SpriteMaterial(parameters) {
		Material.call(this);

		this.type = 'SpriteMaterial';

		this.color = new Color(0xffffff);
		this.map = null;

		this.rotation = 0;

		this.sizeAttenuation = true;

		this.lights = false;
		this.transparent = true;

		this.setValues(parameters);
	}

	SpriteMaterial.prototype = Object.create(Material.prototype);
	SpriteMaterial.prototype.constructor = SpriteMaterial;
	SpriteMaterial.prototype.isSpriteMaterial = true;

	SpriteMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);

		this.color.copy(source.color);
		this.map = source.map;

		this.rotation = source.rotation;

		this.sizeAttenuation = source.sizeAttenuation;

		return this;
	};

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	let geometry;

	function Sprite(material) {
		Object3D.call(this);

		this.type = 'Sprite';

		if (geometry === undefined) {
			geometry = new BufferGeometry();

			const float32Array = new Float32Array([
				-0.5, -0.5, 0, 0, 0,
				0.5, -0.5, 0, 1, 0,
				0.5, 0.5, 0, 1, 1,
				-0.5, 0.5, 0, 0, 1,
			]);

			const interleavedBuffer = new InterleavedBuffer(float32Array, 5);

			geometry.setIndex([0, 1, 2,	0, 2, 3]);
			geometry.addAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
			geometry.addAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
		}

		this.geometry = geometry;
		this.material = (material !== undefined) ? material : new SpriteMaterial();

		this.center = new Vector2(0.5, 0.5);
	}

	Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {

		constructor: Sprite,

		isSprite: true,

		raycast: (function () {
			const intersectPoint = new Vector3();
			const worldScale = new Vector3();
			const mvPosition = new Vector3();

			const alignedPosition = new Vector2();
			const rotatedPosition = new Vector2();
			const viewWorldMatrix = new Matrix4();

			const vA = new Vector3();
			const vB = new Vector3();
			const vC = new Vector3();

			const uvA = new Vector2();
			const uvB = new Vector2();
			const uvC = new Vector2();

			function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
				// compute position in camera space
				alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);

				// to check if rotation is not zero
				if (sin !== undefined) {
					rotatedPosition.x = (cos * alignedPosition.x) - (sin * alignedPosition.y);
					rotatedPosition.y = (sin * alignedPosition.x) + (cos * alignedPosition.y);
				} else {
					rotatedPosition.copy(alignedPosition);
				}


				vertexPosition.copy(mvPosition);
				vertexPosition.x += rotatedPosition.x;
				vertexPosition.y += rotatedPosition.y;

				// transform to world space
				vertexPosition.applyMatrix4(viewWorldMatrix);
			}

			return function raycast(raycaster, intersects) {
				worldScale.setFromMatrixScale(this.matrixWorld);
				viewWorldMatrix.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld);
				mvPosition.setFromMatrixPosition(this.modelViewMatrix);

				const { rotation } = this.material;
				let sin; let
					cos;
				if (rotation !== 0) {
					cos = Math.cos(rotation);
					sin = Math.sin(rotation);
				}

				const { center } = this;

				transformVertex(vA.set(-0.5, -0.5, 0), mvPosition, center, worldScale, sin, cos);
				transformVertex(vB.set(0.5, -0.5, 0), mvPosition, center, worldScale, sin, cos);
				transformVertex(vC.set(0.5, 0.5, 0), mvPosition, center, worldScale, sin, cos);

				uvA.set(0, 0);
				uvB.set(1, 0);
				uvC.set(1, 1);

				// check first triangle
				let intersect = raycaster.ray.intersectTriangle(vA, vB, vC, false, intersectPoint);

				if (intersect === null) {
					// check second triangle
					transformVertex(vB.set(-0.5, 0.5, 0), mvPosition, center, worldScale, sin, cos);
					uvB.set(0, 1);

					intersect = raycaster.ray.intersectTriangle(vA, vC, vB, false, intersectPoint);
					if (intersect === null) {
						return;
					}
				}

				const distance = raycaster.ray.origin.distanceTo(intersectPoint);

				if (distance < raycaster.near || distance > raycaster.far) return;

				intersects.push({

					distance,
					point: intersectPoint.clone(),
					uv: Triangle.getUV(intersectPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2()),
					face: null,
					object: this,

				});
			};
		}()),

		clone() {
			return new this.constructor(this.material).copy(this);
		},

		copy(source) {
			Object3D.prototype.copy.call(this, source);

			if (source.center !== undefined) this.center.copy(source.center);

			return this;
		},


	});

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LOD() {
		Object3D.call(this);

		this.type = 'LOD';

		Object.defineProperties(this, {
			levels: {
				enumerable: true,
				value: [],
			},
		});
	}

	LOD.prototype = Object.assign(Object.create(Object3D.prototype), {

		constructor: LOD,

		copy(source) {
			Object3D.prototype.copy.call(this, source, false);

			const { levels } = source;

			for (let i = 0, l = levels.length; i < l; i++) {
				const level = levels[i];

				this.addLevel(level.object.clone(), level.distance);
			}

			return this;
		},

		addLevel(object, distance) {
			if (distance === undefined) distance = 0;

			distance = Math.abs(distance);

			const { levels } = this;

			for (var l = 0; l < levels.length; l++) {
				if (distance < levels[l].distance) {
					break;
				}
			}

			levels.splice(l, 0, { distance, object });

			this.add(object);
		},

		getObjectForDistance(distance) {
			const { levels } = this;

			for (var i = 1, l = levels.length; i < l; i++) {
				if (distance < levels[i].distance) {
					break;
				}
			}

			return levels[i - 1].object;
		},

		raycast: (function () {
			const matrixPosition = new Vector3();

			return function raycast(raycaster, intersects) {
				matrixPosition.setFromMatrixPosition(this.matrixWorld);

				const distance = raycaster.ray.origin.distanceTo(matrixPosition);

				this.getObjectForDistance(distance).raycast(raycaster, intersects);
			};
		}()),

		update: (function () {
			const v1 = new Vector3();
			const v2 = new Vector3();

			return function update(camera) {
				const { levels } = this;

				if (levels.length > 1) {
					v1.setFromMatrixPosition(camera.matrixWorld);
					v2.setFromMatrixPosition(this.matrixWorld);

					const distance = v1.distanceTo(v2);

					levels[0].object.visible = true;

					for (var i = 1, l = levels.length; i < l; i++) {
						if (distance >= levels[i].distance) {
							levels[i - 1].object.visible = false;
							levels[i].object.visible = true;
						} else {
							break;
						}
					}

					for (; i < l; i++) {
						levels[i].object.visible = false;
					}
				}
			};
		}()),

		toJSON(meta) {
			const data = Object3D.prototype.toJSON.call(this, meta);

			data.object.levels = [];

			const { levels } = this;

			for (let i = 0, l = levels.length; i < l; i++) {
				const level = levels[i];

				data.object.levels.push({
					object: level.object.uuid,
					distance: level.distance,
				});
			}

			return data;
		},

	});

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	function SkinnedMesh(geometry, material) {
		if (geometry && geometry.isGeometry) {
			console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
		}

		Mesh.call(this, geometry, material);

		this.type = 'SkinnedMesh';

		this.bindMode = 'attached';
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();
	}

	SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {

		constructor: SkinnedMesh,

		isSkinnedMesh: true,

		bind(skeleton, bindMatrix) {
			this.skeleton = skeleton;

			if (bindMatrix === undefined) {
				this.updateMatrixWorld(true);

				this.skeleton.calculateInverses();

				bindMatrix = this.matrixWorld;
			}

			this.bindMatrix.copy(bindMatrix);
			this.bindMatrixInverse.getInverse(bindMatrix);
		},

		pose() {
			this.skeleton.pose();
		},

		normalizeSkinWeights() {
			const vector = new Vector4();

			const { skinWeight } = this.geometry.attributes;

			for (let i = 0, l = skinWeight.count; i < l; i++) {
				vector.x = skinWeight.getX(i);
				vector.y = skinWeight.getY(i);
				vector.z = skinWeight.getZ(i);
				vector.w = skinWeight.getW(i);

				const scale = 1.0 / vector.manhattanLength();

				if (scale !== Infinity) {
					vector.multiplyScalar(scale);
				} else {
					vector.set(1, 0, 0, 0); // do something reasonable
				}

				skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
			}
		},

		updateMatrixWorld(force) {
			Mesh.prototype.updateMatrixWorld.call(this, force);

			if (this.bindMode === 'attached') {
				this.bindMatrixInverse.getInverse(this.matrixWorld);
			} else if (this.bindMode === 'detached') {
				this.bindMatrixInverse.getInverse(this.bindMatrix);
			} else {
				console.warn(`THREE.SkinnedMesh: Unrecognized bindMode: ${this.bindMode}`);
			}
		},

		clone() {
			return new this.constructor(this.geometry, this.material).copy(this);
		},

	});

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */

	function Skeleton(bones, boneInverses) {
		// copy the bone array

		bones = bones || [];

		this.bones = bones.slice(0);
		this.boneMatrices = new Float32Array(this.bones.length * 16);

		// use the supplied bone inverses or calculate the inverses

		if (boneInverses === undefined) {
			this.calculateInverses();
		} else if (this.bones.length === boneInverses.length) {
			this.boneInverses = boneInverses.slice(0);
		} else {
			console.warn('THREE.Skeleton boneInverses is the wrong length.');

			this.boneInverses = [];

			for (let i = 0, il = this.bones.length; i < il; i++) {
				this.boneInverses.push(new Matrix4());
			}
		}
	}

	Object.assign(Skeleton.prototype, {

		calculateInverses() {
			this.boneInverses = [];

			for (let i = 0, il = this.bones.length; i < il; i++) {
				const inverse = new Matrix4();

				if (this.bones[i]) {
					inverse.getInverse(this.bones[i].matrixWorld);
				}

				this.boneInverses.push(inverse);
			}
		},

		pose() {
			let bone; let i; let
				il;

			// recover the bind-time world matrices

			for (i = 0, il = this.bones.length; i < il; i++) {
				bone = this.bones[i];

				if (bone) {
					bone.matrixWorld.getInverse(this.boneInverses[i]);
				}
			}

			// compute the local matrices, positions, rotations and scales

			for (i = 0, il = this.bones.length; i < il; i++) {
				bone = this.bones[i];

				if (bone) {
					if (bone.parent && bone.parent.isBone) {
						bone.matrix.getInverse(bone.parent.matrixWorld);
						bone.matrix.multiply(bone.matrixWorld);
					} else {
						bone.matrix.copy(bone.matrixWorld);
					}

					bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
				}
			}
		},

		update: (function () {
			const offsetMatrix = new Matrix4();
			const identityMatrix = new Matrix4();

			return function update() {
				const { bones } = this;
				const { boneInverses } = this;
				const { boneMatrices } = this;
				const { boneTexture } = this;

				// flatten bone matrices to array

				for (let i = 0, il = bones.length; i < il; i++) {
					// compute the offset between the current and the original transform

					const matrix = bones[i] ? bones[i].matrixWorld : identityMatrix;

					offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
					offsetMatrix.toArray(boneMatrices, i * 16);
				}

				if (boneTexture !== undefined) {
					boneTexture.needsUpdate = true;
				}
			};
		}()),

		clone() {
			return new Skeleton(this.bones, this.boneInverses);
		},

		getBoneByName(name) {
			for (let i = 0, il = this.bones.length; i < il; i++) {
				const bone = this.bones[i];

				if (bone.name === name) {
					return bone;
				}
			}

			return undefined;
		},

	});

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	function Bone() {
		Object3D.call(this);

		this.type = 'Bone';
	}

	Bone.prototype = Object.assign(Object.create(Object3D.prototype), {

		constructor: Bone,

		isBone: true,

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round"
	 * }
	 */

	function LineBasicMaterial(parameters) {
		Material.call(this);

		this.type = 'LineBasicMaterial';

		this.color = new Color(0xffffff);

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.lights = false;

		this.setValues(parameters);
	}

	LineBasicMaterial.prototype = Object.create(Material.prototype);
	LineBasicMaterial.prototype.constructor = LineBasicMaterial;

	LineBasicMaterial.prototype.isLineBasicMaterial = true;

	LineBasicMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);

		this.color.copy(source.color);

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		return this;
	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Line(geometry, material, mode) {
		if (mode === 1) {
			console.error('THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.');
		}

		Object3D.call(this);

		this.type = 'Line';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new LineBasicMaterial({ color: Math.random() * 0xffffff });
	}

	Line.prototype = Object.assign(Object.create(Object3D.prototype), {

		constructor: Line,

		isLine: true,

		computeLineDistances: (function () {
			const start = new Vector3();
			const end = new Vector3();

			return function computeLineDistances() {
				const { geometry } = this;

				if (geometry.isBufferGeometry) {
					// we assume non-indexed geometry

					if (geometry.index === null) {
						const positionAttribute = geometry.attributes.position;
						var lineDistances = [0];

						for (var i = 1, l = positionAttribute.count; i < l; i++) {
							start.fromBufferAttribute(positionAttribute, i - 1);
							end.fromBufferAttribute(positionAttribute, i);

							lineDistances[i] = lineDistances[i - 1];
							lineDistances[i] += start.distanceTo(end);
						}

						geometry.addAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
					} else {
						console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
					}
				} else if (geometry.isGeometry) {
					const { vertices } = geometry;
					var { lineDistances } = geometry;

					lineDistances[0] = 0;

					for (var i = 1, l = vertices.length; i < l; i++) {
						lineDistances[i] = lineDistances[i - 1];
						lineDistances[i] += vertices[i - 1].distanceTo(vertices[i]);
					}
				}

				return this;
			};
		}()),

		raycast: (function () {
			const inverseMatrix = new Matrix4();
			const ray = new Ray();
			const sphere = new Sphere();

			return function raycast(raycaster, intersects) {
				const precision = raycaster.linePrecision;

				const { geometry } = this;
				const { matrixWorld } = this;

				// Checking boundingSphere distance to ray

				if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

				sphere.copy(geometry.boundingSphere);
				sphere.applyMatrix4(matrixWorld);
				sphere.radius += precision;

				if (raycaster.ray.intersectsSphere(sphere) === false) return;

				//

				inverseMatrix.getInverse(matrixWorld);
				ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

				const localPrecision = precision / ((this.scale.x + this.scale.y + this.scale.z) / 3);
				const localPrecisionSq = localPrecision * localPrecision;

				const vStart = new Vector3();
				const vEnd = new Vector3();
				const interSegment = new Vector3();
				const interRay = new Vector3();
				const step = (this && this.isLineSegments) ? 2 : 1;

				if (geometry.isBufferGeometry) {
					const { index } = geometry;
					const { attributes } = geometry;
					const positions = attributes.position.array;

					if (index !== null) {
						const indices = index.array;

						for (var i = 0, l = indices.length - 1; i < l; i += step) {
							const a = indices[i];
							const b = indices[i + 1];

							vStart.fromArray(positions, a * 3);
							vEnd.fromArray(positions, b * 3);

							var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

							if (distSq > localPrecisionSq) continue;

							interRay.applyMatrix4(this.matrixWorld); // Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo(interRay);

							if (distance < raycaster.near || distance > raycaster.far) continue;

							intersects.push({

								distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4(this.matrixWorld),
								index: i,
								face: null,
								faceIndex: null,
								object: this,

							});
						}
					} else {
						for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
							vStart.fromArray(positions, 3 * i);
							vEnd.fromArray(positions, 3 * i + 3);

							var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

							if (distSq > localPrecisionSq) continue;

							interRay.applyMatrix4(this.matrixWorld); // Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo(interRay);

							if (distance < raycaster.near || distance > raycaster.far) continue;

							intersects.push({

								distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4(this.matrixWorld),
								index: i,
								face: null,
								faceIndex: null,
								object: this,

							});
						}
					}
				} else if (geometry.isGeometry) {
					const { vertices } = geometry;
					const nbVertices = vertices.length;

					for (var i = 0; i < nbVertices - 1; i += step) {
						var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);

						if (distSq > localPrecisionSq) continue;

						interRay.applyMatrix4(this.matrixWorld); // Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo(interRay);

						if (distance < raycaster.near || distance > raycaster.far) continue;

						intersects.push({

							distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4(this.matrixWorld),
							index: i,
							face: null,
							faceIndex: null,
							object: this,

						});
					}
				}
			};
		}()),

		copy(source) {
			Object3D.prototype.copy.call(this, source);

			this.geometry.copy(source.geometry);
			this.material.copy(source.material);

			return this;
		},

		clone() {
			return new this.constructor().copy(this);
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LineSegments(geometry, material) {
		Line.call(this, geometry, material);

		this.type = 'LineSegments';
	}

	LineSegments.prototype = Object.assign(Object.create(Line.prototype), {

		constructor: LineSegments,

		isLineSegments: true,

		computeLineDistances: (function () {
			const start = new Vector3();
			const end = new Vector3();

			return function computeLineDistances() {
				const { geometry } = this;

				if (geometry.isBufferGeometry) {
					// we assume non-indexed geometry

					if (geometry.index === null) {
						const positionAttribute = geometry.attributes.position;
						var lineDistances = [];

						for (var i = 0, l = positionAttribute.count; i < l; i += 2) {
							start.fromBufferAttribute(positionAttribute, i);
							end.fromBufferAttribute(positionAttribute, i + 1);

							lineDistances[i] = (i === 0) ? 0 : lineDistances[i - 1];
							lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end);
						}

						geometry.addAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
					} else {
						console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
					}
				} else if (geometry.isGeometry) {
					const { vertices } = geometry;
					var { lineDistances } = geometry;

					for (var i = 0, l = vertices.length; i < l; i += 2) {
						start.copy(vertices[i]);
						end.copy(vertices[i + 1]);

						lineDistances[i] = (i === 0) ? 0 : lineDistances[i - 1];
						lineDistances[i + 1] = lineDistances[i] + start.distanceTo(end);
					}
				}

				return this;
			};
		}()),

	});

	/**
	 * @author mgreter / http://github.com/mgreter
	 */

	function LineLoop(geometry, material) {
		Line.call(this, geometry, material);

		this.type = 'LineLoop';
	}

	LineLoop.prototype = Object.assign(Object.create(Line.prototype), {

		constructor: LineLoop,

		isLineLoop: true,

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>
	 *
	 *  morphTargets: <bool>
	 * }
	 */

	function PointsMaterial(parameters) {
		Material.call(this);

		this.type = 'PointsMaterial';

		this.color = new Color(0xffffff);

		this.map = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.morphTargets = false;

		this.lights = false;

		this.setValues(parameters);
	}

	PointsMaterial.prototype = Object.create(Material.prototype);
	PointsMaterial.prototype.constructor = PointsMaterial;

	PointsMaterial.prototype.isPointsMaterial = true;

	PointsMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);

		this.color.copy(source.color);

		this.map = source.map;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.morphTargets = source.morphTargets;

		return this;
	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Points(geometry, material) {
		Object3D.call(this);

		this.type = 'Points';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new PointsMaterial({ color: Math.random() * 0xffffff });
	}

	Points.prototype = Object.assign(Object.create(Object3D.prototype), {

		constructor: Points,

		isPoints: true,

		raycast: (function () {
			const inverseMatrix = new Matrix4();
			const ray = new Ray();
			const sphere = new Sphere();

			return function raycast(raycaster, intersects) {
				const object = this;
				const { geometry } = this;
				const { matrixWorld } = this;
				const { threshold } = raycaster.params.Points;

				// Checking boundingSphere distance to ray

				if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

				sphere.copy(geometry.boundingSphere);
				sphere.applyMatrix4(matrixWorld);
				sphere.radius += threshold;

				if (raycaster.ray.intersectsSphere(sphere) === false) return;

				//

				inverseMatrix.getInverse(matrixWorld);
				ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);

				const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
				const localThresholdSq = localThreshold * localThreshold;
				const position = new Vector3();
				const intersectPoint = new Vector3();

				function testPoint(point, index) {
					const rayPointDistanceSq = ray.distanceSqToPoint(point);

					if (rayPointDistanceSq < localThresholdSq) {
						ray.closestPointToPoint(point, intersectPoint);
						intersectPoint.applyMatrix4(matrixWorld);

						const distance = raycaster.ray.origin.distanceTo(intersectPoint);

						if (distance < raycaster.near || distance > raycaster.far) return;

						intersects.push({

							distance,
							distanceToRay: Math.sqrt(rayPointDistanceSq),
							point: intersectPoint.clone(),
							index,
							face: null,
							object,

						});
					}
				}

				if (geometry.isBufferGeometry) {
					const { index } = geometry;
					const { attributes } = geometry;
					const positions = attributes.position.array;

					if (index !== null) {
						const indices = index.array;

						for (var i = 0, il = indices.length; i < il; i++) {
							const a = indices[i];

							position.fromArray(positions, a * 3);

							testPoint(position, a);
						}
					} else {
						for (var i = 0, l = positions.length / 3; i < l; i++) {
							position.fromArray(positions, i * 3);

							testPoint(position, i);
						}
					}
				} else {
					const { vertices } = geometry;

					for (var i = 0, l = vertices.length; i < l; i++) {
						testPoint(vertices[i], i);
					}
				}
			};
		}()),

		clone() {
			return new this.constructor(this.geometry, this.material).copy(this);
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
		Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);

		this.format = format !== undefined ? format : RGBFormat;

		this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

		this.generateMipmaps = false;
	}

	VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {

		constructor: VideoTexture,

		isVideoTexture: true,

		update() {
			const video = this.image;

			if (video) {
				if (video.readyState >= video.HAVE_CURRENT_DATA) {
					this.needsUpdate = true;
				}
			}
		},

	});

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
		Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

		this.image = { width, height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;
	}

	CompressedTexture.prototype = Object.create(Texture.prototype);
	CompressedTexture.prototype.constructor = CompressedTexture;

	CompressedTexture.prototype.isCompressedTexture = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
		Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);

		this.needsUpdate = true;
	}

	CanvasTexture.prototype = Object.create(Texture.prototype);
	CanvasTexture.prototype.constructor = CanvasTexture;
	CanvasTexture.prototype.isCanvasTexture = true;

	/**
	 * @author Matt DesLauriers / @mattdesl
	 * @author atix / arthursilber.de
	 */

	function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
		format = format !== undefined ? format : DepthFormat;

		if (format !== DepthFormat && format !== DepthStencilFormat) {
			throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
		}

		if (type === undefined && format === DepthFormat) type = UnsignedShortType;
		if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;

		Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);

		this.image = { width, height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.flipY = false;
		this.generateMipmaps	= false;
	}

	DepthTexture.prototype = Object.create(Texture.prototype);
	DepthTexture.prototype.constructor = DepthTexture;
	DepthTexture.prototype.isDepthTexture = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WireframeGeometry(geometry) {
		BufferGeometry.call(this);

		this.type = 'WireframeGeometry';

		// buffer

		const vertices = [];

		// helper variables

		let i; let j; let l; let o; let
			ol;
		const edge = [0, 0]; const edges = {}; let e; let edge1; let
			edge2;
		let key; const
			keys = ['a', 'b', 'c'];
		let vertex;

		// different logic for Geometry and BufferGeometry

		if (geometry && geometry.isGeometry) {
			// create a data structure that contains all edges without duplicates

			const { faces } = geometry;

			for (i = 0, l = faces.length; i < l; i++) {
				const face = faces[i];

				for (j = 0; j < 3; j++) {
					edge1 = face[keys[j]];
					edge2 = face[keys[(j + 1) % 3]];
					edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates
					edge[1] = Math.max(edge1, edge2);

					key = `${edge[0]},${edge[1]}`;

					if (edges[key] === undefined) {
						edges[key] = { index1: edge[0], index2: edge[1] };
					}
				}
			}

			// generate vertices

			for (key in edges) {
				e = edges[key];

				vertex = geometry.vertices[e.index1];
				vertices.push(vertex.x, vertex.y, vertex.z);

				vertex = geometry.vertices[e.index2];
				vertices.push(vertex.x, vertex.y, vertex.z);
			}
		} else if (geometry && geometry.isBufferGeometry) {
			let position; let indices; let
				groups;
			let group; let start; let
				count;
			let index1; let
				index2;

			vertex = new Vector3();

			if (geometry.index !== null) {
				// indexed BufferGeometry

				position = geometry.attributes.position;
				indices = geometry.index;
				groups = geometry.groups;

				if (groups.length === 0) {
					groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
				}

				// create a data structure that contains all eges without duplicates

				for (o = 0, ol = groups.length; o < ol; ++o) {
					group = groups[o];

					start = group.start;
					count = group.count;

					for (i = start, l = (start + count); i < l; i += 3) {
						for (j = 0; j < 3; j++) {
							edge1 = indices.getX(i + j);
							edge2 = indices.getX(i + (j + 1) % 3);
							edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates
							edge[1] = Math.max(edge1, edge2);

							key = `${edge[0]},${edge[1]}`;

							if (edges[key] === undefined) {
								edges[key] = { index1: edge[0], index2: edge[1] };
							}
						}
					}
				}

				// generate vertices

				for (key in edges) {
					e = edges[key];

					vertex.fromBufferAttribute(position, e.index1);
					vertices.push(vertex.x, vertex.y, vertex.z);

					vertex.fromBufferAttribute(position, e.index2);
					vertices.push(vertex.x, vertex.y, vertex.z);
				}
			} else {
				// non-indexed BufferGeometry

				position = geometry.attributes.position;

				for (i = 0, l = (position.count / 3); i < l; i++) {
					for (j = 0; j < 3; j++) {
						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						index1 = 3 * i + j;
						vertex.fromBufferAttribute(position, index1);
						vertices.push(vertex.x, vertex.y, vertex.z);

						index2 = 3 * i + ((j + 1) % 3);
						vertex.fromBufferAttribute(position, index2);
						vertices.push(vertex.x, vertex.y, vertex.z);
					}
				}
			}
		}

		// build geometry

		this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
	}

	WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
	WireframeGeometry.prototype.constructor = WireframeGeometry;

	/**
	 * @author zz85 / https://github.com/zz85
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 */

	// ParametricGeometry

	function ParametricGeometry(func, slices, stacks) {
		Geometry.call(this);

		this.type = 'ParametricGeometry';

		this.parameters = {
			func,
			slices,
			stacks,
		};

		this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
		this.mergeVertices();
	}

	ParametricGeometry.prototype = Object.create(Geometry.prototype);
	ParametricGeometry.prototype.constructor = ParametricGeometry;

	// ParametricBufferGeometry

	function ParametricBufferGeometry(func, slices, stacks) {
		BufferGeometry.call(this);

		this.type = 'ParametricBufferGeometry';

		this.parameters = {
			func,
			slices,
			stacks,
		};

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		const EPS = 0.00001;

		const normal = new Vector3();

		const p0 = new Vector3(); const
			p1 = new Vector3();
		const pu = new Vector3(); const
			pv = new Vector3();

		let i; let
			j;

		if (func.length < 3) {
			console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
		}

		// generate vertices, normals and uvs

		const sliceCount = slices + 1;

		for (i = 0; i <= stacks; i++) {
			const v = i / stacks;

			for (j = 0; j <= slices; j++) {
				const u = j / slices;

				// vertex

				func(u, v, p0);
				vertices.push(p0.x, p0.y, p0.z);

				// normal

				// approximate tangent vectors via finite differences

				if (u - EPS >= 0) {
					func(u - EPS, v, p1);
					pu.subVectors(p0, p1);
				} else {
					func(u + EPS, v, p1);
					pu.subVectors(p1, p0);
				}

				if (v - EPS >= 0) {
					func(u, v - EPS, p1);
					pv.subVectors(p0, p1);
				} else {
					func(u, v + EPS, p1);
					pv.subVectors(p1, p0);
				}

				// cross product of tangent vectors returns surface normal

				normal.crossVectors(pu, pv).normalize();
				normals.push(normal.x, normal.y, normal.z);

				// uv

				uvs.push(u, v);
			}
		}

		// generate indices

		for (i = 0; i < stacks; i++) {
			for (j = 0; j < slices; j++) {
				const a = i * sliceCount + j;
				const b = i * sliceCount + j + 1;
				const c = (i + 1) * sliceCount + j + 1;
				const d = (i + 1) * sliceCount + j;

				// faces one and two

				indices.push(a, b, d);
				indices.push(b, c, d);
			}
		}

		// build geometry

		this.setIndex(indices);
		this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
	}

	ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// PolyhedronGeometry

	function PolyhedronGeometry(vertices, indices, radius, detail) {
		Geometry.call(this);

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices,
			indices,
			radius,
			detail,
		};

		this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
		this.mergeVertices();
	}

	PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
	PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

	// PolyhedronBufferGeometry

	function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
		BufferGeometry.call(this);

		this.type = 'PolyhedronBufferGeometry';

		this.parameters = {
			vertices,
			indices,
			radius,
			detail,
		};

		radius = radius || 1;
		detail = detail || 0;

		// default buffer data

		const vertexBuffer = [];
		const uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide(detail);

		// all vertices should lie on a conceptual sphere with a given radius

		appplyRadius(radius);

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.addAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
		this.addAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
		this.addAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));

		if (detail === 0) {
			this.computeVertexNormals(); // flat normals
		} else {
			this.normalizeNormals(); // smooth normals
		}

		// helper functions

		function subdivide(detail) {
			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			// iterate over all faces and apply a subdivison with the given detail value

			for (let i = 0; i < indices.length; i += 3) {
				// get the vertices of the face

				getVertexByIndex(indices[i + 0], a);
				getVertexByIndex(indices[i + 1], b);
				getVertexByIndex(indices[i + 2], c);

				// perform subdivision

				subdivideFace(a, b, c, detail);
			}
		}

		function subdivideFace(a, b, c, detail) {
			const cols = Math.pow(2, detail);

			// we use this multidimensional array as a data structure for creating the subdivision

			const v = [];

			let i; let
				j;

			// construct all of the vertices for this subdivision

			for (i = 0; i <= cols; i++) {
				v[i] = [];

				const aj = a.clone().lerp(c, i / cols);
				const bj = b.clone().lerp(c, i / cols);

				const rows = cols - i;

				for (j = 0; j <= rows; j++) {
					if (j === 0 && i === cols) {
						v[i][j] = aj;
					} else {
						v[i][j] = aj.clone().lerp(bj, j / rows);
					}
				}
			}

			// construct all of the faces

			for (i = 0; i < cols; i++) {
				for (j = 0; j < 2 * (cols - i) - 1; j++) {
					const k = Math.floor(j / 2);

					if (j % 2 === 0) {
						pushVertex(v[i][k + 1]);
						pushVertex(v[i + 1][k]);
						pushVertex(v[i][k]);
					} else {
						pushVertex(v[i][k + 1]);
						pushVertex(v[i + 1][k + 1]);
						pushVertex(v[i + 1][k]);
					}
				}
			}
		}

		function appplyRadius(radius) {
			const vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for (let i = 0; i < vertexBuffer.length; i += 3) {
				vertex.x = vertexBuffer[i + 0];
				vertex.y = vertexBuffer[i + 1];
				vertex.z = vertexBuffer[i + 2];

				vertex.normalize().multiplyScalar(radius);

				vertexBuffer[i + 0] = vertex.x;
				vertexBuffer[i + 1] = vertex.y;
				vertexBuffer[i + 2] = vertex.z;
			}
		}

		function generateUVs() {
			const vertex = new Vector3();

			for (let i = 0; i < vertexBuffer.length; i += 3) {
				vertex.x = vertexBuffer[i + 0];
				vertex.y = vertexBuffer[i + 1];
				vertex.z = vertexBuffer[i + 2];

				const u = azimuth(vertex) / 2 / Math.PI + 0.5;
				const v = inclination(vertex) / Math.PI + 0.5;
				uvBuffer.push(u, 1 - v);
			}

			correctUVs();

			correctSeam();
		}

		function correctSeam() {
			// handle case when face straddles the seam, see #3269

			for (let i = 0; i < uvBuffer.length; i += 6) {
				// uv data of a single face

				const x0 = uvBuffer[i + 0];
				const x1 = uvBuffer[i + 2];
				const x2 = uvBuffer[i + 4];

				const max = Math.max(x0, x1, x2);
				const min = Math.min(x0, x1, x2);

				// 0.9 is somewhat arbitrary

				if (max > 0.9 && min < 0.1) {
					if (x0 < 0.2) uvBuffer[i + 0] += 1;
					if (x1 < 0.2) uvBuffer[i + 2] += 1;
					if (x2 < 0.2) uvBuffer[i + 4] += 1;
				}
			}
		}

		function pushVertex(vertex) {
			vertexBuffer.push(vertex.x, vertex.y, vertex.z);
		}

		function getVertexByIndex(index, vertex) {
			const stride = index * 3;

			vertex.x = vertices[stride + 0];
			vertex.y = vertices[stride + 1];
			vertex.z = vertices[stride + 2];
		}

		function correctUVs() {
			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			const centroid = new Vector3();

			const uvA = new Vector2();
			const uvB = new Vector2();
			const uvC = new Vector2();

			for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
				a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
				b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
				c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);

				uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
				uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
				uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);

				centroid.copy(a).add(b).add(c).divideScalar(3);

				const azi = azimuth(centroid);

				correctUV(uvA, j + 0, a, azi);
				correctUV(uvB, j + 2, b, azi);
				correctUV(uvC, j + 4, c, azi);
			}
		}

		function correctUV(uv, stride, vector, azimuth) {
			if ((azimuth < 0) && (uv.x === 1)) {
				uvBuffer[stride] = uv.x - 1;
			}

			if ((vector.x === 0) && (vector.z === 0)) {
				uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
			}
		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth(vector) {
			return Math.atan2(vector.z, -vector.x);
		}


		// Angle above the XZ plane.

		function inclination(vector) {
			return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
		}
	}

	PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// TetrahedronGeometry

	function TetrahedronGeometry(radius, detail) {
		Geometry.call(this);

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius,
			detail,
		};

		this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
		this.mergeVertices();
	}

	TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
	TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

	// TetrahedronBufferGeometry

	function TetrahedronBufferGeometry(radius, detail) {
		const vertices = [
			1, 1, 1, 	-1, -1, 1, 	-1, 1, -1, 	1, -1, -1,
		];

		const indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1,
		];

		PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);

		this.type = 'TetrahedronBufferGeometry';

		this.parameters = {
			radius,
			detail,
		};
	}

	TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
	TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// OctahedronGeometry

	function OctahedronGeometry(radius, detail) {
		Geometry.call(this);

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius,
			detail,
		};

		this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
		this.mergeVertices();
	}

	OctahedronGeometry.prototype = Object.create(Geometry.prototype);
	OctahedronGeometry.prototype.constructor = OctahedronGeometry;

	// OctahedronBufferGeometry

	function OctahedronBufferGeometry(radius, detail) {
		const vertices = [
			1, 0, 0, 	-1, 0, 0,	0, 1, 0,
			0, -1, 0, 	0, 0, 1,	0, 0, -1,
		];

		const indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2,
		];

		PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);

		this.type = 'OctahedronBufferGeometry';

		this.parameters = {
			radius,
			detail,
		};
	}

	OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
	OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// IcosahedronGeometry

	function IcosahedronGeometry(radius, detail) {
		Geometry.call(this);

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius,
			detail,
		};

		this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
		this.mergeVertices();
	}

	IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
	IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

	// IcosahedronBufferGeometry

	function IcosahedronBufferGeometry(radius, detail) {
		const t = (1 + Math.sqrt(5)) / 2;

		const vertices = [
			-1, t, 0, 	1, t, 0, 	-1, -t, 0, 	1, -t, 0,
			 0, -1, t, 	0, 1, t,	0, -1, -t, 	0, 1, -t,
			 t, 0, -1, 	t, 0, 1, 	-t, 0, -1, 	-t, 0, 1,
		];

		const indices = [
			 0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			 1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			 3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			 4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1,
		];

		PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);

		this.type = 'IcosahedronBufferGeometry';

		this.parameters = {
			radius,
			detail,
		};
	}

	IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
	IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

	/**
	 * @author Abe Pazos / https://hamoid.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// DodecahedronGeometry

	function DodecahedronGeometry(radius, detail) {
		Geometry.call(this);

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius,
			detail,
		};

		this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
		this.mergeVertices();
	}

	DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
	DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

	// DodecahedronBufferGeometry

	function DodecahedronBufferGeometry(radius, detail) {
		const t = (1 + Math.sqrt(5)) / 2;
		const r = 1 / t;

		const vertices = [

			// (1, 1, 1)
			-1, -1, -1,	-1, -1, 1,
			-1, 1, -1, -1, 1, 1,
			1, -1, -1, 1, -1, 1,
			1, 1, -1, 1, 1, 1,

			// (0, 1/, )
			 0, -r, -t, 0, -r, t,
			 0, r, -t, 0, r, t,

			// (1/, , 0)
			-r, -t, 0, -r, t, 0,
			 r, -t, 0, r, t, 0,

			// (, 0, 1/)
			-t, 0, -r, t, 0, -r,
			-t, 0, r, t, 0, r,
		];

		const indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9,
		];

		PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);

		this.type = 'DodecahedronBufferGeometry';

		this.parameters = {
			radius,
			detail,
		};
	}

	DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
	DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

	/**
	 * @author oosmoxiecode / https://github.com/oosmoxiecode
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 */

	// TubeGeometry

	function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
		Geometry.call(this);

		this.type = 'TubeGeometry';

		this.parameters = {
			path,
			tubularSegments,
			radius,
			radialSegments,
			closed,
		};

		if (taper !== undefined) console.warn('THREE.TubeGeometry: taper has been removed.');

		const bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);

		// expose internals

		this.tangents = bufferGeometry.tangents;
		this.normals = bufferGeometry.normals;
		this.binormals = bufferGeometry.binormals;

		// create geometry

		this.fromBufferGeometry(bufferGeometry);
		this.mergeVertices();
	}

	TubeGeometry.prototype = Object.create(Geometry.prototype);
	TubeGeometry.prototype.constructor = TubeGeometry;

	// TubeBufferGeometry

	function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
		BufferGeometry.call(this);

		this.type = 'TubeBufferGeometry';

		this.parameters = {
			path,
			tubularSegments,
			radius,
			radialSegments,
			closed,
		};

		tubularSegments = tubularSegments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;

		const frames = path.computeFrenetFrames(tubularSegments, closed);

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		const vertex = new Vector3();
		const normal = new Vector3();
		const uv = new Vector2();
		let P = new Vector3();

		let i; let
			j;

		// buffer

		const vertices = [];
		const normals = [];
		const uvs = [];
		const indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex(indices);
		this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

		// functions

		function generateBufferData() {
			for (i = 0; i < tubularSegments; i++) {
				generateSegment(i);
			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment((closed === false) ? tubularSegments : 0);

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();
		}

		function generateSegment(i) {
			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt(i / tubularSegments, P);

			// retrieve corresponding normal and binormal

			const N = frames.normals[i];
			const B = frames.binormals[i];

			// generate normals and vertices for the current segment

			for (j = 0; j <= radialSegments; j++) {
				const v = j / radialSegments * Math.PI * 2;

				const sin = Math.sin(v);
				const cos = -Math.cos(v);

				// normal

				normal.x = (cos * N.x + sin * B.x);
				normal.y = (cos * N.y + sin * B.y);
				normal.z = (cos * N.z + sin * B.z);
				normal.normalize();

				normals.push(normal.x, normal.y, normal.z);

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;

				vertices.push(vertex.x, vertex.y, vertex.z);
			}
		}

		function generateIndices() {
			for (j = 1; j <= tubularSegments; j++) {
				for (i = 1; i <= radialSegments; i++) {
					const a = (radialSegments + 1) * (j - 1) + (i - 1);
					const b = (radialSegments + 1) * j + (i - 1);
					const c = (radialSegments + 1) * j + i;
					const d = (radialSegments + 1) * (j - 1) + i;

					// faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			}
		}

		function generateUVs() {
			for (i = 0; i <= tubularSegments; i++) {
				for (j = 0; j <= radialSegments; j++) {
					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;

					uvs.push(uv.x, uv.y);
				}
			}
		}
	}

	TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

	/**
	 * @author oosmoxiecode
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * based on http://www.blackpawn.com/texts/pqtorus/
	 */

	// TorusKnotGeometry

	function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
		Geometry.call(this);

		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius,
			tube,
			tubularSegments,
			radialSegments,
			p,
			q,
		};

		if (heightScale !== undefined) console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');

		this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
		this.mergeVertices();
	}

	TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
	TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

	// TorusKnotBufferGeometry

	function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
		BufferGeometry.call(this);

		this.type = 'TorusKnotBufferGeometry';

		this.parameters = {
			radius,
			tube,
			tubularSegments,
			radialSegments,
			p,
			q,
		};

		radius = radius || 1;
		tube = tube || 0.4;
		tubularSegments = Math.floor(tubularSegments) || 64;
		radialSegments = Math.floor(radialSegments) || 8;
		p = p || 2;
		q = q || 3;

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let i; let
			j;

		const vertex = new Vector3();
		const normal = new Vector3();

		const P1 = new Vector3();
		const P2 = new Vector3();

		const B = new Vector3();
		const T = new Vector3();
		const N = new Vector3();

		// generate vertices, normals and uvs

		for (i = 0; i <= tubularSegments; ++i) {
			// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

			const u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve(u, p, q, radius, P1);
			calculatePositionOnCurve(u + 0.01, p, q, radius, P2);

			// calculate orthonormal basis

			T.subVectors(P2, P1);
			N.addVectors(P2, P1);
			B.crossVectors(T, N);
			N.crossVectors(B, T);

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for (j = 0; j <= radialSegments; ++j) {
				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				const v = j / radialSegments * Math.PI * 2;
				const cx = -tube * Math.cos(v);
				const cy = tube * Math.sin(v);

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

				vertex.x = P1.x + (cx * N.x + cy * B.x);
				vertex.y = P1.y + (cx * N.y + cy * B.y);
				vertex.z = P1.z + (cx * N.z + cy * B.z);

				vertices.push(vertex.x, vertex.y, vertex.z);

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors(vertex, P1).normalize();

				normals.push(normal.x, normal.y, normal.z);

				// uv

				uvs.push(i / tubularSegments);
				uvs.push(j / radialSegments);
			}
		}

		// generate indices

		for (j = 1; j <= tubularSegments; j++) {
			for (i = 1; i <= radialSegments; i++) {
				// indices

				const a = (radialSegments + 1) * (j - 1) + (i - 1);
				const b = (radialSegments + 1) * j + (i - 1);
				const c = (radialSegments + 1) * j + i;
				const d = (radialSegments + 1) * (j - 1) + i;

				// faces

				indices.push(a, b, d);
				indices.push(b, c, d);
			}
		}

		// build geometry

		this.setIndex(indices);
		this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve(u, p, q, radius, position) {
			const cu = Math.cos(u);
			const su = Math.sin(u);
			const quOverP = q / p * u;
			const cs = Math.cos(quOverP);

			position.x = radius * (2 + cs) * 0.5 * cu;
			position.y = radius * (2 + cs) * su * 0.5;
			position.z = radius * Math.sin(quOverP) * 0.5;
		}
	}

	TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// TorusGeometry

	function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
		Geometry.call(this);

		this.type = 'TorusGeometry';

		this.parameters = {
			radius,
			tube,
			radialSegments,
			tubularSegments,
			arc,
		};

		this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
		this.mergeVertices();
	}

	TorusGeometry.prototype = Object.create(Geometry.prototype);
	TorusGeometry.prototype.constructor = TorusGeometry;

	// TorusBufferGeometry

	function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
		BufferGeometry.call(this);

		this.type = 'TorusBufferGeometry';

		this.parameters = {
			radius,
			tube,
			radialSegments,
			tubularSegments,
			arc,
		};

		radius = radius || 1;
		tube = tube || 0.4;
		radialSegments = Math.floor(radialSegments) || 8;
		tubularSegments = Math.floor(tubularSegments) || 6;
		arc = arc || Math.PI * 2;

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const center = new Vector3();
		const vertex = new Vector3();
		const normal = new Vector3();

		let j; let
			i;

		// generate vertices, normals and uvs

		for (j = 0; j <= radialSegments; j++) {
			for (i = 0; i <= tubularSegments; i++) {
				const u = i / tubularSegments * arc;
				const v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
				vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
				vertex.z = tube * Math.sin(v);

				vertices.push(vertex.x, vertex.y, vertex.z);

				// normal

				center.x = radius * Math.cos(u);
				center.y = radius * Math.sin(u);
				normal.subVectors(vertex, center).normalize();

				normals.push(normal.x, normal.y, normal.z);

				// uv

				uvs.push(i / tubularSegments);
				uvs.push(j / radialSegments);
			}
		}

		// generate indices

		for (j = 1; j <= radialSegments; j++) {
			for (i = 1; i <= tubularSegments; i++) {
				// indices

				const a = (tubularSegments + 1) * j + i - 1;
				const b = (tubularSegments + 1) * (j - 1) + i - 1;
				const c = (tubularSegments + 1) * (j - 1) + i;
				const d = (tubularSegments + 1) * j + i;

				// faces

				indices.push(a, b, d);
				indices.push(b, c, d);
			}
		}

		// build geometry

		this.setIndex(indices);
		this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
	}

	TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 * Port from https://github.com/mapbox/earcut (v2.1.2)
	 */

	const Earcut = {

		triangulate(data, holeIndices, dim) {
			dim = dim || 2;

			const hasHoles = holeIndices && holeIndices.length;
			const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
			let outerNode = linkedList(data, 0, outerLen, dim, true);
			const triangles = [];

			if (!outerNode) return triangles;

			let minX; let minY; let maxX; let maxY; let x; let y; let
				invSize;

			if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

			// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

			if (data.length > 80 * dim) {
				minX = maxX = data[0];
				minY = maxY = data[1];

				for (let i = dim; i < outerLen; i += dim) {
					x = data[i];
					y = data[i + 1];
					if (x < minX) minX = x;
					if (y < minY) minY = y;
					if (x > maxX) maxX = x;
					if (y > maxY) maxY = y;
				}

				// minX, minY and invSize are later used to transform coords into integers for z-order calculation

				invSize = Math.max(maxX - minX, maxY - minY);
				invSize = invSize !== 0 ? 1 / invSize : 0;
			}

			earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

			return triangles;
		},

	};

	// create a circular doubly linked list from polygon points in the specified winding order

	function linkedList(data, start, end, dim, clockwise) {
		let i; let
			last;

		if (clockwise === (signedArea(data, start, end, dim) > 0)) {
			for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
		} else {
			for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
		}

		if (last && equals(last, last.next)) {
			removeNode(last);
			last = last.next;
		}

		return last;
	}

	// eliminate colinear or duplicate points

	function filterPoints(start, end) {
		if (!start) return start;
		if (!end) end = start;

		let p = start; let
			again;

		do {
			again = false;

			if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
				removeNode(p);
				p = end = p.prev;
				if (p === p.next) break;
				again = true;
			} else {
				p = p.next;
			}
		} while (again || p !== end);

		return end;
	}

	// main ear slicing loop which triangulates a polygon (given as a linked list)

	function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
		if (!ear) return;

		// interlink polygon nodes in z-order

		if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

		let stop = ear; let prev; let
			next;

		// iterate through ears, slicing them one by one

		while (ear.prev !== ear.next) {
			prev = ear.prev;
			next = ear.next;

			if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
				// cut off the triangle
				triangles.push(prev.i / dim);
				triangles.push(ear.i / dim);
				triangles.push(next.i / dim);

				removeNode(ear);

				// skipping the next vertice leads to less sliver triangles
				ear = next.next;
				stop = next.next;

				continue;
			}

			ear = next;

			// if we looped through the whole remaining polygon and can't find any more ears

			if (ear === stop) {
				// try filtering points and slicing again

				if (!pass) {
					earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

					// if this didn't work, try curing all small self-intersections locally
				} else if (pass === 1) {
					ear = cureLocalIntersections(ear, triangles, dim);
					earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

					// as a last resort, try splitting the remaining polygon into two
				} else if (pass === 2) {
					splitEarcut(ear, triangles, dim, minX, minY, invSize);
				}

				break;
			}
		}
	}

	// check whether a polygon node forms a valid ear with adjacent nodes

	function isEar(ear) {
		const a = ear.prev;
		const b = ear;
		const c = ear.next;

		if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

		// now make sure we don't have other points inside the potential ear
		let p = ear.next.next;

		while (p !== ear.prev) {
			if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
				return false;
			}

			p = p.next;
		}

		return true;
	}

	function isEarHashed(ear, minX, minY, invSize) {
		const a = ear.prev;
		const b = ear;
		const c = ear.next;

		if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

		// triangle bbox; min & max are calculated like this for speed

		const minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x);
		const minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y);
		const maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x);
		const maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

		// z-order range for the current triangle bbox;

		const minZ = zOrder(minTX, minTY, minX, minY, invSize);
		const maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

		// first look for points inside the triangle in increasing z-order

		let p = ear.nextZ;

		while (p && p.z <= maxZ) {
			if (p !== ear.prev && p !== ear.next
					&& pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y)
					&& area(p.prev, p, p.next) >= 0) return false;
			p = p.nextZ;
		}

		// then look for points in decreasing z-order

		p = ear.prevZ;

		while (p && p.z >= minZ) {
			if (p !== ear.prev && p !== ear.next
					&& pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y)
					&& area(p.prev, p, p.next) >= 0) return false;

			p = p.prevZ;
		}

		return true;
	}

	// go through all polygon nodes and cure small local self-intersections

	function cureLocalIntersections(start, triangles, dim) {
		let p = start;

		do {
			const a = p.prev; const
				b = p.next.next;

			if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
				triangles.push(a.i / dim);
				triangles.push(p.i / dim);
				triangles.push(b.i / dim);

				// remove two nodes involved

				removeNode(p);
				removeNode(p.next);

				p = start = b;
			}

			p = p.next;
		} while (p !== start);

		return p;
	}

	// try splitting polygon into two and triangulate them independently

	function splitEarcut(start, triangles, dim, minX, minY, invSize) {
		// look for a valid diagonal that divides the polygon into two

		let a = start;

		do {
			let b = a.next.next;

			while (b !== a.prev) {
				if (a.i !== b.i && isValidDiagonal(a, b)) {
					// split the polygon in two by the diagonal

					let c = splitPolygon(a, b);

					// filter colinear points around the cuts

					a = filterPoints(a, a.next);
					c = filterPoints(c, c.next);

					// run earcut on each half

					earcutLinked(a, triangles, dim, minX, minY, invSize);
					earcutLinked(c, triangles, dim, minX, minY, invSize);
					return;
				}

				b = b.next;
			}

			a = a.next;
		} while (a !== start);
	}

	// link every hole into the outer loop, producing a single-ring polygon without holes

	function eliminateHoles(data, holeIndices, outerNode, dim) {
		const queue = []; let i; let len; let start; let end; let
			list;

		for (i = 0, len = holeIndices.length; i < len; i++) {
			start = holeIndices[i] * dim;
			end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
			list = linkedList(data, start, end, dim, false);
			if (list === list.next) list.steiner = true;
			queue.push(getLeftmost(list));
		}

		queue.sort(compareX);

		// process holes from left to right

		for (i = 0; i < queue.length; i++) {
			eliminateHole(queue[i], outerNode);
			outerNode = filterPoints(outerNode, outerNode.next);
		}

		return outerNode;
	}

	function compareX(a, b) {
		return a.x - b.x;
	}

	// find a bridge between vertices that connects hole with an outer ring and and link it

	function eliminateHole(hole, outerNode) {
		outerNode = findHoleBridge(hole, outerNode);

		if (outerNode) {
			const b = splitPolygon(outerNode, hole);

			filterPoints(b, b.next);
		}
	}

	// David Eberly's algorithm for finding a bridge between hole and outer polygon

	function findHoleBridge(hole, outerNode) {
		let p = outerNode;
		const hx = hole.x;
		const hy = hole.y;
		let qx = -Infinity;
		let m;

		// find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point

		do {
			if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
				const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

				if (x <= hx && x > qx) {
					qx = x;

					if (x === hx) {
						if (hy === p.y) return p;
						if (hy === p.next.y) return p.next;
					}

					m = p.x < p.next.x ? p : p.next;
				}
			}

			p = p.next;
		} while (p !== outerNode);

		if (!m) return null;

		if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point

		const stop = m;
		const mx = m.x;
		const my = m.y;
		let tanMin = Infinity;
		let tan;

		p = m.next;

		while (p !== stop) {
			if (hx >= p.x && p.x >= mx && hx !== p.x
							&& pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
				tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

				if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
					m = p;
					tanMin = tan;
				}
			}

			p = p.next;
		}

		return m;
	}

	// interlink polygon nodes in z-order

	function indexCurve(start, minX, minY, invSize) {
		let p = start;

		do {
			if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;
		} while (p !== start);

		p.prevZ.nextZ = null;
		p.prevZ = null;

		sortLinked(p);
	}

	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html

	function sortLinked(list) {
		let i; let p; let q; let e; let tail; let numMerges; let pSize; let qSize; let
			inSize = 1;

		do {
			p = list;
			list = null;
			tail = null;
			numMerges = 0;

			while (p) {
				numMerges++;
				q = p;
				pSize = 0;

				for (i = 0; i < inSize; i++) {
					pSize++;
					q = q.nextZ;
					if (!q) break;
				}

				qSize = inSize;

				while (pSize > 0 || (qSize > 0 && q)) {
					if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
						e = p;
						p = p.nextZ;
						pSize--;
					} else {
						e = q;
						q = q.nextZ;
						qSize--;
					}

					if (tail) tail.nextZ = e;
					else list = e;

					e.prevZ = tail;
					tail = e;
				}

				p = q;
			}

			tail.nextZ = null;
			inSize *= 2;
		} while (numMerges > 1);

		return list;
	}

	// z-order of a point given coords and inverse of the longer side of data bbox

	function zOrder(x, y, minX, minY, invSize) {
		// coords are transformed into non-negative 15-bit integer range

		x = 32767 * (x - minX) * invSize;
		y = 32767 * (y - minY) * invSize;

		x = (x | (x << 8)) & 0x00FF00FF;
		x = (x | (x << 4)) & 0x0F0F0F0F;
		x = (x | (x << 2)) & 0x33333333;
		x = (x | (x << 1)) & 0x55555555;

		y = (y | (y << 8)) & 0x00FF00FF;
		y = (y | (y << 4)) & 0x0F0F0F0F;
		y = (y | (y << 2)) & 0x33333333;
		y = (y | (y << 1)) & 0x55555555;

		return x | (y << 1);
	}

	// find the leftmost node of a polygon ring

	function getLeftmost(start) {
		let p = start; let
			leftmost = start;

		do {
			if (p.x < leftmost.x) leftmost = p;
			p = p.next;
		} while (p !== start);

		return leftmost;
	}

	// check if a point lies within a convex triangle

	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
		return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0
		 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0
		 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
	}

	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)

	function isValidDiagonal(a, b) {
		return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b)
			&& locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
	}

	// signed area of a triangle

	function area(p, q, r) {
		return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	}

	// check if two points are equal

	function equals(p1, p2) {
		return p1.x === p2.x && p1.y === p2.y;
	}

	// check if two segments intersect

	function intersects(p1, q1, p2, q2) {
		if ((equals(p1, q1) && equals(p2, q2))
				|| (equals(p1, q2) && equals(p2, q1))) return true;

		return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0
					 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
	}

	// check if a polygon diagonal intersects any polygon segments

	function intersectsPolygon(a, b) {
		let p = a;

		do {
			if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i
							&& intersects(p, p.next, a, b)) {
				return true;
			}

			p = p.next;
		} while (p !== a);

		return false;
	}

	// check if a polygon diagonal is locally inside the polygon

	function locallyInside(a, b) {
		return area(a.prev, a, a.next) < 0
			? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0
			: area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
	}

	// check if the middle point of a polygon diagonal is inside the polygon

	function middleInside(a, b) {
		let p = a;
		let inside = false;
		const px = (a.x + b.x) / 2;
		const py = (a.y + b.y) / 2;

		do {
			if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y
							&& (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)) {
				inside = !inside;
			}

			p = p.next;
		} while (p !== a);

		return inside;
	}

	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring

	function splitPolygon(a, b) {
		const a2 = new Node(a.i, a.x, a.y);
		const b2 = new Node(b.i, b.x, b.y);
		const an = a.next;
		const bp = b.prev;

		a.next = b;
		b.prev = a;

		a2.next = an;
		an.prev = a2;

		b2.next = a2;
		a2.prev = b2;

		bp.next = b2;
		b2.prev = bp;

		return b2;
	}

	// create a node and optionally link it with previous one (in a circular doubly linked list)

	function insertNode(i, x, y, last) {
		const p = new Node(i, x, y);

		if (!last) {
			p.prev = p;
			p.next = p;
		} else {
			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;
		}

		return p;
	}

	function removeNode(p) {
		p.next.prev = p.prev;
		p.prev.next = p.next;

		if (p.prevZ) p.prevZ.nextZ = p.nextZ;
		if (p.nextZ) p.nextZ.prevZ = p.prevZ;
	}

	function Node(i, x, y) {
		// vertice index in coordinates array
		this.i = i;

		// vertex coordinates
		this.x = x;
		this.y = y;

		// previous and next vertice nodes in a polygon ring
		this.prev = null;
		this.next = null;

		// z-order curve value
		this.z = null;

		// previous and next nodes in z-order
		this.prevZ = null;
		this.nextZ = null;

		// indicates whether this is a steiner point
		this.steiner = false;
	}

	function signedArea(data, start, end, dim) {
		let sum = 0;

		for (let i = start, j = end - dim; i < end; i += dim) {
			sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
			j = i;
		}

		return sum;
	}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	var ShapeUtils = {

		// calculate area of the contour polygon

		area(contour) {
			const n = contour.length;
			let a = 0.0;

			for (let p = n - 1, q = 0; q < n; p = q++) {
				a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
			}

			return a * 0.5;
		},

		isClockWise(pts) {
			return ShapeUtils.area(pts) < 0;
		},

		triangulateShape(contour, holes) {
			const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
			const holeIndices = []; // array of hole indices
			const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

			removeDupEndPts(contour);
			addContour(vertices, contour);

			//

			let holeIndex = contour.length;

			holes.forEach(removeDupEndPts);

			for (var i = 0; i < holes.length; i++) {
				holeIndices.push(holeIndex);
				holeIndex += holes[i].length;
				addContour(vertices, holes[i]);
			}

			//

			const triangles = Earcut.triangulate(vertices, holeIndices);

			//

			for (var i = 0; i < triangles.length; i += 3) {
				faces.push(triangles.slice(i, i + 3));
			}

			return faces;
		},

	};

	function removeDupEndPts(points) {
		const l = points.length;

		if (l > 2 && points[l - 1].equals(points[0])) {
			points.pop();
		}
	}

	function addContour(vertices, contour) {
		for (let i = 0; i < contour.length; i++) {
			vertices.push(contour[i].x);
			vertices.push(contour[i].y);
		}
	}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  depth: <float>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.Curve> // curve to extrude shape along
	 *
	 *  UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */

	// ExtrudeGeometry

	function ExtrudeGeometry(shapes, options) {
		Geometry.call(this);

		this.type = 'ExtrudeGeometry';

		this.parameters = {
			shapes,
			options,
		};

		this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
		this.mergeVertices();
	}

	ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
	ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

	ExtrudeGeometry.prototype.toJSON = function () {
		const data = Geometry.prototype.toJSON.call(this);

		const { shapes } = this.parameters;
		const { options } = this.parameters;

		return toJSON(shapes, options, data);
	};

	// ExtrudeBufferGeometry

	function ExtrudeBufferGeometry(shapes, options) {
		BufferGeometry.call(this);

		this.type = 'ExtrudeBufferGeometry';

		this.parameters = {
			shapes,
			options,
		};

		shapes = Array.isArray(shapes) ? shapes : [shapes];

		const scope = this;

		const verticesArray = [];
		const uvArray = [];

		for (let i = 0, l = shapes.length; i < l; i++) {
			const shape = shapes[i];
			addShape(shape);
		}

		// build geometry

		this.addAttribute('position', new Float32BufferAttribute(verticesArray, 3));
		this.addAttribute('uv', new Float32BufferAttribute(uvArray, 2));

		this.computeVertexNormals();

		// functions

		function addShape(shape) {
			const placeholder = [];

			// options

			const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			const steps = options.steps !== undefined ? options.steps : 1;
			let depth = options.depth !== undefined ? options.depth : 100;

			let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
			let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
			let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			const { extrudePath } = options;

			const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

			// deprecated options

			if (options.amount !== undefined) {
				console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
				depth = options.amount;
			}

			//

			let extrudePts; let
				extrudeByPath = false;
			let splineTube; let binormal; let normal; let
				position2;

			if (extrudePath) {
				extrudePts = extrudePath.getSpacedPoints(steps);

				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = extrudePath.computeFrenetFrames(steps, false);

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();
			}

			// Safeguards if bevels are not enabled

			if (!bevelEnabled) {
				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
			}

			// Variables initialization

			let ahole; let h; let
				hl; // looping of holes

			const shapePoints = shape.extractPoints(curveSegments);

			let vertices = shapePoints.shape;
			const { holes } = shapePoints;

			const reverse = !ShapeUtils.isClockWise(vertices);

			if (reverse) {
				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for (h = 0, hl = holes.length; h < hl; h++) {
					ahole = holes[h];

					if (ShapeUtils.isClockWise(ahole)) {
						holes[h] = ahole.reverse();
					}
				}
			}


			const faces = ShapeUtils.triangulateShape(vertices, holes);

			/* Vertices */

			const contour = vertices; // vertices has all points but contour has only points of circumference

			for (h = 0, hl = holes.length; h < hl; h++) {
				ahole = holes[h];

				vertices = vertices.concat(ahole);
			}


			function scalePt2(pt, vec, size) {
				if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');

				return vec.clone().multiplyScalar(size).add(pt);
			}

			let b; let bs; let t; let z;
			let vert; const vlen = vertices.length;
			let face; const
				flen = faces.length;


			// Find directions for point movement


			function getBevelVec(inPt, inPrev, inNext) {
				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.

				let v_trans_x; let v_trans_y; let
					shrink_by; // resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				const v_prev_x = inPt.x - inPrev.x;
				const v_prev_y = inPt.y - inPrev.y;
				const v_next_x = inNext.x - inPt.x;
				const v_next_y = inNext.y - inPt.y;

				const v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);

				// check for collinear edges
				const collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);

				if (Math.abs(collinear0) > Number.EPSILON) {
					// not collinear

					// length of vectors for normalizing

					const v_prev_len = Math.sqrt(v_prev_lensq);
					const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);

					// shift adjacent points by unit vectors to the left

					const ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
					const ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);

					const ptNextShift_x = (inNext.x - v_next_y / v_next_len);
					const ptNextShift_y = (inNext.y + v_next_x / v_next_len);

					// scaling factor for v_prev to intersection point

					const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y
							- (ptNextShift_y - ptPrevShift_y) * v_next_x)
						/ (v_prev_x * v_next_y - v_prev_y * v_next_x);

					// vector from inPt to intersection point

					v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
					v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);

					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					const v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
					if (v_trans_lensq <= 2) {
						return new Vector2(v_trans_x, v_trans_y);
					}

					shrink_by = Math.sqrt(v_trans_lensq / 2);
				} else {
					// handle special case of collinear edges

					let direction_eq = false; // assumes: opposite
					if (v_prev_x > Number.EPSILON) {
						if (v_next_x > Number.EPSILON) {
							direction_eq = true;
						}
					} else if (v_prev_x < -Number.EPSILON) {
						if (v_next_x < -Number.EPSILON) {
							direction_eq = true;
						}
					} else if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
						direction_eq = true;
					}

					if (direction_eq) {
						// console.log("Warning: lines are a straight sequence");
						v_trans_x = -v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt(v_prev_lensq);
					} else {
						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt(v_prev_lensq / 2);
					}
				}

				return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
			}


			const contourMovements = [];

			for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
				if (j === il) j = 0;
				if (k === il) k = 0;

				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
			}

			const holesMovements = [];
			let oneHoleMovements; let
				verticesMovements = contourMovements.concat();

			for (h = 0, hl = holes.length; h < hl; h++) {
				ahole = holes[h];

				oneHoleMovements = [];

				for (i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
					if (j === il) j = 0;
					if (k === il) k = 0;

					//  (j)---(i)---(k)
					oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
				}

				holesMovements.push(oneHoleMovements);
				verticesMovements = verticesMovements.concat(oneHoleMovements);
			}


			// Loop bevelSegments, 1 for the front, 1 for the back

			for (b = 0; b < bevelSegments; b++) {
				// for ( b = bevelSegments; b > 0; b -- ) {

				t = b / bevelSegments;
				z = bevelThickness * Math.cos(t * Math.PI / 2);
				bs = bevelSize * Math.sin(t * Math.PI / 2);

				// contract shape

				for (i = 0, il = contour.length; i < il; i++) {
					vert = scalePt2(contour[i], contourMovements[i], bs);

					v(vert.x, vert.y, -z);
				}

				// expand holes

				for (h = 0, hl = holes.length; h < hl; h++) {
					ahole = holes[h];
					oneHoleMovements = holesMovements[h];

					for (i = 0, il = ahole.length; i < il; i++) {
						vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

						v(vert.x, vert.y, -z);
					}
				}
			}

			bs = bevelSize;

			// Back facing vertices

			for (i = 0; i < vlen; i++) {
				vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

				if (!extrudeByPath) {
					v(vert.x, vert.y, 0);
				} else {
					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
					binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);

					position2.copy(extrudePts[0]).add(normal).add(binormal);

					v(position2.x, position2.y, position2.z);
				}
			}

			// Add stepped vertices...
			// Including front facing vertices

			let s;

			for (s = 1; s <= steps; s++) {
				for (i = 0; i < vlen; i++) {
					vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

					if (!extrudeByPath) {
						v(vert.x, vert.y, depth / steps * s);
					} else {
						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
						binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);

						position2.copy(extrudePts[s]).add(normal).add(binormal);

						v(position2.x, position2.y, position2.z);
					}
				}
			}


			// Add bevel segments planes

			// for ( b = 1; b <= bevelSegments; b ++ ) {
			for (b = bevelSegments - 1; b >= 0; b--) {
				t = b / bevelSegments;
				z = bevelThickness * Math.cos(t * Math.PI / 2);
				bs = bevelSize * Math.sin(t * Math.PI / 2);

				// contract shape

				for (i = 0, il = contour.length; i < il; i++) {
					vert = scalePt2(contour[i], contourMovements[i], bs);
					v(vert.x, vert.y, depth + z);
				}

				// expand holes

				for (h = 0, hl = holes.length; h < hl; h++) {
					ahole = holes[h];
					oneHoleMovements = holesMovements[h];

					for (i = 0, il = ahole.length; i < il; i++) {
						vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

						if (!extrudeByPath) {
							v(vert.x, vert.y, depth + z);
						} else {
							v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
						}
					}
				}
			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();


			// ///  Internal functions

			function buildLidFaces() {
				const start = verticesArray.length / 3;

				if (bevelEnabled) {
					let layer = 0; // steps + 1
					let offset = vlen * layer;

					// Bottom faces

					for (i = 0; i < flen; i++) {
						face = faces[i];
						f3(face[2] + offset, face[1] + offset, face[0] + offset);
					}

					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for (i = 0; i < flen; i++) {
						face = faces[i];
						f3(face[0] + offset, face[1] + offset, face[2] + offset);
					}
				} else {
					// Bottom faces

					for (i = 0; i < flen; i++) {
						face = faces[i];
						f3(face[2], face[1], face[0]);
					}

					// Top faces

					for (i = 0; i < flen; i++) {
						face = faces[i];
						f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
					}
				}

				scope.addGroup(start, verticesArray.length / 3 - start, 0);
			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {
				const start = verticesArray.length / 3;
				let layeroffset = 0;
				sidewalls(contour, layeroffset);
				layeroffset += contour.length;

				for (h = 0, hl = holes.length; h < hl; h++) {
					ahole = holes[h];
					sidewalls(ahole, layeroffset);

					// , true
					layeroffset += ahole.length;
				}


				scope.addGroup(start, verticesArray.length / 3 - start, 1);
			}

			function sidewalls(contour, layeroffset) {
				let j; let
					k;
				i = contour.length;

				while (--i >= 0) {
					j = i;
					k = i - 1;
					if (k < 0) k = contour.length - 1;

					// console.log('b', i,j, i-1, k,vertices.length);

					let s = 0;
					const sl = steps + bevelSegments * 2;

					for (s = 0; s < sl; s++) {
						const slen1 = vlen * s;
						const slen2 = vlen * (s + 1);

						const a = layeroffset + j + slen1;
						const b = layeroffset + k + slen1;
						const c = layeroffset + k + slen2;
						const d = layeroffset + j + slen2;

						f4(a, b, c, d);
					}
				}
			}

			function v(x, y, z) {
				placeholder.push(x);
				placeholder.push(y);
				placeholder.push(z);
			}


			function f3(a, b, c) {
				addVertex(a);
				addVertex(b);
				addVertex(c);

				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);

				addUV(uvs[0]);
				addUV(uvs[1]);
				addUV(uvs[2]);
			}

			function f4(a, b, c, d) {
				addVertex(a);
				addVertex(b);
				addVertex(d);

				addVertex(b);
				addVertex(c);
				addVertex(d);


				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);

				addUV(uvs[0]);
				addUV(uvs[1]);
				addUV(uvs[3]);

				addUV(uvs[1]);
				addUV(uvs[2]);
				addUV(uvs[3]);
			}

			function addVertex(index) {
				verticesArray.push(placeholder[index * 3 + 0]);
				verticesArray.push(placeholder[index * 3 + 1]);
				verticesArray.push(placeholder[index * 3 + 2]);
			}


			function addUV(vector2) {
				uvArray.push(vector2.x);
				uvArray.push(vector2.y);
			}
		}
	}

	ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

	ExtrudeBufferGeometry.prototype.toJSON = function () {
		const data = BufferGeometry.prototype.toJSON.call(this);

		const { shapes } = this.parameters;
		const { options } = this.parameters;

		return toJSON(shapes, options, data);
	};

	//

	var WorldUVGenerator = {

		generateTopUV(geometry, vertices, indexA, indexB, indexC) {
			const a_x = vertices[indexA * 3];
			const a_y = vertices[indexA * 3 + 1];
			const b_x = vertices[indexB * 3];
			const b_y = vertices[indexB * 3 + 1];
			const c_x = vertices[indexC * 3];
			const c_y = vertices[indexC * 3 + 1];

			return [
				new Vector2(a_x, a_y),
				new Vector2(b_x, b_y),
				new Vector2(c_x, c_y),
			];
		},

		generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {
			const a_x = vertices[indexA * 3];
			const a_y = vertices[indexA * 3 + 1];
			const a_z = vertices[indexA * 3 + 2];
			const b_x = vertices[indexB * 3];
			const b_y = vertices[indexB * 3 + 1];
			const b_z = vertices[indexB * 3 + 2];
			const c_x = vertices[indexC * 3];
			const c_y = vertices[indexC * 3 + 1];
			const c_z = vertices[indexC * 3 + 2];
			const d_x = vertices[indexD * 3];
			const d_y = vertices[indexD * 3 + 1];
			const d_z = vertices[indexD * 3 + 2];

			if (Math.abs(a_y - b_y) < 0.01) {
				return [
					new Vector2(a_x, 1 - a_z),
					new Vector2(b_x, 1 - b_z),
					new Vector2(c_x, 1 - c_z),
					new Vector2(d_x, 1 - d_z),
				];
			}
			return [
				new Vector2(a_y, 1 - a_z),
				new Vector2(b_y, 1 - b_z),
				new Vector2(c_y, 1 - c_z),
				new Vector2(d_y, 1 - d_z),
			];
		},
	};

	function toJSON(shapes, options, data) {
		//

		data.shapes = [];

		if (Array.isArray(shapes)) {
			for (let i = 0, l = shapes.length; i < l; i++) {
				const shape = shapes[i];

				data.shapes.push(shape.uuid);
			}
		} else {
			data.shapes.push(shapes.uuid);
		}

		//

		if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();

		return data;
	}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  font: <THREE.Font>, // font
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float> // how far from text outline is bevel
	 * }
	 */

	// TextGeometry

	function TextGeometry(text, parameters) {
		Geometry.call(this);

		this.type = 'TextGeometry';

		this.parameters = {
			text,
			parameters,
		};

		this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
		this.mergeVertices();
	}

	TextGeometry.prototype = Object.create(Geometry.prototype);
	TextGeometry.prototype.constructor = TextGeometry;

	// TextBufferGeometry

	function TextBufferGeometry(text, parameters) {
		parameters = parameters || {};

		const { font } = parameters;

		if (!(font && font.isFont)) {
			console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
			return new Geometry();
		}

		const shapes = font.generateShapes(text, parameters.size);

		// translate parameters to ExtrudeGeometry API

		parameters.depth = parameters.height !== undefined ? parameters.height : 50;

		// defaults

		if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
		if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
		if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;

		ExtrudeBufferGeometry.call(this, shapes, parameters);

		this.type = 'TextBufferGeometry';
	}

	TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
	TextBufferGeometry.prototype.constructor = TextBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// SphereGeometry

	function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
		Geometry.call(this);

		this.type = 'SphereGeometry';

		this.parameters = {
			radius,
			widthSegments,
			heightSegments,
			phiStart,
			phiLength,
			thetaStart,
			thetaLength,
		};

		this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
		this.mergeVertices();
	}

	SphereGeometry.prototype = Object.create(Geometry.prototype);
	SphereGeometry.prototype.constructor = SphereGeometry;

	// SphereBufferGeometry

	function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
		BufferGeometry.call(this);

		this.type = 'SphereBufferGeometry';

		this.parameters = {
			radius,
			widthSegments,
			heightSegments,
			phiStart,
			phiLength,
			thetaStart,
			thetaLength,
		};

		radius = radius || 1;

		widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
		heightSegments = Math.max(2, Math.floor(heightSegments) || 6);

		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

		const thetaEnd = thetaStart + thetaLength;

		let ix; let
			iy;

		let index = 0;
		const grid = [];

		const vertex = new Vector3();
		const normal = new Vector3();

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// generate vertices, normals and uvs

		for (iy = 0; iy <= heightSegments; iy++) {
			const verticesRow = [];

			const v = iy / heightSegments;

			for (ix = 0; ix <= widthSegments; ix++) {
				const u = ix / widthSegments;

				// vertex

				vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
				vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
				vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);

				vertices.push(vertex.x, vertex.y, vertex.z);

				// normal

				normal.set(vertex.x, vertex.y, vertex.z).normalize();
				normals.push(normal.x, normal.y, normal.z);

				// uv

				uvs.push(u, 1 - v);

				verticesRow.push(index++);
			}

			grid.push(verticesRow);
		}

		// indices

		for (iy = 0; iy < heightSegments; iy++) {
			for (ix = 0; ix < widthSegments; ix++) {
				const a = grid[iy][ix + 1];
				const b = grid[iy][ix];
				const c = grid[iy + 1][ix];
				const d = grid[iy + 1][ix + 1];

				if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
				if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
			}
		}

		// build geometry

		this.setIndex(indices);
		this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
	}

	SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

	/**
	 * @author Kaleb Murphy
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// RingGeometry

	function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
		Geometry.call(this);

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius,
			outerRadius,
			thetaSegments,
			phiSegments,
			thetaStart,
			thetaLength,
		};

		this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
		this.mergeVertices();
	}

	RingGeometry.prototype = Object.create(Geometry.prototype);
	RingGeometry.prototype.constructor = RingGeometry;

	// RingBufferGeometry

	function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
		BufferGeometry.call(this);

		this.type = 'RingBufferGeometry';

		this.parameters = {
			innerRadius,
			outerRadius,
			thetaSegments,
			phiSegments,
			thetaStart,
			thetaLength,
		};

		innerRadius = innerRadius || 0.5;
		outerRadius = outerRadius || 1;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
		phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// some helper variables

		let segment;
		let radius = innerRadius;
		const radiusStep = ((outerRadius - innerRadius) / phiSegments);
		const vertex = new Vector3();
		const uv = new Vector2();
		let j; let
			i;

		// generate vertices, normals and uvs

		for (j = 0; j <= phiSegments; j++) {
			for (i = 0; i <= thetaSegments; i++) {
				// values are generate from the inside of the ring to the outside

				segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos(segment);
				vertex.y = radius * Math.sin(segment);

				vertices.push(vertex.x, vertex.y, vertex.z);

				// normal

				normals.push(0, 0, 1);

				// uv

				uv.x = (vertex.x / outerRadius + 1) / 2;
				uv.y = (vertex.y / outerRadius + 1) / 2;

				uvs.push(uv.x, uv.y);
			}

			// increase the radius for next row of vertices

			radius += radiusStep;
		}

		// indices

		for (j = 0; j < phiSegments; j++) {
			const thetaSegmentLevel = j * (thetaSegments + 1);

			for (i = 0; i < thetaSegments; i++) {
				segment = i + thetaSegmentLevel;

				const a = segment;
				const b = segment + thetaSegments + 1;
				const c = segment + thetaSegments + 2;
				const d = segment + 1;

				// faces

				indices.push(a, b, d);
				indices.push(b, c, d);
			}
		}

		// build geometry

		this.setIndex(indices);
		this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
	}

	RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	RingBufferGeometry.prototype.constructor = RingBufferGeometry;

	/**
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://clara.io
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// LatheGeometry

	function LatheGeometry(points, segments, phiStart, phiLength) {
		Geometry.call(this);

		this.type = 'LatheGeometry';

		this.parameters = {
			points,
			segments,
			phiStart,
			phiLength,
		};

		this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
		this.mergeVertices();
	}

	LatheGeometry.prototype = Object.create(Geometry.prototype);
	LatheGeometry.prototype.constructor = LatheGeometry;

	// LatheBufferGeometry

	function LatheBufferGeometry(points, segments, phiStart, phiLength) {
		BufferGeometry.call(this);

		this.type = 'LatheBufferGeometry';

		this.parameters = {
			points,
			segments,
			phiStart,
			phiLength,
		};

		segments = Math.floor(segments) || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || Math.PI * 2;

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = _Math.clamp(phiLength, 0, Math.PI * 2);


		// buffers

		const indices = [];
		const vertices = [];
		const uvs = [];

		// helper variables

		let base;
		const inverseSegments = 1.0 / segments;
		const vertex = new Vector3();
		const uv = new Vector2();
		let i; let
			j;

		// generate vertices and uvs

		for (i = 0; i <= segments; i++) {
			const phi = phiStart + i * inverseSegments * phiLength;

			const sin = Math.sin(phi);
			const cos = Math.cos(phi);

			for (j = 0; j <= (points.length - 1); j++) {
				// vertex

				vertex.x = points[j].x * sin;
				vertex.y = points[j].y;
				vertex.z = points[j].x * cos;

				vertices.push(vertex.x, vertex.y, vertex.z);

				// uv

				uv.x = i / segments;
				uv.y = j / (points.length - 1);

				uvs.push(uv.x, uv.y);
			}
		}

		// indices

		for (i = 0; i < segments; i++) {
			for (j = 0; j < (points.length - 1); j++) {
				base = j + i * points.length;

				const a = base;
				const b = base + points.length;
				const c = base + points.length + 1;
				const d = base + 1;

				// faces

				indices.push(a, b, d);
				indices.push(b, c, d);
			}
		}

		// build geometry

		this.setIndex(indices);
		this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

		// generate normals

		this.computeVertexNormals();

		// if the geometry is closed, we need to average the normals along the seam.
		// because the corresponding vertices are identical (but still have different UVs).

		if (phiLength === Math.PI * 2) {
			const normals = this.attributes.normal.array;
			const n1 = new Vector3();
			const n2 = new Vector3();
			const n = new Vector3();

			// this is the buffer offset for the last line of vertices

			base = segments * points.length * 3;

			for (i = 0, j = 0; i < points.length; i++, j += 3) {
				// select the normal of the vertex in the first line

				n1.x = normals[j + 0];
				n1.y = normals[j + 1];
				n1.z = normals[j + 2];

				// select the normal of the vertex in the last line

				n2.x = normals[base + j + 0];
				n2.y = normals[base + j + 1];
				n2.z = normals[base + j + 2];

				// average normals

				n.addVectors(n1, n2).normalize();

				// assign the new values to both normals

				normals[j + 0] = normals[base + j + 0] = n.x;
				normals[j + 1] = normals[base + j + 1] = n.y;
				normals[j + 2] = normals[base + j + 2] = n.z;
			}
		}
	}

	LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

	/**
	 * @author jonobr1 / http://jonobr1.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// ShapeGeometry

	function ShapeGeometry(shapes, curveSegments) {
		Geometry.call(this);

		this.type = 'ShapeGeometry';

		if (typeof curveSegments === 'object') {
			console.warn('THREE.ShapeGeometry: Options parameter has been removed.');

			curveSegments = curveSegments.curveSegments;
		}

		this.parameters = {
			shapes,
			curveSegments,
		};

		this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
		this.mergeVertices();
	}

	ShapeGeometry.prototype = Object.create(Geometry.prototype);
	ShapeGeometry.prototype.constructor = ShapeGeometry;

	ShapeGeometry.prototype.toJSON = function () {
		const data = Geometry.prototype.toJSON.call(this);

		const { shapes } = this.parameters;

		return toJSON$1(shapes, data);
	};

	// ShapeBufferGeometry

	function ShapeBufferGeometry(shapes, curveSegments) {
		BufferGeometry.call(this);

		this.type = 'ShapeBufferGeometry';

		this.parameters = {
			shapes,
			curveSegments,
		};

		curveSegments = curveSegments || 12;

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let groupStart = 0;
		let groupCount = 0;

		// allow single and array values for "shapes" parameter

		if (Array.isArray(shapes) === false) {
			addShape(shapes);
		} else {
			for (let i = 0; i < shapes.length; i++) {
				addShape(shapes[i]);

				this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;
			}
		}

		// build geometry

		this.setIndex(indices);
		this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));


		// helper functions

		function addShape(shape) {
			let i; let l; let
				shapeHole;

			const indexOffset = vertices.length / 3;
			const points = shape.extractPoints(curveSegments);

			let shapeVertices = points.shape;
			const shapeHoles = points.holes;

			// check direction of vertices

			if (ShapeUtils.isClockWise(shapeVertices) === false) {
				shapeVertices = shapeVertices.reverse();
			}

			for (i = 0, l = shapeHoles.length; i < l; i++) {
				shapeHole = shapeHoles[i];

				if (ShapeUtils.isClockWise(shapeHole) === true) {
					shapeHoles[i] = shapeHole.reverse();
				}
			}

			const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);

			// join vertices of inner and outer paths to a single array

			for (i = 0, l = shapeHoles.length; i < l; i++) {
				shapeHole = shapeHoles[i];
				shapeVertices = shapeVertices.concat(shapeHole);
			}

			// vertices, normals, uvs

			for (i = 0, l = shapeVertices.length; i < l; i++) {
				const vertex = shapeVertices[i];

				vertices.push(vertex.x, vertex.y, 0);
				normals.push(0, 0, 1);
				uvs.push(vertex.x, vertex.y); // world uvs
			}

			// incides

			for (i = 0, l = faces.length; i < l; i++) {
				const face = faces[i];

				const a = face[0] + indexOffset;
				const b = face[1] + indexOffset;
				const c = face[2] + indexOffset;

				indices.push(a, b, c);
				groupCount += 3;
			}
		}
	}

	ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

	ShapeBufferGeometry.prototype.toJSON = function () {
		const data = BufferGeometry.prototype.toJSON.call(this);

		const { shapes } = this.parameters;

		return toJSON$1(shapes, data);
	};

	//

	function toJSON$1(shapes, data) {
		data.shapes = [];

		if (Array.isArray(shapes)) {
			for (let i = 0, l = shapes.length; i < l; i++) {
				const shape = shapes[i];

				data.shapes.push(shape.uuid);
			}
		} else {
			data.shapes.push(shapes.uuid);
		}

		return data;
	}

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function EdgesGeometry(geometry, thresholdAngle) {
		BufferGeometry.call(this);

		this.type = 'EdgesGeometry';

		this.parameters = {
			thresholdAngle,
		};

		thresholdAngle = (thresholdAngle !== undefined) ? thresholdAngle : 1;

		// buffer

		const vertices = [];

		// helper variables

		const thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);
		const edge = [0, 0]; const edges = {}; let edge1; let
			edge2;
		let key; const
			keys = ['a', 'b', 'c'];

		// prepare source geometry

		let geometry2;

		if (geometry.isBufferGeometry) {
			geometry2 = new Geometry();
			geometry2.fromBufferGeometry(geometry);
		} else {
			geometry2 = geometry.clone();
		}

		geometry2.mergeVertices();
		geometry2.computeFaceNormals();

		const sourceVertices = geometry2.vertices;
		const { faces } = geometry2;

		// now create a data structure where each entry represents an edge with its adjoining faces

		for (let i = 0, l = faces.length; i < l; i++) {
			const face = faces[i];

			for (let j = 0; j < 3; j++) {
				edge1 = face[keys[j]];
				edge2 = face[keys[(j + 1) % 3]];
				edge[0] = Math.min(edge1, edge2);
				edge[1] = Math.max(edge1, edge2);

				key = `${edge[0]},${edge[1]}`;

				if (edges[key] === undefined) {
					edges[key] = {
						index1: edge[0], index2: edge[1], face1: i, face2: undefined,
					};
				} else {
					edges[key].face2 = i;
				}
			}
		}

		// generate vertices

		for (key in edges) {
			const e = edges[key];

			// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

			if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
				let vertex = sourceVertices[e.index1];
				vertices.push(vertex.x, vertex.y, vertex.z);

				vertex = sourceVertices[e.index2];
				vertices.push(vertex.x, vertex.y, vertex.z);
			}
		}

		// build geometry

		this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
	}

	EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
	EdgesGeometry.prototype.constructor = EdgesGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// CylinderGeometry

	function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
		Geometry.call(this);

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop,
			radiusBottom,
			height,
			radialSegments,
			heightSegments,
			openEnded,
			thetaStart,
			thetaLength,
		};

		this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
		this.mergeVertices();
	}

	CylinderGeometry.prototype = Object.create(Geometry.prototype);
	CylinderGeometry.prototype.constructor = CylinderGeometry;

	// CylinderBufferGeometry

	function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
		BufferGeometry.call(this);

		this.type = 'CylinderBufferGeometry';

		this.parameters = {
			radiusTop,
			radiusBottom,
			height,
			radialSegments,
			heightSegments,
			openEnded,
			thetaStart,
			thetaLength,
		};

		const scope = this;

		radiusTop = radiusTop !== undefined ? radiusTop : 1;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
		height = height || 1;

		radialSegments = Math.floor(radialSegments) || 8;
		heightSegments = Math.floor(heightSegments) || 1;

		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let index = 0;
		const indexArray = [];
		const halfHeight = height / 2;
		let groupStart = 0;

		// generate geometry

		generateTorso();

		if (openEnded === false) {
			if (radiusTop > 0) generateCap(true);
			if (radiusBottom > 0) generateCap(false);
		}

		// build geometry

		this.setIndex(indices);
		this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));

		function generateTorso() {
			let x; let
				y;
			const normal = new Vector3();
			const vertex = new Vector3();

			let groupCount = 0;

			// this will be used to calculate the normal
			const slope = (radiusBottom - radiusTop) / height;

			// generate vertices, normals and uvs

			for (y = 0; y <= heightSegments; y++) {
				const indexRow = [];

				const v = y / heightSegments;

				// calculate the radius of the current row

				const radius = v * (radiusBottom - radiusTop) + radiusTop;

				for (x = 0; x <= radialSegments; x++) {
					const u = x / radialSegments;

					const theta = u * thetaLength + thetaStart;

					const sinTheta = Math.sin(theta);
					const cosTheta = Math.cos(theta);

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = -v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push(vertex.x, vertex.y, vertex.z);

					// normal

					normal.set(sinTheta, slope, cosTheta).normalize();
					normals.push(normal.x, normal.y, normal.z);

					// uv

					uvs.push(u, 1 - v);

					// save index of vertex in respective row

					indexRow.push(index++);
				}

				// now save vertices of the row in our index array

				indexArray.push(indexRow);
			}

			// generate indices

			for (x = 0; x < radialSegments; x++) {
				for (y = 0; y < heightSegments; y++) {
					// we use the index array to access the correct indices

					const a = indexArray[y][x];
					const b = indexArray[y + 1][x];
					const c = indexArray[y + 1][x + 1];
					const d = indexArray[y][x + 1];

					// faces

					indices.push(a, b, d);
					indices.push(b, c, d);

					// update group counter

					groupCount += 6;
				}
			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup(groupStart, groupCount, 0);

			// calculate new start value for groups

			groupStart += groupCount;
		}

		function generateCap(top) {
			let x; let centerIndexStart; let
				centerIndexEnd;

			const uv = new Vector2();
			const vertex = new Vector3();

			let groupCount = 0;

			const radius = (top === true) ? radiusTop : radiusBottom;
			const sign = (top === true) ? 1 : -1;

			// save the index of the first center vertex
			centerIndexStart = index;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for (x = 1; x <= radialSegments; x++) {
				// vertex

				vertices.push(0, halfHeight * sign, 0);

				// normal

				normals.push(0, sign, 0);

				// uv

				uvs.push(0.5, 0.5);

				// increase index

				index++;
			}

			// save the index of the last center vertex

			centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for (x = 0; x <= radialSegments; x++) {
				const u = x / radialSegments;
				const theta = u * thetaLength + thetaStart;

				const cosTheta = Math.cos(theta);
				const sinTheta = Math.sin(theta);

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push(vertex.x, vertex.y, vertex.z);

				// normal

				normals.push(0, sign, 0);

				// uv

				uv.x = (cosTheta * 0.5) + 0.5;
				uv.y = (sinTheta * 0.5 * sign) + 0.5;
				uvs.push(uv.x, uv.y);

				// increase index

				index++;
			}

			// generate indices

			for (x = 0; x < radialSegments; x++) {
				const c = centerIndexStart + x;
				const i = centerIndexEnd + x;

				if (top === true) {
					// face top

					indices.push(i, i + 1, c);
				} else {
					// face bottom

					indices.push(i + 1, i, c);
				}

				groupCount += 3;
			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);

			// calculate new start value for groups

			groupStart += groupCount;
		}
	}

	CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

	/**
	 * @author abelnation / http://github.com/abelnation
	 */

	// ConeGeometry

	function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
		CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);

		this.type = 'ConeGeometry';

		this.parameters = {
			radius,
			height,
			radialSegments,
			heightSegments,
			openEnded,
			thetaStart,
			thetaLength,
		};
	}

	ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
	ConeGeometry.prototype.constructor = ConeGeometry;

	// ConeBufferGeometry

	function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
		CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);

		this.type = 'ConeBufferGeometry';

		this.parameters = {
			radius,
			height,
			radialSegments,
			heightSegments,
			openEnded,
			thetaStart,
			thetaLength,
		};
	}

	ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
	ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author hughes
	 */

	// CircleGeometry

	function CircleGeometry(radius, segments, thetaStart, thetaLength) {
		Geometry.call(this);

		this.type = 'CircleGeometry';

		this.parameters = {
			radius,
			segments,
			thetaStart,
			thetaLength,
		};

		this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
		this.mergeVertices();
	}

	CircleGeometry.prototype = Object.create(Geometry.prototype);
	CircleGeometry.prototype.constructor = CircleGeometry;

	// CircleBufferGeometry

	function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
		BufferGeometry.call(this);

		this.type = 'CircleBufferGeometry';

		this.parameters = {
			radius,
			segments,
			thetaStart,
			thetaLength,
		};

		radius = radius || 1;
		segments = segments !== undefined ? Math.max(3, segments) : 8;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let i; let
			s;
		const vertex = new Vector3();
		const uv = new Vector2();

		// center point

		vertices.push(0, 0, 0);
		normals.push(0, 0, 1);
		uvs.push(0.5, 0.5);

		for (s = 0, i = 3; s <= segments; s++, i += 3) {
			const segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos(segment);
			vertex.y = radius * Math.sin(segment);

			vertices.push(vertex.x, vertex.y, vertex.z);

			// normal

			normals.push(0, 0, 1);

			// uvs

			uv.x = (vertices[i] / radius + 1) / 2;
			uv.y = (vertices[i + 1] / radius + 1) / 2;

			uvs.push(uv.x, uv.y);
		}

		// indices

		for (i = 1; i <= segments; i++) {
			indices.push(i, i + 1, 0);
		}

		// build geometry

		this.setIndex(indices);
		this.addAttribute('position', new Float32BufferAttribute(vertices, 3));
		this.addAttribute('normal', new Float32BufferAttribute(normals, 3));
		this.addAttribute('uv', new Float32BufferAttribute(uvs, 2));
	}

	CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;


	const Geometries = /* #__PURE__ */Object.freeze({
		WireframeGeometry,
		ParametricGeometry,
		ParametricBufferGeometry,
		TetrahedronGeometry,
		TetrahedronBufferGeometry,
		OctahedronGeometry,
		OctahedronBufferGeometry,
		IcosahedronGeometry,
		IcosahedronBufferGeometry,
		DodecahedronGeometry,
		DodecahedronBufferGeometry,
		PolyhedronGeometry,
		PolyhedronBufferGeometry,
		TubeGeometry,
		TubeBufferGeometry,
		TorusKnotGeometry,
		TorusKnotBufferGeometry,
		TorusGeometry,
		TorusBufferGeometry,
		TextGeometry,
		TextBufferGeometry,
		SphereGeometry,
		SphereBufferGeometry,
		RingGeometry,
		RingBufferGeometry,
		PlaneGeometry,
		PlaneBufferGeometry,
		LatheGeometry,
		LatheBufferGeometry,
		ShapeGeometry,
		ShapeBufferGeometry,
		ExtrudeGeometry,
		ExtrudeBufferGeometry,
		EdgesGeometry,
		ConeGeometry,
		ConeBufferGeometry,
		CylinderGeometry,
		CylinderBufferGeometry,
		CircleGeometry,
		CircleBufferGeometry,
		BoxGeometry,
		BoxBufferGeometry,
	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  color: <THREE.Color>
	 * }
	 */

	function ShadowMaterial(parameters) {
		Material.call(this);

		this.type = 'ShadowMaterial';

		this.color = new Color(0x000000);
		this.transparent = true;

		this.setValues(parameters);
	}

	ShadowMaterial.prototype = Object.create(Material.prototype);
	ShadowMaterial.prototype.constructor = ShadowMaterial;

	ShadowMaterial.prototype.isShadowMaterial = true;

	ShadowMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);

		this.color.copy(source.color);

		return this;
	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function RawShaderMaterial(parameters) {
		ShaderMaterial.call(this, parameters);

		this.type = 'RawShaderMaterial';
	}

	RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
	RawShaderMaterial.prototype.constructor = RawShaderMaterial;

	RawShaderMaterial.prototype.isRawShaderMaterial = true;

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  roughness: <float>,
	 *  metalness: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *  metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  envMapIntensity: <float>
	 *
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshStandardMaterial(parameters) {
		Material.call(this);

		this.defines = { STANDARD: '' };

		this.type = 'MeshStandardMaterial';

		this.color = new Color(0xffffff); // diffuse
		this.roughness = 0.5;
		this.metalness = 0.5;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color(0x000000);
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2(1, 1);

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.roughnessMap = null;

		this.metalnessMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapIntensity = 1.0;

		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues(parameters);
	}

	MeshStandardMaterial.prototype = Object.create(Material.prototype);
	MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

	MeshStandardMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);

		this.defines = { STANDARD: '' };

		this.color.copy(source.color);
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;

		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;
	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  reflectivity: <float>
	 * }
	 */

	function MeshPhysicalMaterial(parameters) {
		MeshStandardMaterial.call(this);

		this.defines = { PHYSICAL: '' };

		this.type = 'MeshPhysicalMaterial';

		this.reflectivity = 0.5; // maps to F0 = 0.04

		this.clearCoat = 0.0;
		this.clearCoatRoughness = 0.0;

		this.setValues(parameters);
	}

	MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
	MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

	MeshPhysicalMaterial.prototype.copy = function (source) {
		MeshStandardMaterial.prototype.copy.call(this, source);

		this.defines = { PHYSICAL: '' };

		this.reflectivity = source.reflectivity;

		this.clearCoat = source.clearCoat;
		this.clearCoatRoughness = source.clearCoatRoughness;

		return this;
	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshPhongMaterial(parameters) {
		Material.call(this);

		this.type = 'MeshPhongMaterial';

		this.color = new Color(0xffffff); // diffuse
		this.specular = new Color(0x111111);
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color(0x000000);
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2(1, 1);

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues(parameters);
	}

	MeshPhongMaterial.prototype = Object.create(Material.prototype);
	MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

	MeshPhongMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);

		this.color.copy(source.color);
		this.specular.copy(source.specular);
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;
	};

	/**
	 * @author takahirox / http://github.com/takahirox
	 *
	 * parameters = {
	 *  gradientMap: new THREE.Texture( <Image> )
	 * }
	 */

	function MeshToonMaterial(parameters) {
		MeshPhongMaterial.call(this);

		this.defines = { TOON: '' };

		this.type = 'MeshToonMaterial';

		this.gradientMap = null;

		this.setValues(parameters);
	}

	MeshToonMaterial.prototype = Object.create(MeshPhongMaterial.prototype);
	MeshToonMaterial.prototype.constructor = MeshToonMaterial;

	MeshToonMaterial.prototype.isMeshToonMaterial = true;

	MeshToonMaterial.prototype.copy = function (source) {
		MeshPhongMaterial.prototype.copy.call(this, source);

		this.gradientMap = source.gradientMap;

		return this;
	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshNormalMaterial(parameters) {
		Material.call(this);

		this.type = 'MeshNormalMaterial';

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2(1, 1);

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;
		this.lights = false;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues(parameters);
	}

	MeshNormalMaterial.prototype = Object.create(Material.prototype);
	MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

	MeshNormalMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;
	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshLambertMaterial(parameters) {
		Material.call(this);

		this.type = 'MeshLambertMaterial';

		this.color = new Color(0xffffff); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color(0x000000);
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues(parameters);
	}

	MeshLambertMaterial.prototype = Object.create(Material.prototype);
	MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

	MeshLambertMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);

		this.color.copy(source.color);

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy(source.emissive);
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;
	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  matcap: new THREE.Texture( <Image> ),
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshMatcapMaterial(parameters) {
		Material.call(this);

		this.defines = { MATCAP: '' };

		this.type = 'MeshMatcapMaterial';

		this.color = new Color(0xffffff); // diffuse

		this.matcap = null;

		this.map = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2(1, 1);

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.lights = false;

		this.setValues(parameters);
	}

	MeshMatcapMaterial.prototype = Object.create(Material.prototype);
	MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;

	MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

	MeshMatcapMaterial.prototype.copy = function (source) {
		Material.prototype.copy.call(this, source);

		this.defines = { MATCAP: '' };

		this.color.copy(source.color);

		this.matcap = source.matcap;

		this.map = source.map;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy(source.normalScale);

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;
	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>
	 * }
	 */

	function LineDashedMaterial(parameters) {
		LineBasicMaterial.call(this);

		this.type = 'LineDashedMaterial';

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.setValues(parameters);
	}

	LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
	LineDashedMaterial.prototype.constructor = LineDashedMaterial;

	LineDashedMaterial.prototype.isLineDashedMaterial = true;

	LineDashedMaterial.prototype.copy = function (source) {
		LineBasicMaterial.prototype.copy.call(this, source);

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;
	};


	const Materials = /* #__PURE__ */Object.freeze({
		ShadowMaterial,
		SpriteMaterial,
		RawShaderMaterial,
		ShaderMaterial,
		PointsMaterial,
		MeshPhysicalMaterial,
		MeshStandardMaterial,
		MeshPhongMaterial,
		MeshToonMaterial,
		MeshNormalMaterial,
		MeshLambertMaterial,
		MeshDepthMaterial,
		MeshDistanceMaterial,
		MeshBasicMaterial,
		MeshMatcapMaterial,
		LineDashedMaterial,
		LineBasicMaterial,
		Material,
	});

	/**
	 * @author tschw
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	var AnimationUtils = {

		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice(array, from, to) {
			if (AnimationUtils.isTypedArray(array)) {
				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
			}

			return array.slice(from, to);
		},

		// converts an array to a specific type
		convertArray(array, type, forceClone) {
			if (!array // let 'undefined' and 'null' pass
				|| !forceClone && array.constructor === type) return array;

			if (typeof type.BYTES_PER_ELEMENT === 'number') {
				return new type(array); // create typed array
			}

			return Array.prototype.slice.call(array); // create Array
		},

		isTypedArray(object) {
			return ArrayBuffer.isView(object)
				&& !(object instanceof DataView);
		},

		// returns an array by which times and values can be sorted
		getKeyframeOrder(times) {
			function compareTime(i, j) {
				return times[i] - times[j];
			}

			const n = times.length;
			const result = new Array(n);
			for (let i = 0; i !== n; ++i) result[i] = i;

			result.sort(compareTime);

			return result;
		},

		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray(values, stride, order) {
			const nValues = values.length;
			const result = new values.constructor(nValues);

			for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
				const srcOffset = order[i] * stride;

				for (let j = 0; j !== stride; ++j) {
					result[dstOffset++] = values[srcOffset + j];
				}
			}

			return result;
		},

		// function for parsing AOS keyframe formats
		flattenJSON(jsonKeys, times, values, valuePropertyName) {
			let i = 1; let
				key = jsonKeys[0];

			while (key !== undefined && key[valuePropertyName] === undefined) {
				key = jsonKeys[i++];
			}

			if (key === undefined) return; // no data

			let value = key[valuePropertyName];
			if (value === undefined) return; // no data

			if (Array.isArray(value)) {
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						values.push.apply(values, value); // push all elements
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			} else if (value.toArray !== undefined) {
				// ...assume THREE.Math-ish

				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						value.toArray(values, values.length);
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			} else {
				// otherwise push as-is

				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						values.push(value);
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			}
		},

	};

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 * @author tschw
	 */

	function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;

		this.resultBuffer = resultBuffer !== undefined
			? resultBuffer : new sampleValues.constructor(sampleSize);
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;
	}

	Object.assign(Interpolant.prototype, {

		evaluate(t) {
			const pp = this.parameterPositions;
			let i1 = this._cachedIndex;

			let t1 = pp[i1];
			let t0 = pp[i1 - 1];

			validate_interval: {
				seek: {
					let right;

					linear_scan: {
						// - See http://jsperf.com/comparison-to-undefined/3
						// - slower code:
						//-
						// - 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if (!(t < t1)) {
							for (var giveUpAt = i1 + 2; ;) {
								if (t1 === undefined) {
									if (t < t0) break forward_scan;

									// after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_(i1 - 1, t, t0);
								}

								if (i1 === giveUpAt) break; // this loop

								t0 = t1;
								t1 = pp[++i1];

								if (t < t1) {
									// we have arrived at the sought interval
									break seek;
								}
							}

							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;
						}

						// - slower code:
						// -					if ( t < t0 || t0 === undefined ) {
						if (!(t >= t0)) {
							// looping?

							const t1global = pp[1];

							if (t < t1global) {
								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;
							}

							// linear reverse scan

							for (var giveUpAt = i1 - 2; ;) {
								if (t0 === undefined) {
									// before start

									this._cachedIndex = 0;
									return this.beforeStart_(0, t, t1);
								}

								if (i1 === giveUpAt) break; // this loop

								t1 = t0;
								t0 = pp[--i1 - 1];

								if (t >= t0) {
									// we have arrived at the sought interval
									break seek;
								}
							}

							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;
						}

						// the interval is valid

						break validate_interval;
					} // linear scan

					// binary search

					while (i1 < right) {
						const mid = (i1 + right) >>> 1;

						if (t < pp[mid]) {
							right = mid;
						} else {
							i1 = mid + 1;
						}
					}

					t1 = pp[i1];
					t0 = pp[i1 - 1];

					// check boundary cases, again

					if (t0 === undefined) {
						this._cachedIndex = 0;
						return this.beforeStart_(0, t, t1);
					}

					if (t1 === undefined) {
						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_(i1 - 1, t0, t);
					}
				} // seek

				this._cachedIndex = i1;

				this.intervalChanged_(i1, t0, t1);
			} // validate_interval

			return this.interpolate_(i1, t0, t, t1);
		},

		settings: null, // optional, subclass-specific settings structure
		// Note: The indirection allows central control of many interpolants.

		// --- Protected interface

		DefaultSettings_: {},

		getSettings_() {
			return this.settings || this.DefaultSettings_;
		},

		copySampleValue_(index) {
			// copies a sample value to the result buffer

			const result = this.resultBuffer;
			const values = this.sampleValues;
			const stride = this.valueSize;
			const offset = index * stride;

			for (let i = 0; i !== stride; ++i) {
				result[i] = values[offset + i];
			}

			return result;
		},

		// Template methods for derived classes:

		interpolate_(/* i1, t0, t, t1 */) {
			throw new Error('call to abstract method');
			// implementations shall return this.resultBuffer
		},

		intervalChanged_(/* i1, t0, t1 */) {

			// empty

		},

	});

	//! \ DECLARE ALIAS AFTER assign prototype !
	Object.assign(Interpolant.prototype, {

		// ( 0, t, t0 ), returns this.resultBuffer
		beforeStart_: Interpolant.prototype.copySampleValue_,

		// ( N-1, tN-1, t ), returns this.resultBuffer
		afterEnd_: Interpolant.prototype.copySampleValue_,

	});

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 *
	 * @author tschw
	 */

	function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);

		this._weightPrev = -0;
		this._offsetPrev = -0;
		this._weightNext = -0;
		this._offsetNext = -0;
	}

	CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {

		constructor: CubicInterpolant,

		DefaultSettings_: {

			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding,

		},

		intervalChanged_(i1, t0, t1) {
			const pp = this.parameterPositions;
			let iPrev = i1 - 2;
			let iNext = i1 + 1;

			let tPrev = pp[iPrev];
			let tNext = pp[iNext];

			if (tPrev === undefined) {
				switch (this.getSettings_().endingStart) {
				case ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[iPrev] - pp[iPrev + 1];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;
				}
			}

			if (tNext === undefined) {
				switch (this.getSettings_().endingEnd) {
				case ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[1] - pp[0];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;
				}
			}

			const halfDt = (t1 - t0) * 0.5;
			const stride = this.valueSize;

			this._weightPrev = halfDt / (t0 - tPrev);
			this._weightNext = halfDt / (tNext - t1);
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;
		},

		interpolate_(i1, t0, t, t1) {
			const result = this.resultBuffer;
			const values = this.sampleValues;
			const stride = this.valueSize;

			const o1 = i1 * stride; const		o0 = o1 - stride;
			const oP = this._offsetPrev; const 	oN = this._offsetNext;
			const wP = this._weightPrev; const	wN = this._weightNext;

			const p = (t - t0) / (t1 - t0);
			const pp = p * p;
			const ppp = pp * p;

			// evaluate polynomials

			const sP = -wP * ppp + 2 * wP * pp - wP * p;
			const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
			const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
			const sN = wN * ppp - wN * pp;

			// combine data linearly

			for (let i = 0; i !== stride; ++i) {
				result[i] =						sP * values[oP + i]
						+ s0 * values[o0 + i]
						+ s1 * values[o1 + i]
						+ sN * values[oN + i];
			}

			return result;
		},

	});

	/**
	 * @author tschw
	 */

	function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
	}

	LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {

		constructor: LinearInterpolant,

		interpolate_(i1, t0, t, t1) {
			const result = this.resultBuffer;
			const values = this.sampleValues;
			const stride = this.valueSize;

			const offset1 = i1 * stride;
			const offset0 = offset1 - stride;

			const weight1 = (t - t0) / (t1 - t0);
			const weight0 = 1 - weight1;

			for (let i = 0; i !== stride; ++i) {
				result[i] =						values[offset0 + i] * weight0
						+ values[offset1 + i] * weight1;
			}

			return result;
		},

	});

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 *
	 * @author tschw
	 */

	function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
	}

	DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {

		constructor: DiscreteInterpolant,

		interpolate_(i1 /* , t0, t, t1 */) {
			return this.copySampleValue_(i1 - 1);
		},

	});

	/**
	 *
	 * A timed sequence of keyframes for a specific property.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function KeyframeTrack(name, times, values, interpolation) {
		if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
		if (times === undefined || times.length === 0) throw new Error(`THREE.KeyframeTrack: no keyframes in track named ${name}`);

		this.name = name;

		this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
		this.values = AnimationUtils.convertArray(values, this.ValueBufferType);

		this.setInterpolation(interpolation || this.DefaultInterpolation);
	}

	// Static methods

	Object.assign(KeyframeTrack, {

		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):

		toJSON(track) {
			const trackType = track.constructor;

			let json;

			// derived classes can define a static toJSON method
			if (trackType.toJSON !== undefined) {
				json = trackType.toJSON(track);
			} else {
				// by default, we assume the data can be serialized as-is
				json = {

					name: track.name,
					times: AnimationUtils.convertArray(track.times, Array),
					values: AnimationUtils.convertArray(track.values, Array),

				};

				const interpolation = track.getInterpolation();

				if (interpolation !== track.DefaultInterpolation) {
					json.interpolation = interpolation;
				}
			}

			json.type = track.ValueTypeName; // mandatory

			return json;
		},

	});

	Object.assign(KeyframeTrack.prototype, {

		constructor: KeyframeTrack,

		TimeBufferType: Float32Array,

		ValueBufferType: Float32Array,

		DefaultInterpolation: InterpolateLinear,

		InterpolantFactoryMethodDiscrete(result) {
			return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
		},

		InterpolantFactoryMethodLinear(result) {
			return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
		},

		InterpolantFactoryMethodSmooth(result) {
			return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
		},

		setInterpolation(interpolation) {
			let factoryMethod;

			switch (interpolation) {
			case InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;
			}

			if (factoryMethod === undefined) {
				const message = `unsupported interpolation for ${
					this.ValueTypeName} keyframe track named ${this.name}`;

				if (this.createInterpolant === undefined) {
					// fall back to default, unless the default itself is messed up
					if (interpolation !== this.DefaultInterpolation) {
						this.setInterpolation(this.DefaultInterpolation);
					} else {
						throw new Error(message); // fatal, in this case
					}
				}

				console.warn('THREE.KeyframeTrack:', message);
				return this;
			}

			this.createInterpolant = factoryMethod;

			return this;
		},

		getInterpolation() {
			switch (this.createInterpolant) {
			case this.InterpolantFactoryMethodDiscrete:

				return InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return InterpolateSmooth;
			}
		},

		getValueSize() {
			return this.values.length / this.times.length;
		},

		// move all keyframes either forwards or backwards in time
		shift(timeOffset) {
			if (timeOffset !== 0.0) {
				const { times } = this;

				for (let i = 0, n = times.length; i !== n; ++i) {
					times[i] += timeOffset;
				}
			}

			return this;
		},

		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale(timeScale) {
			if (timeScale !== 1.0) {
				const { times } = this;

				for (let i = 0, n = times.length; i !== n; ++i) {
					times[i] *= timeScale;
				}
			}

			return this;
		},

		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim(startTime, endTime) {
			const { times } = this;
			const nKeys = times.length;
			let from = 0;
			let to = nKeys - 1;

			while (from !== nKeys && times[from] < startTime) {
				++from;
			}

			while (to !== -1 && times[to] > endTime) {
				--to;
			}

			++to; // inclusive -> exclusive bound

			if (from !== 0 || to !== nKeys) {
				// empty tracks are forbidden, so keep at least one keyframe
				if (from >= to) to = Math.max(to, 1), from = to - 1;

				const stride = this.getValueSize();
				this.times = AnimationUtils.arraySlice(times, from, to);
				this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
			}

			return this;
		},

		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate() {
			let valid = true;

			const valueSize = this.getValueSize();
			if (valueSize - Math.floor(valueSize) !== 0) {
				console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
				valid = false;
			}

			const { times } = this;
			const { values } = this;

			const nKeys = times.length;

			if (nKeys === 0) {
				console.error('THREE.KeyframeTrack: Track is empty.', this);
				valid = false;
			}

			let prevTime = null;

			for (var i = 0; i !== nKeys; i++) {
				const currTime = times[i];

				if (typeof currTime === 'number' && isNaN(currTime)) {
					console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
					valid = false;
					break;
				}

				if (prevTime !== null && prevTime > currTime) {
					console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
					valid = false;
					break;
				}

				prevTime = currTime;
			}

			if (values !== undefined) {
				if (AnimationUtils.isTypedArray(values)) {
					for (var i = 0, n = values.length; i !== n; ++i) {
						const value = values[i];

						if (isNaN(value)) {
							console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
							valid = false;
							break;
						}
					}
				}
			}

			return valid;
		},

		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		optimize() {
			const { times } = this;
			const { values } = this;
			const stride = this.getValueSize();

			const smoothInterpolation = this.getInterpolation() === InterpolateSmooth;

			let writeIndex = 1;
			const lastIndex = times.length - 1;

			for (let i = 1; i < lastIndex; ++i) {
				let keep = false;

				const time = times[i];
				const timeNext = times[i + 1];

				// remove adjacent keyframes scheduled at the same time

				if (time !== timeNext && (i !== 1 || time !== time[0])) {
					if (!smoothInterpolation) {
						// remove unnecessary keyframes same as their neighbors

						const offset = i * stride;
						const offsetP = offset - stride;
						const offsetN = offset + stride;

						for (var j = 0; j !== stride; ++j) {
							const value = values[offset + j];

							if (value !== values[offsetP + j]
								|| value !== values[offsetN + j]) {
								keep = true;
								break;
							}
						}
					} else {
						keep = true;
					}
				}

				// in-place compaction

				if (keep) {
					if (i !== writeIndex) {
						times[writeIndex] = times[i];

						var readOffset = i * stride;
						var writeOffset = writeIndex * stride;

						for (var j = 0; j !== stride; ++j) {
							values[writeOffset + j] = values[readOffset + j];
						}
					}

					++writeIndex;
				}
			}

			// flush last keyframe (compaction looks ahead)

			if (lastIndex > 0) {
				times[writeIndex] = times[lastIndex];

				for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
					values[writeOffset + j] = values[readOffset + j];
				}

				++writeIndex;
			}

			if (writeIndex !== times.length) {
				this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
				this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
			}

			return this;
		},

	});

	/**
	 *
	 * A Track of Boolean keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function BooleanKeyframeTrack(name, times, values) {
		KeyframeTrack.call(this, name, times, values);
	}

	BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {

		constructor: BooleanKeyframeTrack,

		ValueTypeName: 'bool',
		ValueBufferType: Array,

		DefaultInterpolation: InterpolateDiscrete,

		InterpolantFactoryMethodLinear: undefined,
		InterpolantFactoryMethodSmooth: undefined,

		// Note: Actually this track could have a optimized / compressed
		// representation of a single value and a custom interpolant that
		// computes "firstValue ^ isOdd( index )".

	});

	/**
	 *
	 * A Track of keyframe values that represent color.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function ColorKeyframeTrack(name, times, values, interpolation) {
		KeyframeTrack.call(this, name, times, values, interpolation);
	}

	ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {

		constructor: ColorKeyframeTrack,

		ValueTypeName: 'color',

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

		// Note: Very basic implementation and nothing special yet.
		// However, this is the place for color space parameterization.

	});

	/**
	 *
	 * A Track of numeric keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function NumberKeyframeTrack(name, times, values, interpolation) {
		KeyframeTrack.call(this, name, times, values, interpolation);
	}

	NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {

		constructor: NumberKeyframeTrack,

		ValueTypeName: 'number',

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

	});

	/**
	 * Spherical linear unit quaternion interpolant.
	 *
	 * @author tschw
	 */

	function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
	}

	QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {

		constructor: QuaternionLinearInterpolant,

		interpolate_(i1, t0, t, t1) {
			const result = this.resultBuffer;
			const values = this.sampleValues;
			const stride = this.valueSize;

			let offset = i1 * stride;

			const alpha = (t - t0) / (t1 - t0);

			for (let end = offset + stride; offset !== end; offset += 4) {
				Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
			}

			return result;
		},

	});

	/**
	 *
	 * A Track of quaternion keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function QuaternionKeyframeTrack(name, times, values, interpolation) {
		KeyframeTrack.call(this, name, times, values, interpolation);
	}

	QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {

		constructor: QuaternionKeyframeTrack,

		ValueTypeName: 'quaternion',

		// ValueBufferType is inherited

		DefaultInterpolation: InterpolateLinear,

		InterpolantFactoryMethodLinear(result) {
			return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
		},

		InterpolantFactoryMethodSmooth: undefined, // not yet implemented

	});

	/**
	 *
	 * A Track that interpolates Strings
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function StringKeyframeTrack(name, times, values, interpolation) {
		KeyframeTrack.call(this, name, times, values, interpolation);
	}

	StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {

		constructor: StringKeyframeTrack,

		ValueTypeName: 'string',
		ValueBufferType: Array,

		DefaultInterpolation: InterpolateDiscrete,

		InterpolantFactoryMethodLinear: undefined,

		InterpolantFactoryMethodSmooth: undefined,

	});

	/**
	 *
	 * A Track of vectored keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function VectorKeyframeTrack(name, times, values, interpolation) {
		KeyframeTrack.call(this, name, times, values, interpolation);
	}

	VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {

		constructor: VectorKeyframeTrack,

		ValueTypeName: 'vector',

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

	});

	/**
	 *
	 * Reusable set of Tracks that represent an animation.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	function AnimationClip(name, duration, tracks) {
		this.name = name;
		this.tracks = tracks;
		this.duration = (duration !== undefined) ? duration : -1;

		this.uuid = _Math.generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if (this.duration < 0) {
			this.resetDuration();
		}
	}

	function getTrackTypeForValueTypeName(typeName) {
		switch (typeName.toLowerCase()) {
		case 'scalar':
		case 'double':
		case 'float':
		case 'number':
		case 'integer':

			return NumberKeyframeTrack;

		case 'vector':
		case 'vector2':
		case 'vector3':
		case 'vector4':

			return VectorKeyframeTrack;

		case 'color':

			return ColorKeyframeTrack;

		case 'quaternion':

			return QuaternionKeyframeTrack;

		case 'bool':
		case 'boolean':

			return BooleanKeyframeTrack;

		case 'string':

			return StringKeyframeTrack;
		}

		throw new Error(`THREE.KeyframeTrack: Unsupported typeName: ${typeName}`);
	}

	function parseKeyframeTrack(json) {
		if (json.type === undefined) {
			throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
		}

		const trackType = getTrackTypeForValueTypeName(json.type);

		if (json.times === undefined) {
			const times = []; const
				values = [];

			AnimationUtils.flattenJSON(json.keys, times, values, 'value');

			json.times = times;
			json.values = values;
		}

		// derived classes can define a static parse method
		if (trackType.parse !== undefined) {
			return trackType.parse(json);
		}

		// by default, we assume a constructor compatible with the base
		return new trackType(json.name, json.times, json.values, json.interpolation);
	}

	Object.assign(AnimationClip, {

		parse(json) {
			const tracks = [];
			const jsonTracks = json.tracks;
			const frameTime = 1.0 / (json.fps || 1.0);

			for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
				tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
			}

			return new AnimationClip(json.name, json.duration, tracks);
		},

		toJSON(clip) {
			const tracks = [];
			const clipTracks = clip.tracks;

			const json = {

				name: clip.name,
				duration: clip.duration,
				tracks,
				uuid: clip.uuid,

			};

			for (let i = 0, n = clipTracks.length; i !== n; ++i) {
				tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
			}

			return json;
		},

		CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
			const numMorphTargets = morphTargetSequence.length;
			const tracks = [];

			for (let i = 0; i < numMorphTargets; i++) {
				let times = [];
				let values = [];

				times.push(
					(i + numMorphTargets - 1) % numMorphTargets,
					i,
					(i + 1) % numMorphTargets,
				);

				values.push(0, 1, 0);

				const order = AnimationUtils.getKeyframeOrder(times);
				times = AnimationUtils.sortedArray(times, 1, order);
				values = AnimationUtils.sortedArray(values, 1, order);

				// if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.
				if (!noLoop && times[0] === 0) {
					times.push(numMorphTargets);
					values.push(values[0]);
				}

				tracks.push(
					new NumberKeyframeTrack(
						`.morphTargetInfluences[${morphTargetSequence[i].name}]`,
						times, values,
					).scale(1.0 / fps),
				);
			}

			return new AnimationClip(name, -1, tracks);
		},

		findByName(objectOrClipArray, name) {
			let clipArray = objectOrClipArray;

			if (!Array.isArray(objectOrClipArray)) {
				const o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;
			}

			for (let i = 0; i < clipArray.length; i++) {
				if (clipArray[i].name === name) {
					return clipArray[i];
				}
			}

			return null;
		},

		CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
			const animationToMorphTargets = {};

			// tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
			const pattern = /^([\w-]*?)([\d]+)$/;

			// sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002
			for (let i = 0, il = morphTargets.length; i < il; i++) {
				const morphTarget = morphTargets[i];
				const parts = morphTarget.name.match(pattern);

				if (parts && parts.length > 1) {
					var name = parts[1];

					let animationMorphTargets = animationToMorphTargets[name];
					if (!animationMorphTargets) {
						animationToMorphTargets[name] = animationMorphTargets = [];
					}

					animationMorphTargets.push(morphTarget);
				}
			}

			const clips = [];

			for (var name in animationToMorphTargets) {
				clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
			}

			return clips;
		},

		// parse the animation.hierarchy format
		parseAnimation(animation, bones) {
			if (!animation) {
				console.error('THREE.AnimationClip: No animation in JSONLoader data.');
				return null;
			}

			const addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
				// only return track if there are actually keys.
				if (animationKeys.length !== 0) {
					const times = [];
					const values = [];

					AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);

					// empty keys are filtered out, so check again
					if (times.length !== 0) {
						destTracks.push(new trackType(trackName, times, values));
					}
				}
			};

			const tracks = [];

			const clipName = animation.name || 'default';
			// automatic length determination in AnimationClip.
			let duration = animation.length || -1;
			const fps = animation.fps || 30;

			const hierarchyTracks = animation.hierarchy || [];

			for (let h = 0; h < hierarchyTracks.length; h++) {
				const animationKeys = hierarchyTracks[h].keys;

				// skip empty tracks
				if (!animationKeys || animationKeys.length === 0) continue;

				// process morph targets
				if (animationKeys[0].morphTargets) {
					// figure out all morph targets used in this track
					const morphTargetNames = {};

					for (var k = 0; k < animationKeys.length; k++) {
						if (animationKeys[k].morphTargets) {
							for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
								morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
							}
						}
					}

					// create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.
					for (const morphTargetName in morphTargetNames) {
						const times = [];
						const values = [];

						for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
							const animationKey = animationKeys[k];

							times.push(animationKey.time);
							values.push((animationKey.morphTarget === morphTargetName) ? 1 : 0);
						}

						tracks.push(new NumberKeyframeTrack(`.morphTargetInfluence[${morphTargetName}]`, times, values));
					}

					duration = morphTargetNames.length * (fps || 1.0);
				} else {
					// ...assume skeletal animation

					const boneName = `.bones[${bones[h].name}]`;

					addNonemptyTrack(
						VectorKeyframeTrack, `${boneName}.position`,
						animationKeys, 'pos', tracks,
					);

					addNonemptyTrack(
						QuaternionKeyframeTrack, `${boneName}.quaternion`,
						animationKeys, 'rot', tracks,
					);

					addNonemptyTrack(
						VectorKeyframeTrack, `${boneName}.scale`,
						animationKeys, 'scl', tracks,
					);
				}
			}

			if (tracks.length === 0) {
				return null;
			}

			const clip = new AnimationClip(clipName, duration, tracks);

			return clip;
		},

	});

	Object.assign(AnimationClip.prototype, {

		resetDuration() {
			const { tracks } = this;
			let duration = 0;

			for (let i = 0, n = tracks.length; i !== n; ++i) {
				const track = this.tracks[i];

				duration = Math.max(duration, track.times[track.times.length - 1]);
			}

			this.duration = duration;

			return this;
		},

		trim() {
			for (let i = 0; i < this.tracks.length; i++) {
				this.tracks[i].trim(0, this.duration);
			}

			return this;
		},

		validate() {
			let valid = true;

			for (let i = 0; i < this.tracks.length; i++) {
				valid = valid && this.tracks[i].validate();
			}

			return valid;
		},

		optimize() {
			for (let i = 0; i < this.tracks.length; i++) {
				this.tracks[i].optimize();
			}

			return this;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	const Cache = {

		enabled: false,

		files: {},

		add(key, file) {
			if (this.enabled === false) return;

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[key] = file;
		},

		get(key) {
			if (this.enabled === false) return;

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[key];
		},

		remove(key) {
			delete this.files[key];
		},

		clear() {
			this.files = {};
		},

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LoadingManager(onLoad, onProgress, onError) {
		const scope = this;

		let isLoading = false;
		let itemsLoaded = 0;
		let itemsTotal = 0;
		let urlModifier;

		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function (url) {
			itemsTotal++;

			if (isLoading === false) {
				if (scope.onStart !== undefined) {
					scope.onStart(url, itemsLoaded, itemsTotal);
				}
			}

			isLoading = true;
		};

		this.itemEnd = function (url) {
			itemsLoaded++;

			if (scope.onProgress !== undefined) {
				scope.onProgress(url, itemsLoaded, itemsTotal);
			}

			if (itemsLoaded === itemsTotal) {
				isLoading = false;

				if (scope.onLoad !== undefined) {
					scope.onLoad();
				}
			}
		};

		this.itemError = function (url) {
			if (scope.onError !== undefined) {
				scope.onError(url);
			}
		};

		this.resolveURL = function (url) {
			if (urlModifier) {
				return urlModifier(url);
			}

			return url;
		};

		this.setURLModifier = function (transform) {
			urlModifier = transform;
			return this;
		};
	}

	const DefaultLoadingManager = new LoadingManager();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	const loading = {};

	function FileLoader(manager) {
		this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
	}

	Object.assign(FileLoader.prototype, {

		load(url, onLoad, onProgress, onError) {
			if (url === undefined) url = '';

			if (this.path !== undefined) url = this.path + url;

			url = this.manager.resolveURL(url);

			const scope = this;

			const cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);

				setTimeout(() => {
					if (onLoad) onLoad(cached);

					scope.manager.itemEnd(url);
				}, 0);

				return cached;
			}

			// Check if request is duplicate

			if (loading[url] !== undefined) {
				loading[url].push({

					onLoad,
					onProgress,
					onError,

				});

				return;
			}

			// Check for data: URI
			const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
			const dataUriRegexResult = url.match(dataUriRegex);

			// Safari can not handle Data URIs through XMLHttpRequest so process manually
			if (dataUriRegexResult) {
				const mimeType = dataUriRegexResult[1];
				const isBase64 = !!dataUriRegexResult[2];
				let data = dataUriRegexResult[3];

				data = decodeURIComponent(data);

				if (isBase64) data = atob(data);

				try {
					let response;
					const responseType = (this.responseType || '').toLowerCase();

					switch (responseType) {
					case 'arraybuffer':
					case 'blob':

						var view = new Uint8Array(data.length);

						for (let i = 0; i < data.length; i++) {
							view[i] = data.charCodeAt(i);
						}

						if (responseType === 'blob') {
							response = new Blob([view.buffer], { type: mimeType });
						} else {
							response = view.buffer;
						}

						break;

					case 'document':

						var parser = new DOMParser();
						response = parser.parseFromString(data, mimeType);

						break;

					case 'json':

						response = JSON.parse(data);

						break;

					default: // 'text' or other

						response = data;

						break;
					}

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout(() => {
						if (onLoad) onLoad(response);

						scope.manager.itemEnd(url);
					}, 0);
				} catch (error) {
					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout(() => {
						if (onError) onError(error);

						scope.manager.itemError(url);
						scope.manager.itemEnd(url);
					}, 0);
				}
			} else {
				// Initialise array for duplicate requests

				loading[url] = [];

				loading[url].push({

					onLoad,
					onProgress,
					onError,

				});

				var request = new XMLHttpRequest();

				request.open('GET', url, true);

				request.addEventListener('load', function (event) {
					const { response } = this;

					Cache.add(url, response);

					const callbacks = loading[url];

					delete loading[url];

					if (this.status === 200 || this.status === 0) {
						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.

						if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.');

						for (var i = 0, il = callbacks.length; i < il; i++) {
							var callback = callbacks[i];
							if (callback.onLoad) callback.onLoad(response);
						}

						scope.manager.itemEnd(url);
					} else {
						for (var i = 0, il = callbacks.length; i < il; i++) {
							var callback = callbacks[i];
							if (callback.onError) callback.onError(event);
						}

						scope.manager.itemError(url);
						scope.manager.itemEnd(url);
					}
				}, false);

				request.addEventListener('progress', (event) => {
					const callbacks = loading[url];

					for (let i = 0, il = callbacks.length; i < il; i++) {
						const callback = callbacks[i];
						if (callback.onProgress) callback.onProgress(event);
					}
				}, false);

				request.addEventListener('error', (event) => {
					const callbacks = loading[url];

					delete loading[url];

					for (let i = 0, il = callbacks.length; i < il; i++) {
						const callback = callbacks[i];
						if (callback.onError) callback.onError(event);
					}

					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				}, false);

				request.addEventListener('abort', (event) => {
					const callbacks = loading[url];

					delete loading[url];

					for (let i = 0, il = callbacks.length; i < il; i++) {
						const callback = callbacks[i];
						if (callback.onError) callback.onError(event);
					}

					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				}, false);

				if (this.responseType !== undefined) request.responseType = this.responseType;
				if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;

				if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

				for (const header in this.requestHeader) {
					request.setRequestHeader(header, this.requestHeader[header]);
				}

				request.send(null);
			}

			scope.manager.itemStart(url);

			return request;
		},

		setPath(value) {
			this.path = value;
			return this;
		},

		setResponseType(value) {
			this.responseType = value;
			return this;
		},

		setWithCredentials(value) {
			this.withCredentials = value;
			return this;
		},

		setMimeType(value) {
			this.mimeType = value;
			return this;
		},

		setRequestHeader(value) {
			this.requestHeader = value;
			return this;
		},

	});

	/**
	 * @author bhouston / http://clara.io/
	 */

	function AnimationLoader(manager) {
		this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
	}

	Object.assign(AnimationLoader.prototype, {

		load(url, onLoad, onProgress, onError) {
			const scope = this;

			const loader = new FileLoader(scope.manager);
			loader.setPath(scope.path);
			loader.load(url, (text) => {
				onLoad(scope.parse(JSON.parse(text)));
			}, onProgress, onError);
		},

		parse(json, onLoad) {
			const animations = [];

			for (let i = 0; i < json.length; i++) {
				const clip = AnimationClip.parse(json[i]);

				animations.push(clip);
			}

			onLoad(animations);
		},

		setPath(value) {
			this.path = value;
			return this;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */

	function CompressedTextureLoader(manager) {
		this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;

		// override in sub classes
		this._parser = null;
	}

	Object.assign(CompressedTextureLoader.prototype, {

		load(url, onLoad, onProgress, onError) {
			const scope = this;

			const images = [];

			const texture = new CompressedTexture();
			texture.image = images;

			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setResponseType('arraybuffer');

			function loadTexture(i) {
				loader.load(url[i], (buffer) => {
					const texDatas = scope._parser(buffer, true);

					images[i] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps,
					};

					loaded += 1;

					if (loaded === 6) {
						if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if (onLoad) onLoad(texture);
					}
				}, onProgress, onError);
			}

			if (Array.isArray(url)) {
				var loaded = 0;

				for (let i = 0, il = url.length; i < il; ++i) {
					loadTexture(i);
				}
			} else {
				// compressed cubemap texture stored in a single DDS file

				loader.load(url, (buffer) => {
					const texDatas = scope._parser(buffer, true);

					if (texDatas.isCubemap) {
						const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for (let f = 0; f < faces; f++) {
							images[f] = { mipmaps: [] };

							for (let i = 0; i < texDatas.mipmapCount; i++) {
								images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
								images[f].format = texDatas.format;
								images[f].width = texDatas.width;
								images[f].height = texDatas.height;
							}
						}
					} else {
						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;
					}

					if (texDatas.mipmapCount === 1) {
						texture.minFilter = LinearFilter;
					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if (onLoad) onLoad(texture);
				}, onProgress, onError);
			}

			return texture;
		},

		setPath(value) {
			this.path = value;
			return this;
		},

	});

	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */

	function DataTextureLoader(manager) {
		this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;

		// override in sub classes
		this._parser = null;
	}

	Object.assign(DataTextureLoader.prototype, {

		load(url, onLoad, onProgress, onError) {
			const scope = this;

			const texture = new DataTexture();

			const loader = new FileLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.setPath(this.path);
			loader.load(url, (buffer) => {
				const texData = scope._parser(buffer);

				if (!texData) return;

				if (texData.image !== undefined) {
					texture.image = texData.image;
				} else if (texData.data !== undefined) {
					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;
				}

				texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

				texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
				texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearMipMapLinearFilter;

				texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

				if (texData.format !== undefined) {
					texture.format = texData.format;
				}
				if (texData.type !== undefined) {
					texture.type = texData.type;
				}

				if (texData.mipmaps !== undefined) {
					texture.mipmaps = texData.mipmaps;
				}

				if (texData.mipmapCount === 1) {
					texture.minFilter = LinearFilter;
				}

				texture.needsUpdate = true;

				if (onLoad) onLoad(texture, texData);
			}, onProgress, onError);


			return texture;
		},

		setPath(value) {
			this.path = value;
			return this;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function ImageLoader(manager) {
		this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
	}

	Object.assign(ImageLoader.prototype, {

		crossOrigin: 'anonymous',

		load(url, onLoad, onProgress, onError) {
			if (url === undefined) url = '';

			if (this.path !== undefined) url = this.path + url;

			url = this.manager.resolveURL(url);

			const scope = this;

			const cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);

				setTimeout(() => {
					if (onLoad) onLoad(cached);

					scope.manager.itemEnd(url);
				}, 0);

				return cached;
			}

			const image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');

			function onImageLoad() {
				image.removeEventListener('load', onImageLoad, false);
				image.removeEventListener('error', onImageError, false);

				Cache.add(url, this);

				if (onLoad) onLoad(this);

				scope.manager.itemEnd(url);
			}

			function onImageError(event) {
				image.removeEventListener('load', onImageLoad, false);
				image.removeEventListener('error', onImageError, false);

				if (onError) onError(event);

				scope.manager.itemError(url);
				scope.manager.itemEnd(url);
			}

			image.addEventListener('load', onImageLoad, false);
			image.addEventListener('error', onImageError, false);

			if (url.substr(0, 5) !== 'data:') {
				if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
			}

			scope.manager.itemStart(url);

			image.src = url;

			return image;
		},

		setCrossOrigin(value) {
			this.crossOrigin = value;
			return this;
		},

		setPath(value) {
			this.path = value;
			return this;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function CubeTextureLoader(manager) {
		this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
	}

	Object.assign(CubeTextureLoader.prototype, {

		crossOrigin: 'anonymous',

		load(urls, onLoad, onProgress, onError) {
			const texture = new CubeTexture();

			const loader = new ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			loader.setPath(this.path);

			let loaded = 0;

			function loadTexture(i) {
				loader.load(urls[i], (image) => {
					texture.images[i] = image;

					loaded++;

					if (loaded === 6) {
						texture.needsUpdate = true;

						if (onLoad) onLoad(texture);
					}
				}, undefined, onError);
			}

			for (let i = 0; i < urls.length; ++i) {
				loadTexture(i);
			}

			return texture;
		},

		setCrossOrigin(value) {
			this.crossOrigin = value;
			return this;
		},

		setPath(value) {
			this.path = value;
			return this;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function TextureLoader(manager) {
		this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
	}

	Object.assign(TextureLoader.prototype, {

		crossOrigin: 'anonymous',

		load(url, onLoad, onProgress, onError) {
			const texture = new Texture();

			const loader = new ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			loader.setPath(this.path);

			loader.load(url, (image) => {
				texture.image = image;

				// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
				const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;

				texture.format = isJPEG ? RGBFormat : RGBAFormat;
				texture.needsUpdate = true;

				if (onLoad !== undefined) {
					onLoad(texture);
				}
			}, onProgress, onError);

			return texture;
		},

		setCrossOrigin(value) {
			this.crossOrigin = value;
			return this;
		},

		setPath(value) {
			this.path = value;
			return this;
		},

	});

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 * */

	/** ************************************************************
	 *	Abstract Curve base class
	 ************************************************************* */

	function Curve() {
		this.type = 'Curve';

		this.arcLengthDivisions = 200;
	}

	Object.assign(Curve.prototype, {

		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]

		getPoint(/* t, optionalTarget */) {
			console.warn('THREE.Curve: .getPoint() not implemented.');
			return null;
		},

		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]

		getPointAt(u, optionalTarget) {
			const t = this.getUtoTmapping(u);
			return this.getPoint(t, optionalTarget);
		},

		// Get sequence of points using getPoint( t )

		getPoints(divisions) {
			if (divisions === undefined) divisions = 5;

			const points = [];

			for (let d = 0; d <= divisions; d++) {
				points.push(this.getPoint(d / divisions));
			}

			return points;
		},

		// Get sequence of points using getPointAt( u )

		getSpacedPoints(divisions) {
			if (divisions === undefined) divisions = 5;

			const points = [];

			for (let d = 0; d <= divisions; d++) {
				points.push(this.getPointAt(d / divisions));
			}

			return points;
		},

		// Get total curve arc length

		getLength() {
			const lengths = this.getLengths();
			return lengths[lengths.length - 1];
		},

		// Get list of cumulative segment lengths

		getLengths(divisions) {
			if (divisions === undefined) divisions = this.arcLengthDivisions;

			if (this.cacheArcLengths
				&& (this.cacheArcLengths.length === divisions + 1)
				&& !this.needsUpdate) {
				return this.cacheArcLengths;
			}

			this.needsUpdate = false;

			const cache = [];
			let current; let
				last = this.getPoint(0);
			let p; let
				sum = 0;

			cache.push(0);

			for (p = 1; p <= divisions; p++) {
				current = this.getPoint(p / divisions);
				sum += current.distanceTo(last);
				cache.push(sum);
				last = current;
			}

			this.cacheArcLengths = cache;

			return cache; // { sums: cache, sum: sum }; Sum is in the last element.
		},

		updateArcLengths() {
			this.needsUpdate = true;
			this.getLengths();
		},

		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

		getUtoTmapping(u, distance) {
			const arcLengths = this.getLengths();

			let i = 0; const
				il = arcLengths.length;

			let targetArcLength; // The targeted u distance value to get

			if (distance) {
				targetArcLength = distance;
			} else {
				targetArcLength = u * arcLengths[il - 1];
			}

			// binary search for the index with largest value smaller than target u distance

			let low = 0; let high = il - 1; let
				comparison;

			while (low <= high) {
				i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[i] - targetArcLength;

				if (comparison < 0) {
					low = i + 1;
				} else if (comparison > 0) {
					high = i - 1;
				} else {
					high = i;
					break;

					// DONE
				}
			}

			i = high;

			if (arcLengths[i] === targetArcLength) {
				return i / (il - 1);
			}

			// we could get finer grain at lengths, or use simple interpolation between two points

			const lengthBefore = arcLengths[i];
			const lengthAfter = arcLengths[i + 1];

			const segmentLength = lengthAfter - lengthBefore;

			// determine where we are between the 'before' and 'after' points

			const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;

			// add that fractional amount to t

			const t = (i + segmentFraction) / (il - 1);

			return t;
		},

		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation

		getTangent(t) {
			const delta = 0.0001;
			let t1 = t - delta;
			let t2 = t + delta;

			// Capping in case of danger

			if (t1 < 0) t1 = 0;
			if (t2 > 1) t2 = 1;

			const pt1 = this.getPoint(t1);
			const pt2 = this.getPoint(t2);

			const vec = pt2.clone().sub(pt1);
			return vec.normalize();
		},

		getTangentAt(u) {
			const t = this.getUtoTmapping(u);
			return this.getTangent(t);
		},

		computeFrenetFrames(segments, closed) {
			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

			const normal = new Vector3();

			const tangents = [];
			const normals = [];
			const binormals = [];

			const vec = new Vector3();
			const mat = new Matrix4();

			let i; let u; let
				theta;

			// compute the tangent vectors for each segment on the curve

			for (i = 0; i <= segments; i++) {
				u = i / segments;

				tangents[i] = this.getTangentAt(u);
				tangents[i].normalize();
			}

			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component

			normals[0] = new Vector3();
			binormals[0] = new Vector3();
			let min = Number.MAX_VALUE;
			const tx = Math.abs(tangents[0].x);
			const ty = Math.abs(tangents[0].y);
			const tz = Math.abs(tangents[0].z);

			if (tx <= min) {
				min = tx;
				normal.set(1, 0, 0);
			}

			if (ty <= min) {
				min = ty;
				normal.set(0, 1, 0);
			}

			if (tz <= min) {
				normal.set(0, 0, 1);
			}

			vec.crossVectors(tangents[0], normal).normalize();

			normals[0].crossVectors(tangents[0], vec);
			binormals[0].crossVectors(tangents[0], normals[0]);


			// compute the slowly-varying normal and binormal vectors for each segment on the curve

			for (i = 1; i <= segments; i++) {
				normals[i] = normals[i - 1].clone();

				binormals[i] = binormals[i - 1].clone();

				vec.crossVectors(tangents[i - 1], tangents[i]);

				if (vec.length() > Number.EPSILON) {
					vec.normalize();

					theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors

					normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
				}

				binormals[i].crossVectors(tangents[i], normals[i]);
			}

			// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

			if (closed === true) {
				theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));
				theta /= segments;

				if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
					theta = -theta;
				}

				for (i = 1; i <= segments; i++) {
					// twist a little...
					normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
					binormals[i].crossVectors(tangents[i], normals[i]);
				}
			}

			return {
				tangents,
				normals,
				binormals,
			};
		},

		clone() {
			return new this.constructor().copy(this);
		},

		copy(source) {
			this.arcLengthDivisions = source.arcLengthDivisions;

			return this;
		},

		toJSON() {
			const data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON',
				},
			};

			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;

			return data;
		},

		fromJSON(json) {
			this.arcLengthDivisions = json.arcLengthDivisions;

			return this;
		},

	});

	function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
		Curve.call(this);

		this.type = 'EllipseCurve';

		this.aX = aX || 0;
		this.aY = aY || 0;

		this.xRadius = xRadius || 1;
		this.yRadius = yRadius || 1;

		this.aStartAngle = aStartAngle || 0;
		this.aEndAngle = aEndAngle || 2 * Math.PI;

		this.aClockwise = aClockwise || false;

		this.aRotation = aRotation || 0;
	}

	EllipseCurve.prototype = Object.create(Curve.prototype);
	EllipseCurve.prototype.constructor = EllipseCurve;

	EllipseCurve.prototype.isEllipseCurve = true;

	EllipseCurve.prototype.getPoint = function (t, optionalTarget) {
		const point = optionalTarget || new Vector2();

		const twoPi = Math.PI * 2;
		let deltaAngle = this.aEndAngle - this.aStartAngle;
		const samePoints = Math.abs(deltaAngle) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while (deltaAngle < 0) deltaAngle += twoPi;
		while (deltaAngle > twoPi) deltaAngle -= twoPi;

		if (deltaAngle < Number.EPSILON) {
			if (samePoints) {
				deltaAngle = 0;
			} else {
				deltaAngle = twoPi;
			}
		}

		if (this.aClockwise === true && !samePoints) {
			if (deltaAngle === twoPi) {
				deltaAngle = -twoPi;
			} else {
				deltaAngle -= twoPi;
			}
		}

		const angle = this.aStartAngle + t * deltaAngle;
		let x = this.aX + this.xRadius * Math.cos(angle);
		let y = this.aY + this.yRadius * Math.sin(angle);

		if (this.aRotation !== 0) {
			const cos = Math.cos(this.aRotation);
			const sin = Math.sin(this.aRotation);

			const tx = x - this.aX;
			const ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;
		}

		return point.set(x, y);
	};

	EllipseCurve.prototype.copy = function (source) {
		Curve.prototype.copy.call(this, source);

		this.aX = source.aX;
		this.aY = source.aY;

		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;

		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;

		this.aClockwise = source.aClockwise;

		this.aRotation = source.aRotation;

		return this;
	};


	EllipseCurve.prototype.toJSON = function () {
		const data = Curve.prototype.toJSON.call(this);

		data.aX = this.aX;
		data.aY = this.aY;

		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;

		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;

		data.aClockwise = this.aClockwise;

		data.aRotation = this.aRotation;

		return data;
	};

	EllipseCurve.prototype.fromJSON = function (json) {
		Curve.prototype.fromJSON.call(this, json);

		this.aX = json.aX;
		this.aY = json.aY;

		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;

		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;

		this.aClockwise = json.aClockwise;

		this.aRotation = json.aRotation;

		return this;
	};

	function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
		EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);

		this.type = 'ArcCurve';
	}

	ArcCurve.prototype = Object.create(EllipseCurve.prototype);
	ArcCurve.prototype.constructor = ArcCurve;

	ArcCurve.prototype.isArcCurve = true;

	/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */


	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {
		let c0 = 0; let c1 = 0; let c2 = 0; let
			c3 = 0;

		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		function init(x0, x1, t0, t1) {
			c0 = x0;
			c1 = t0;
			c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;
		}

		return {

			initCatmullRom(x0, x1, x2, x3, tension) {
				init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
			},

			initNonuniformCatmullRom(x0, x1, x2, x3, dt0, dt1, dt2) {
				// compute tangents when parameterized in [t1,t2]
				let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
				let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;

				// rescale tangents for parametrization in [0,1]
				t1 *= dt1;
				t2 *= dt1;

				init(x1, x2, t1, t2);
			},

			calc(t) {
				const t2 = t * t;
				const t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;
			},

		};
	}

	//

	const tmp = new Vector3();
	const px = new CubicPoly(); const py = new CubicPoly(); const
		pz = new CubicPoly();

	function CatmullRomCurve3(points, closed, curveType, tension) {
		Curve.call(this);

		this.type = 'CatmullRomCurve3';

		this.points = points || [];
		this.closed = closed || false;
		this.curveType = curveType || 'centripetal';
		this.tension = tension || 0.5;
	}

	CatmullRomCurve3.prototype = Object.create(Curve.prototype);
	CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

	CatmullRomCurve3.prototype.getPoint = function (t, optionalTarget) {
		const point = optionalTarget || new Vector3();

		const { points } = this;
		const l = points.length;

		const p = (l - (this.closed ? 0 : 1)) * t;
		let intPoint = Math.floor(p);
		let weight = p - intPoint;

		if (this.closed) {
			intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
		} else if (weight === 0 && intPoint === l - 1) {
			intPoint = l - 2;
			weight = 1;
		}

		let p0; let p1; let p2; let
			p3; // 4 points

		if (this.closed || intPoint > 0) {
			p0 = points[(intPoint - 1) % l];
		} else {
			// extrapolate first point
			tmp.subVectors(points[0], points[1]).add(points[0]);
			p0 = tmp;
		}

		p1 = points[intPoint % l];
		p2 = points[(intPoint + 1) % l];

		if (this.closed || intPoint + 2 < l) {
			p3 = points[(intPoint + 2) % l];
		} else {
			// extrapolate last point
			tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
			p3 = tmp;
		}

		if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
			// init Centripetal / Chordal Catmull-Rom
			const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
			let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
			let dt2 = Math.pow(p2.distanceToSquared(p3), pow);

			// safety check for repeated points
			if (dt1 < 1e-4) dt1 = 1.0;
			if (dt0 < 1e-4) dt0 = dt1;
			if (dt2 < 1e-4) dt2 = dt1;

			px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
			py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
			pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
		} else if (this.curveType === 'catmullrom') {
			px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
			py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
			pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
		}

		point.set(
			px.calc(weight),
			py.calc(weight),
			pz.calc(weight),
		);

		return point;
	};

	CatmullRomCurve3.prototype.copy = function (source) {
		Curve.prototype.copy.call(this, source);

		this.points = [];

		for (let i = 0, l = source.points.length; i < l; i++) {
			const point = source.points[i];

			this.points.push(point.clone());
		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;

		return this;
	};

	CatmullRomCurve3.prototype.toJSON = function () {
		const data = Curve.prototype.toJSON.call(this);

		data.points = [];

		for (let i = 0, l = this.points.length; i < l; i++) {
			const point = this.points[i];
			data.points.push(point.toArray());
		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;

		return data;
	};

	CatmullRomCurve3.prototype.fromJSON = function (json) {
		Curve.prototype.fromJSON.call(this, json);

		this.points = [];

		for (let i = 0, l = json.points.length; i < l; i++) {
			const point = json.points[i];
			this.points.push(new Vector3().fromArray(point));
		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;

		return this;
	};

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bzier_curve
	 */

	function CatmullRom(t, p0, p1, p2, p3) {
		const v0 = (p2 - p0) * 0.5;
		const v1 = (p3 - p1) * 0.5;
		const t2 = t * t;
		const t3 = t * t2;
		return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
	}

	//

	function QuadraticBezierP0(t, p) {
		const k = 1 - t;
		return k * k * p;
	}

	function QuadraticBezierP1(t, p) {
		return 2 * (1 - t) * t * p;
	}

	function QuadraticBezierP2(t, p) {
		return t * t * p;
	}

	function QuadraticBezier(t, p0, p1, p2) {
		return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1)
			+ QuadraticBezierP2(t, p2);
	}

	//

	function CubicBezierP0(t, p) {
		const k = 1 - t;
		return k * k * k * p;
	}

	function CubicBezierP1(t, p) {
		const k = 1 - t;
		return 3 * k * k * t * p;
	}

	function CubicBezierP2(t, p) {
		return 3 * (1 - t) * t * t * p;
	}

	function CubicBezierP3(t, p) {
		return t * t * t * p;
	}

	function CubicBezier(t, p0, p1, p2, p3) {
		return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2)
			+ CubicBezierP3(t, p3);
	}

	function CubicBezierCurve(v0, v1, v2, v3) {
		Curve.call(this);

		this.type = 'CubicBezierCurve';

		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();
		this.v3 = v3 || new Vector2();
	}

	CubicBezierCurve.prototype = Object.create(Curve.prototype);
	CubicBezierCurve.prototype.constructor = CubicBezierCurve;

	CubicBezierCurve.prototype.isCubicBezierCurve = true;

	CubicBezierCurve.prototype.getPoint = function (t, optionalTarget) {
		const point = optionalTarget || new Vector2();

		const { v0 } = this;
		const { v1 } = this;
		const { v2 } = this;
		const { v3 } = this;

		point.set(
			CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
			CubicBezier(t, v0.y, v1.y, v2.y, v3.y),
		);

		return point;
	};

	CubicBezierCurve.prototype.copy = function (source) {
		Curve.prototype.copy.call(this, source);

		this.v0.copy(source.v0);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		this.v3.copy(source.v3);

		return this;
	};

	CubicBezierCurve.prototype.toJSON = function () {
		const data = Curve.prototype.toJSON.call(this);

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;
	};

	CubicBezierCurve.prototype.fromJSON = function (json) {
		Curve.prototype.fromJSON.call(this, json);

		this.v0.fromArray(json.v0);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		this.v3.fromArray(json.v3);

		return this;
	};

	function CubicBezierCurve3(v0, v1, v2, v3) {
		Curve.call(this);

		this.type = 'CubicBezierCurve3';

		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();
		this.v3 = v3 || new Vector3();
	}

	CubicBezierCurve3.prototype = Object.create(Curve.prototype);
	CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

	CubicBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
		const point = optionalTarget || new Vector3();

		const { v0 } = this;
		const { v1 } = this;
		const { v2 } = this;
		const { v3 } = this;

		point.set(
			CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
			CubicBezier(t, v0.y, v1.y, v2.y, v3.y),
			CubicBezier(t, v0.z, v1.z, v2.z, v3.z),
		);

		return point;
	};

	CubicBezierCurve3.prototype.copy = function (source) {
		Curve.prototype.copy.call(this, source);

		this.v0.copy(source.v0);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);
		this.v3.copy(source.v3);

		return this;
	};

	CubicBezierCurve3.prototype.toJSON = function () {
		const data = Curve.prototype.toJSON.call(this);

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;
	};

	CubicBezierCurve3.prototype.fromJSON = function (json) {
		Curve.prototype.fromJSON.call(this, json);

		this.v0.fromArray(json.v0);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);
		this.v3.fromArray(json.v3);

		return this;
	};

	function LineCurve(v1, v2) {
		Curve.call(this);

		this.type = 'LineCurve';

		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();
	}

	LineCurve.prototype = Object.create(Curve.prototype);
	LineCurve.prototype.constructor = LineCurve;

	LineCurve.prototype.isLineCurve = true;

	LineCurve.prototype.getPoint = function (t, optionalTarget) {
		const point = optionalTarget || new Vector2();

		if (t === 1) {
			point.copy(this.v2);
		} else {
			point.copy(this.v2).sub(this.v1);
			point.multiplyScalar(t).add(this.v1);
		}

		return point;
	};

	// Line curve is linear, so we can overwrite default getPointAt

	LineCurve.prototype.getPointAt = function (u, optionalTarget) {
		return this.getPoint(u, optionalTarget);
	};

	LineCurve.prototype.getTangent = function (/* t */) {
		const tangent = this.v2.clone().sub(this.v1);

		return tangent.normalize();
	};

	LineCurve.prototype.copy = function (source) {
		Curve.prototype.copy.call(this, source);

		this.v1.copy(source.v1);
		this.v2.copy(source.v2);

		return this;
	};

	LineCurve.prototype.toJSON = function () {
		const data = Curve.prototype.toJSON.call(this);

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;
	};

	LineCurve.prototype.fromJSON = function (json) {
		Curve.prototype.fromJSON.call(this, json);

		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);

		return this;
	};

	function LineCurve3(v1, v2) {
		Curve.call(this);

		this.type = 'LineCurve3';

		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();
	}

	LineCurve3.prototype = Object.create(Curve.prototype);
	LineCurve3.prototype.constructor = LineCurve3;

	LineCurve3.prototype.isLineCurve3 = true;

	LineCurve3.prototype.getPoint = function (t, optionalTarget) {
		const point = optionalTarget || new Vector3();

		if (t === 1) {
			point.copy(this.v2);
		} else {
			point.copy(this.v2).sub(this.v1);
			point.multiplyScalar(t).add(this.v1);
		}

		return point;
	};

	// Line curve is linear, so we can overwrite default getPointAt

	LineCurve3.prototype.getPointAt = function (u, optionalTarget) {
		return this.getPoint(u, optionalTarget);
	};

	LineCurve3.prototype.copy = function (source) {
		Curve.prototype.copy.call(this, source);

		this.v1.copy(source.v1);
		this.v2.copy(source.v2);

		return this;
	};

	LineCurve3.prototype.toJSON = function () {
		const data = Curve.prototype.toJSON.call(this);

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;
	};

	LineCurve3.prototype.fromJSON = function (json) {
		Curve.prototype.fromJSON.call(this, json);

		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);

		return this;
	};

	function QuadraticBezierCurve(v0, v1, v2) {
		Curve.call(this);

		this.type = 'QuadraticBezierCurve';

		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();
	}

	QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
	QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

	QuadraticBezierCurve.prototype.getPoint = function (t, optionalTarget) {
		const point = optionalTarget || new Vector2();

		const { v0 } = this;
		const { v1 } = this;
		const { v2 } = this;

		point.set(
			QuadraticBezier(t, v0.x, v1.x, v2.x),
			QuadraticBezier(t, v0.y, v1.y, v2.y),
		);

		return point;
	};

	QuadraticBezierCurve.prototype.copy = function (source) {
		Curve.prototype.copy.call(this, source);

		this.v0.copy(source.v0);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);

		return this;
	};

	QuadraticBezierCurve.prototype.toJSON = function () {
		const data = Curve.prototype.toJSON.call(this);

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;
	};

	QuadraticBezierCurve.prototype.fromJSON = function (json) {
		Curve.prototype.fromJSON.call(this, json);

		this.v0.fromArray(json.v0);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);

		return this;
	};

	function QuadraticBezierCurve3(v0, v1, v2) {
		Curve.call(this);

		this.type = 'QuadraticBezierCurve3';

		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();
	}

	QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
	QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

	QuadraticBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
		const point = optionalTarget || new Vector3();

		const { v0 } = this;
		const { v1 } = this;
		const { v2 } = this;

		point.set(
			QuadraticBezier(t, v0.x, v1.x, v2.x),
			QuadraticBezier(t, v0.y, v1.y, v2.y),
			QuadraticBezier(t, v0.z, v1.z, v2.z),
		);

		return point;
	};

	QuadraticBezierCurve3.prototype.copy = function (source) {
		Curve.prototype.copy.call(this, source);

		this.v0.copy(source.v0);
		this.v1.copy(source.v1);
		this.v2.copy(source.v2);

		return this;
	};

	QuadraticBezierCurve3.prototype.toJSON = function () {
		const data = Curve.prototype.toJSON.call(this);

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;
	};

	QuadraticBezierCurve3.prototype.fromJSON = function (json) {
		Curve.prototype.fromJSON.call(this, json);

		this.v0.fromArray(json.v0);
		this.v1.fromArray(json.v1);
		this.v2.fromArray(json.v2);

		return this;
	};

	function SplineCurve(points /* array of Vector2 */) {
		Curve.call(this);

		this.type = 'SplineCurve';

		this.points = points || [];
	}

	SplineCurve.prototype = Object.create(Curve.prototype);
	SplineCurve.prototype.constructor = SplineCurve;

	SplineCurve.prototype.isSplineCurve = true;

	SplineCurve.prototype.getPoint = function (t, optionalTarget) {
		const point = optionalTarget || new Vector2();

		const { points } = this;
		const p = (points.length - 1) * t;

		const intPoint = Math.floor(p);
		const weight = p - intPoint;

		const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
		const p1 = points[intPoint];
		const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
		const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];

		point.set(
			CatmullRom(weight, p0.x, p1.x, p2.x, p3.x),
			CatmullRom(weight, p0.y, p1.y, p2.y, p3.y),
		);

		return point;
	};

	SplineCurve.prototype.copy = function (source) {
		Curve.prototype.copy.call(this, source);

		this.points = [];

		for (let i = 0, l = source.points.length; i < l; i++) {
			const point = source.points[i];

			this.points.push(point.clone());
		}

		return this;
	};

	SplineCurve.prototype.toJSON = function () {
		const data = Curve.prototype.toJSON.call(this);

		data.points = [];

		for (let i = 0, l = this.points.length; i < l; i++) {
			const point = this.points[i];
			data.points.push(point.toArray());
		}

		return data;
	};

	SplineCurve.prototype.fromJSON = function (json) {
		Curve.prototype.fromJSON.call(this, json);

		this.points = [];

		for (let i = 0, l = json.points.length; i < l; i++) {
			const point = json.points[i];
			this.points.push(new Vector2().fromArray(point));
		}

		return this;
	};


	const Curves = /* #__PURE__ */Object.freeze({
		ArcCurve,
		CatmullRomCurve3,
		CubicBezierCurve,
		CubicBezierCurve3,
		EllipseCurve,
		LineCurve,
		LineCurve3,
		QuadraticBezierCurve,
		QuadraticBezierCurve3,
		SplineCurve,
	});

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * */

	/** ************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 ************************************************************* */

	function CurvePath() {
		Curve.call(this);

		this.type = 'CurvePath';

		this.curves = [];
		this.autoClose = false; // Automatically closes the path
	}

	CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {

		constructor: CurvePath,

		add(curve) {
			this.curves.push(curve);
		},

		closePath() {
			// Add a line curve if start and end of lines are not connected
			const startPoint = this.curves[0].getPoint(0);
			const endPoint = this.curves[this.curves.length - 1].getPoint(1);

			if (!startPoint.equals(endPoint)) {
				this.curves.push(new LineCurve(endPoint, startPoint));
			}
		},

		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:

		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')

		getPoint(t) {
			const d = t * this.getLength();
			const curveLengths = this.getCurveLengths();
			let i = 0;

			// To think about boundaries points.

			while (i < curveLengths.length) {
				if (curveLengths[i] >= d) {
					const diff = curveLengths[i] - d;
					const curve = this.curves[i];

					const segmentLength = curve.getLength();
					const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

					return curve.getPointAt(u);
				}

				i++;
			}

			return null;

			// loop where sum != 0, sum > d , sum+1 <d
		},

		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength

		getLength() {
			const lens = this.getCurveLengths();
			return lens[lens.length - 1];
		},

		// cacheLengths must be recalculated.
		updateArcLengths() {
			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();
		},

		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.

		getCurveLengths() {
			// We use cache values if curves and cache array are same length

			if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
				return this.cacheLengths;
			}

			// Get length of sub-curve
			// Push sums into cached array

			const lengths = []; let
				sums = 0;

			for (let i = 0, l = this.curves.length; i < l; i++) {
				sums += this.curves[i].getLength();
				lengths.push(sums);
			}

			this.cacheLengths = lengths;

			return lengths;
		},

		getSpacedPoints(divisions) {
			if (divisions === undefined) divisions = 40;

			const points = [];

			for (let i = 0; i <= divisions; i++) {
				points.push(this.getPoint(i / divisions));
			}

			if (this.autoClose) {
				points.push(points[0]);
			}

			return points;
		},

		getPoints(divisions) {
			divisions = divisions || 12;

			const points = []; let
				last;

			for (let i = 0, { curves } = this; i < curves.length; i++) {
				const curve = curves[i];
				const resolution = (curve && curve.isEllipseCurve) ? divisions * 2
					: (curve && (curve.isLineCurve || curve.isLineCurve3)) ? 1
						: (curve && curve.isSplineCurve) ? divisions * curve.points.length
							: divisions;

				const pts = curve.getPoints(resolution);

				for (let j = 0; j < pts.length; j++) {
					const point = pts[j];

					if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

					points.push(point);
					last = point;
				}
			}

			if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
				points.push(points[0]);
			}

			return points;
		},

		copy(source) {
			Curve.prototype.copy.call(this, source);

			this.curves = [];

			for (let i = 0, l = source.curves.length; i < l; i++) {
				const curve = source.curves[i];

				this.curves.push(curve.clone());
			}

			this.autoClose = source.autoClose;

			return this;
		},

		toJSON() {
			const data = Curve.prototype.toJSON.call(this);

			data.autoClose = this.autoClose;
			data.curves = [];

			for (let i = 0, l = this.curves.length; i < l; i++) {
				const curve = this.curves[i];
				data.curves.push(curve.toJSON());
			}

			return data;
		},

		fromJSON(json) {
			Curve.prototype.fromJSON.call(this, json);

			this.autoClose = json.autoClose;
			this.curves = [];

			for (let i = 0, l = json.curves.length; i < l; i++) {
				const curve = json.curves[i];
				this.curves.push(new Curves[curve.type]().fromJSON(curve));
			}

			return this;
		},

	});

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 * */

	function Path(points) {
		CurvePath.call(this);

		this.type = 'Path';

		this.currentPoint = new Vector2();

		if (points) {
			this.setFromPoints(points);
		}
	}

	Path.prototype = Object.assign(Object.create(CurvePath.prototype), {

		constructor: Path,

		setFromPoints(points) {
			this.moveTo(points[0].x, points[0].y);

			for (let i = 1, l = points.length; i < l; i++) {
				this.lineTo(points[i].x, points[i].y);
			}
		},

		moveTo(x, y) {
			this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?
		},

		lineTo(x, y) {
			const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
			this.curves.push(curve);

			this.currentPoint.set(x, y);
		},

		quadraticCurveTo(aCPx, aCPy, aX, aY) {
			const curve = new QuadraticBezierCurve(
				this.currentPoint.clone(),
				new Vector2(aCPx, aCPy),
				new Vector2(aX, aY),
			);

			this.curves.push(curve);

			this.currentPoint.set(aX, aY);
		},

		bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
			const curve = new CubicBezierCurve(
				this.currentPoint.clone(),
				new Vector2(aCP1x, aCP1y),
				new Vector2(aCP2x, aCP2y),
				new Vector2(aX, aY),
			);

			this.curves.push(curve);

			this.currentPoint.set(aX, aY);
		},

		splineThru(pts /* Array of Vector */) {
			const npts = [this.currentPoint.clone()].concat(pts);

			const curve = new SplineCurve(npts);
			this.curves.push(curve);

			this.currentPoint.copy(pts[pts.length - 1]);
		},

		arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			const x0 = this.currentPoint.x;
			const y0 = this.currentPoint.y;

			this.absarc(aX + x0, aY + y0, aRadius,
				aStartAngle, aEndAngle, aClockwise);
		},

		absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
		},

		ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
			const x0 = this.currentPoint.x;
			const y0 = this.currentPoint.y;

			this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
		},

		absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
			const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

			if (this.curves.length > 0) {
				// if a previous curve is present, attempt to join
				const firstPoint = curve.getPoint(0);

				if (!firstPoint.equals(this.currentPoint)) {
					this.lineTo(firstPoint.x, firstPoint.y);
				}
			}

			this.curves.push(curve);

			const lastPoint = curve.getPoint(1);
			this.currentPoint.copy(lastPoint);
		},

		copy(source) {
			CurvePath.prototype.copy.call(this, source);

			this.currentPoint.copy(source.currentPoint);

			return this;
		},

		toJSON() {
			const data = CurvePath.prototype.toJSON.call(this);

			data.currentPoint = this.currentPoint.toArray();

			return data;
		},

		fromJSON(json) {
			CurvePath.prototype.fromJSON.call(this, json);

			this.currentPoint.fromArray(json.currentPoint);

			return this;
		},

	});

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 * */

	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.

	function Shape(points) {
		Path.call(this, points);

		this.uuid = _Math.generateUUID();

		this.type = 'Shape';

		this.holes = [];
	}

	Shape.prototype = Object.assign(Object.create(Path.prototype), {

		constructor: Shape,

		getPointsHoles(divisions) {
			const holesPts = [];

			for (let i = 0, l = this.holes.length; i < l; i++) {
				holesPts[i] = this.holes[i].getPoints(divisions);
			}

			return holesPts;
		},

		// get points of shape and holes (keypoints based on segments parameter)

		extractPoints(divisions) {
			return {

				shape: this.getPoints(divisions),
				holes: this.getPointsHoles(divisions),

			};
		},

		copy(source) {
			Path.prototype.copy.call(this, source);

			this.holes = [];

			for (let i = 0, l = source.holes.length; i < l; i++) {
				const hole = source.holes[i];

				this.holes.push(hole.clone());
			}

			return this;
		},

		toJSON() {
			const data = Path.prototype.toJSON.call(this);

			data.uuid = this.uuid;
			data.holes = [];

			for (let i = 0, l = this.holes.length; i < l; i++) {
				const hole = this.holes[i];
				data.holes.push(hole.toJSON());
			}

			return data;
		},

		fromJSON(json) {
			Path.prototype.fromJSON.call(this, json);

			this.uuid = json.uuid;
			this.holes = [];

			for (let i = 0, l = json.holes.length; i < l; i++) {
				const hole = json.holes[i];
				this.holes.push(new Path().fromJSON(hole));
			}

			return this;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Light(color, intensity) {
		Object3D.call(this);

		this.type = 'Light';

		this.color = new Color(color);
		this.intensity = intensity !== undefined ? intensity : 1;

		this.receiveShadow = undefined;
	}

	Light.prototype = Object.assign(Object.create(Object3D.prototype), {

		constructor: Light,

		isLight: true,

		copy(source) {
			Object3D.prototype.copy.call(this, source);

			this.color.copy(source.color);
			this.intensity = source.intensity;

			return this;
		},

		toJSON(meta) {
			const data = Object3D.prototype.toJSON.call(this, meta);

			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;

			if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();

			if (this.distance !== undefined) data.object.distance = this.distance;
			if (this.angle !== undefined) data.object.angle = this.angle;
			if (this.decay !== undefined) data.object.decay = this.decay;
			if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;

			if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();

			return data;
		},

	});

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function HemisphereLight(skyColor, groundColor, intensity) {
		Light.call(this, skyColor, intensity);

		this.type = 'HemisphereLight';

		this.castShadow = undefined;

		this.position.copy(Object3D.DefaultUp);
		this.updateMatrix();

		this.groundColor = new Color(groundColor);
	}

	HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {

		constructor: HemisphereLight,

		isHemisphereLight: true,

		copy(source) {
			Light.prototype.copy.call(this, source);

			this.groundColor.copy(source.groundColor);

			return this;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LightShadow(camera) {
		this.camera = camera;

		this.bias = 0;
		this.radius = 1;

		this.mapSize = new Vector2(512, 512);

		this.map = null;
		this.matrix = new Matrix4();
	}

	Object.assign(LightShadow.prototype, {

		copy(source) {
			this.camera = source.camera.clone();

			this.bias = source.bias;
			this.radius = source.radius;

			this.mapSize.copy(source.mapSize);

			return this;
		},

		clone() {
			return new this.constructor().copy(this);
		},

		toJSON() {
			const object = {};

			if (this.bias !== 0) object.bias = this.bias;
			if (this.radius !== 1) object.radius = this.radius;
			if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();

			object.camera = this.camera.toJSON(false).object;
			delete object.camera.matrix;

			return object;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function SpotLightShadow() {
		LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
	}

	SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {

		constructor: SpotLightShadow,

		isSpotLightShadow: true,

		update(light) {
			const { camera } = this;

			const fov = _Math.RAD2DEG * 2 * light.angle;
			const aspect = this.mapSize.width / this.mapSize.height;
			const far = light.distance || camera.far;

			if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();
			}
		},

	});

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function SpotLight(color, intensity, distance, angle, penumbra, decay) {
		Light.call(this, color, intensity);

		this.type = 'SpotLight';

		this.position.copy(Object3D.DefaultUp);
		this.updateMatrix();

		this.target = new Object3D();

		Object.defineProperty(this, 'power', {
			get() {
				// intensity = power per solid angle.
				// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				return this.intensity * Math.PI;
			},
			set(power) {
				// intensity = power per solid angle.
				// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				this.intensity = power / Math.PI;
			},
		});

		this.distance = (distance !== undefined) ? distance : 0;
		this.angle = (angle !== undefined) ? angle : Math.PI / 3;
		this.penumbra = (penumbra !== undefined) ? penumbra : 0;
		this.decay = (decay !== undefined) ? decay : 1;	// for physically correct lights, should be 2.

		this.shadow = new SpotLightShadow();
	}

	SpotLight.prototype = Object.assign(Object.create(Light.prototype), {

		constructor: SpotLight,

		isSpotLight: true,

		copy(source) {
			Light.prototype.copy.call(this, source);

			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function PointLight(color, intensity, distance, decay) {
		Light.call(this, color, intensity);

		this.type = 'PointLight';

		Object.defineProperty(this, 'power', {
			get() {
				// intensity = power per solid angle.
				// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				return this.intensity * 4 * Math.PI;
			},
			set(power) {
				// intensity = power per solid angle.
				// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				this.intensity = power / (4 * Math.PI);
			},
		});

		this.distance = (distance !== undefined) ? distance : 0;
		this.decay = (decay !== undefined) ? decay : 1;	// for physically correct lights, should be 2.

		this.shadow = new LightShadow(new PerspectiveCamera(90, 1, 0.5, 500));
	}

	PointLight.prototype = Object.assign(Object.create(Light.prototype), {

		constructor: PointLight,

		isPointLight: true,

		copy(source) {
			Light.prototype.copy.call(this, source);

			this.distance = source.distance;
			this.decay = source.decay;

			this.shadow = source.shadow.clone();

			return this;
		},

	});

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author arose / http://github.com/arose
	 */

	function OrthographicCamera(left, right, top, bottom, near, far) {
		Camera.call(this);

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = (left !== undefined) ? left : -1;
		this.right = (right !== undefined) ? right : 1;
		this.top = (top !== undefined) ? top : 1;
		this.bottom = (bottom !== undefined) ? bottom : -1;

		this.near = (near !== undefined) ? near : 0.1;
		this.far = (far !== undefined) ? far : 2000;

		this.updateProjectionMatrix();
	}

	OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {

		constructor: OrthographicCamera,

		isOrthographicCamera: true,

		copy(source, recursive) {
			Camera.prototype.copy.call(this, source, recursive);

			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;

			this.zoom = source.zoom;
			this.view = source.view === null ? null : ({ ...source.view });

			return this;
		},

		setViewOffset(fullWidth, fullHeight, x, y, width, height) {
			if (this.view === null) {
				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1,
				};
			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();
		},

		clearViewOffset() {
			if (this.view !== null) {
				this.view.enabled = false;
			}

			this.updateProjectionMatrix();
		},

		updateProjectionMatrix() {
			const dx = (this.right - this.left) / (2 * this.zoom);
			const dy = (this.top - this.bottom) / (2 * this.zoom);
			const cx = (this.right + this.left) / 2;
			const cy = (this.top + this.bottom) / 2;

			let left = cx - dx;
			let right = cx + dx;
			let top = cy + dy;
			let bottom = cy - dy;

			if (this.view !== null && this.view.enabled) {
				const zoomW = this.zoom / (this.view.width / this.view.fullWidth);
				const zoomH = this.zoom / (this.view.height / this.view.fullHeight);
				const scaleW = (this.right - this.left) / this.view.width;
				const scaleH = (this.top - this.bottom) / this.view.height;

				left += scaleW * (this.view.offsetX / zoomW);
				right = left + scaleW * (this.view.width / zoomW);
				top -= scaleH * (this.view.offsetY / zoomH);
				bottom = top - scaleH * (this.view.height / zoomH);
			}

			this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);

			this.projectionMatrixInverse.getInverse(this.projectionMatrix);
		},

		toJSON(meta) {
			const data = Object3D.prototype.toJSON.call(this, meta);

			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;

			if (this.view !== null) data.object.view = { ...this.view };

			return data;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function DirectionalLightShadow() {
		LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
	}

	DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {

		constructor: DirectionalLightShadow,

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function DirectionalLight(color, intensity) {
		Light.call(this, color, intensity);

		this.type = 'DirectionalLight';

		this.position.copy(Object3D.DefaultUp);
		this.updateMatrix();

		this.target = new Object3D();

		this.shadow = new DirectionalLightShadow();
	}

	DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {

		constructor: DirectionalLight,

		isDirectionalLight: true,

		copy(source) {
			Light.prototype.copy.call(this, source);

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AmbientLight(color, intensity) {
		Light.call(this, color, intensity);

		this.type = 'AmbientLight';

		this.castShadow = undefined;
	}

	AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {

		constructor: AmbientLight,

		isAmbientLight: true,

	});

	/**
	 * @author abelnation / http://github.com/abelnation
	 */

	function RectAreaLight(color, intensity, width, height) {
		Light.call(this, color, intensity);

		this.type = 'RectAreaLight';

		this.width = (width !== undefined) ? width : 10;
		this.height = (height !== undefined) ? height : 10;
	}

	RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {

		constructor: RectAreaLight,

		isRectAreaLight: true,

		copy(source) {
			Light.prototype.copy.call(this, source);

			this.width = source.width;
			this.height = source.height;

			return this;
		},

		toJSON(meta) {
			const data = Light.prototype.toJSON.call(this, meta);

			data.object.width = this.width;
			data.object.height = this.height;

			return data;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function MaterialLoader(manager) {
		this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
		this.textures = {};
	}

	Object.assign(MaterialLoader.prototype, {

		load(url, onLoad, onProgress, onError) {
			const scope = this;

			const loader = new FileLoader(scope.manager);
			loader.setPath(scope.path);
			loader.load(url, (text) => {
				onLoad(scope.parse(JSON.parse(text)));
			}, onProgress, onError);
		},

		parse(json) {
			const { textures } = this;

			function getTexture(name) {
				if (textures[name] === undefined) {
					console.warn('THREE.MaterialLoader: Undefined texture', name);
				}

				return textures[name];
			}

			const material = new Materials[json.type]();

			if (json.uuid !== undefined) material.uuid = json.uuid;
			if (json.name !== undefined) material.name = json.name;
			if (json.color !== undefined) material.color.setHex(json.color);
			if (json.roughness !== undefined) material.roughness = json.roughness;
			if (json.metalness !== undefined) material.metalness = json.metalness;
			if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
			if (json.specular !== undefined) material.specular.setHex(json.specular);
			if (json.shininess !== undefined) material.shininess = json.shininess;
			if (json.clearCoat !== undefined) material.clearCoat = json.clearCoat;
			if (json.clearCoatRoughness !== undefined) material.clearCoatRoughness = json.clearCoatRoughness;
			if (json.vertexColors !== undefined) material.vertexColors = json.vertexColors;
			if (json.fog !== undefined) material.fog = json.fog;
			if (json.flatShading !== undefined) material.flatShading = json.flatShading;
			if (json.blending !== undefined) material.blending = json.blending;
			if (json.combine !== undefined) material.combine = json.combine;
			if (json.side !== undefined) material.side = json.side;
			if (json.opacity !== undefined) material.opacity = json.opacity;
			if (json.transparent !== undefined) material.transparent = json.transparent;
			if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
			if (json.depthTest !== undefined) material.depthTest = json.depthTest;
			if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
			if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
			if (json.wireframe !== undefined) material.wireframe = json.wireframe;
			if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
			if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
			if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;

			if (json.rotation !== undefined) material.rotation = json.rotation;

			if (json.linewidth !== 1) material.linewidth = json.linewidth;
			if (json.dashSize !== undefined) material.dashSize = json.dashSize;
			if (json.gapSize !== undefined) material.gapSize = json.gapSize;
			if (json.scale !== undefined) material.scale = json.scale;

			if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
			if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
			if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;

			if (json.skinning !== undefined) material.skinning = json.skinning;
			if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
			if (json.dithering !== undefined) material.dithering = json.dithering;

			if (json.visible !== undefined) material.visible = json.visible;
			if (json.userData !== undefined) material.userData = json.userData;

			// Shader Material

			if (json.uniforms !== undefined) {
				for (const name in json.uniforms) {
					const uniform = json.uniforms[name];

					material.uniforms[name] = {};

					switch (uniform.type) {
					case 't':
						material.uniforms[name].value = getTexture(uniform.value);
						break;

					case 'c':
						material.uniforms[name].value = new Color().setHex(uniform.value);
						break;

					case 'v2':
						material.uniforms[name].value = new Vector2().fromArray(uniform.value);
						break;

					case 'v3':
						material.uniforms[name].value = new Vector3().fromArray(uniform.value);
						break;

					case 'v4':
						material.uniforms[name].value = new Vector4().fromArray(uniform.value);
						break;

					case 'm4':
						material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
						break;

					default:
						material.uniforms[name].value = uniform.value;
					}
				}
			}

			if (json.defines !== undefined) material.defines = json.defines;
			if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
			if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;

			if (json.extensions !== undefined) {
				for (const key in json.extensions) {
					material.extensions[key] = json.extensions[key];
				}
			}

			// Deprecated

			if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading

			// for PointsMaterial

			if (json.size !== undefined) material.size = json.size;
			if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;

			// maps

			if (json.map !== undefined) material.map = getTexture(json.map);

			if (json.alphaMap !== undefined) {
				material.alphaMap = getTexture(json.alphaMap);
				material.transparent = true;
			}

			if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
			if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;

			if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
			if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
			if (json.normalScale !== undefined) {
				let { normalScale } = json;

				if (Array.isArray(normalScale) === false) {
					// Blender exporter used to export a scalar. See #7459

					normalScale = [normalScale, normalScale];
				}

				material.normalScale = new Vector2().fromArray(normalScale);
			}

			if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
			if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
			if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;

			if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
			if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);

			if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
			if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;

			if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);

			if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
			if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;

			if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;

			if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
			if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;

			if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
			if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;

			if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);

			return material;
		},

		setPath(value) {
			this.path = value;
			return this;
		},

		setTextures(value) {
			this.textures = value;
			return this;
		},

	});

	/**
	 * @author Don McCurdy / https://www.donmccurdy.com
	 */

	const LoaderUtils = {

		decodeText(array) {
			if (typeof TextDecoder !== 'undefined') {
				return new TextDecoder().decode(array);
			}

			// Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.

			let s = '';

			for (let i = 0, il = array.length; i < il; i++) {
				// Implicitly assumes little-endian.
				s += String.fromCharCode(array[i]);
			}

			// Merges multi-byte utf-8 characters.
			return decodeURIComponent(escape(s));
		},

		extractUrlBase(url) {
			const index = url.lastIndexOf('/');

			if (index === -1) return './';

			return url.substr(0, index + 1);
		},

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function BufferGeometryLoader(manager) {
		this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
	}

	Object.assign(BufferGeometryLoader.prototype, {

		load(url, onLoad, onProgress, onError) {
			const scope = this;

			const loader = new FileLoader(scope.manager);
			loader.setPath(scope.path);
			loader.load(url, (text) => {
				onLoad(scope.parse(JSON.parse(text)));
			}, onProgress, onError);
		},

		parse(json) {
			const geometry = new BufferGeometry();

			const { index } = json.data;

			if (index !== undefined) {
				var typedArray = new TYPED_ARRAYS[index.type](index.array);
				geometry.setIndex(new BufferAttribute(typedArray, 1));
			}

			const { attributes } = json.data;

			for (const key in attributes) {
				const attribute = attributes[key];
				var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);

				geometry.addAttribute(key, new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized));
			}

			const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if (groups !== undefined) {
				for (let i = 0, n = groups.length; i !== n; ++i) {
					const group = groups[i];

					geometry.addGroup(group.start, group.count, group.materialIndex);
				}
			}

			const { boundingSphere } = json.data;

			if (boundingSphere !== undefined) {
				const center = new Vector3();

				if (boundingSphere.center !== undefined) {
					center.fromArray(boundingSphere.center);
				}

				geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
			}

			if (json.name) geometry.name = json.name;
			if (json.userData) geometry.userData = json.userData;

			return geometry;
		},

		setPath(value) {
			this.path = value;
			return this;
		},

	});

	var TYPED_ARRAYS = {
		Int8Array,
		Uint8Array,
		// Workaround for IE11 pre KB2929437. See #11440
		Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
		Int16Array,
		Uint16Array,
		Int32Array,
		Uint32Array,
		Float32Array,
		Float64Array,
	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function ObjectLoader(manager) {
		this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
		this.resourcePath = '';
	}

	Object.assign(ObjectLoader.prototype, {

		crossOrigin: 'anonymous',

		load(url, onLoad, onProgress, onError) {
			const scope = this;

			const path = (this.path === undefined) ? LoaderUtils.extractUrlBase(url) : this.path;
			this.resourcePath = this.resourcePath || path;

			const loader = new FileLoader(scope.manager);
			loader.setPath(this.path);
			loader.load(url, (text) => {
				let json = null;

				try {
					json = JSON.parse(text);
				} catch (error) {
					if (onError !== undefined) onError(error);

					console.error(`THREE:ObjectLoader: Can't parse ${url}.`, error.message);

					return;
				}

				const { metadata } = json;

				if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
					console.error(`THREE.ObjectLoader: Can't load ${url}`);
					return;
				}

				scope.parse(json, onLoad);
			}, onProgress, onError);
		},

		setPath(value) {
			this.path = value;
			return this;
		},

		setResourcePath(value) {
			this.resourcePath = value;
			return this;
		},

		setCrossOrigin(value) {
			this.crossOrigin = value;
			return this;
		},

		parse(json, onLoad) {
			const shapes = this.parseShape(json.shapes);
			const geometries = this.parseGeometries(json.geometries, shapes);

			const images = this.parseImages(json.images, () => {
				if (onLoad !== undefined) onLoad(object);
			});

			const textures = this.parseTextures(json.textures, images);
			const materials = this.parseMaterials(json.materials, textures);

			var object = this.parseObject(json.object, geometries, materials);

			if (json.animations) {
				object.animations = this.parseAnimations(json.animations);
			}

			if (json.images === undefined || json.images.length === 0) {
				if (onLoad !== undefined) onLoad(object);
			}

			return object;
		},

		parseShape(json) {
			const shapes = {};

			if (json !== undefined) {
				for (let i = 0, l = json.length; i < l; i++) {
					const shape = new Shape().fromJSON(json[i]);

					shapes[shape.uuid] = shape;
				}
			}

			return shapes;
		},

		parseGeometries(json, shapes) {
			const geometries = {};

			if (json !== undefined) {
				const bufferGeometryLoader = new BufferGeometryLoader();

				for (let i = 0, l = json.length; i < l; i++) {
					var geometry;
					const data = json[i];

					switch (data.type) {
					case 'PlaneGeometry':
					case 'PlaneBufferGeometry':

						geometry = new Geometries[data.type](
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments,
						);

						break;

					case 'BoxGeometry':
					case 'BoxBufferGeometry':
					case 'CubeGeometry': // backwards compatible

						geometry = new Geometries[data.type](
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments,
						);

						break;

					case 'CircleGeometry':
					case 'CircleBufferGeometry':

						geometry = new Geometries[data.type](
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength,
						);

						break;

					case 'CylinderGeometry':
					case 'CylinderBufferGeometry':

						geometry = new Geometries[data.type](
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength,
						);

						break;

					case 'ConeGeometry':
					case 'ConeBufferGeometry':

						geometry = new Geometries[data.type](
							data.radius,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength,
						);

						break;

					case 'SphereGeometry':
					case 'SphereBufferGeometry':

						geometry = new Geometries[data.type](
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength,
						);

						break;

					case 'DodecahedronGeometry':
					case 'DodecahedronBufferGeometry':
					case 'IcosahedronGeometry':
					case 'IcosahedronBufferGeometry':
					case 'OctahedronGeometry':
					case 'OctahedronBufferGeometry':
					case 'TetrahedronGeometry':
					case 'TetrahedronBufferGeometry':

						geometry = new Geometries[data.type](
							data.radius,
							data.detail,
						);

						break;

					case 'RingGeometry':
					case 'RingBufferGeometry':

						geometry = new Geometries[data.type](
							data.innerRadius,
							data.outerRadius,
							data.thetaSegments,
							data.phiSegments,
							data.thetaStart,
							data.thetaLength,
						);

						break;

					case 'TorusGeometry':
					case 'TorusBufferGeometry':

						geometry = new Geometries[data.type](
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc,
						);

						break;

					case 'TorusKnotGeometry':
					case 'TorusKnotBufferGeometry':

						geometry = new Geometries[data.type](
							data.radius,
							data.tube,
							data.tubularSegments,
							data.radialSegments,
							data.p,
							data.q,
						);

						break;

					case 'LatheGeometry':
					case 'LatheBufferGeometry':

						geometry = new Geometries[data.type](
							data.points,
							data.segments,
							data.phiStart,
							data.phiLength,
						);

						break;

					case 'PolyhedronGeometry':
					case 'PolyhedronBufferGeometry':

						geometry = new Geometries[data.type](
							data.vertices,
							data.indices,
							data.radius,
							data.details,
						);

						break;

					case 'ShapeGeometry':
					case 'ShapeBufferGeometry':

						var geometryShapes = [];

						for (var j = 0, jl = data.shapes.length; j < jl; j++) {
							var shape = shapes[data.shapes[j]];

							geometryShapes.push(shape);
						}

						geometry = new Geometries[data.type](
							geometryShapes,
							data.curveSegments,
						);

						break;


					case 'ExtrudeGeometry':
					case 'ExtrudeBufferGeometry':

						var geometryShapes = [];

						for (var j = 0, jl = data.shapes.length; j < jl; j++) {
							var shape = shapes[data.shapes[j]];

							geometryShapes.push(shape);
						}

						var { extrudePath } = data.options;

						if (extrudePath !== undefined) {
							data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
						}

						geometry = new Geometries[data.type](
							geometryShapes,
							data.options,
						);

						break;

					case 'BufferGeometry':

						geometry = bufferGeometryLoader.parse(data);

						break;

					case 'Geometry':

						if ('THREE' in window && 'LegacyJSONLoader' in THREE) {
							const geometryLoader = new THREE.LegacyJSONLoader();
							geometry = geometryLoader.parse(data, this.resourcePath).geometry;
						} else {
							console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
						}

						break;

					default:

						console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);

						continue;
					}

					geometry.uuid = data.uuid;

					if (data.name !== undefined) geometry.name = data.name;
					if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;

					geometries[data.uuid] = geometry;
				}
			}

			return geometries;
		},

		parseMaterials(json, textures) {
			const cache = {}; // MultiMaterial
			const materials = {};

			if (json !== undefined) {
				const loader = new MaterialLoader();
				loader.setTextures(textures);

				for (let i = 0, l = json.length; i < l; i++) {
					const data = json[i];

					if (data.type === 'MultiMaterial') {
						// Deprecated

						const array = [];

						for (let j = 0; j < data.materials.length; j++) {
							const material = data.materials[j];

							if (cache[material.uuid] === undefined) {
								cache[material.uuid] = loader.parse(material);
							}

							array.push(cache[material.uuid]);
						}

						materials[data.uuid] = array;
					} else {
						materials[data.uuid] = loader.parse(data);
						cache[data.uuid] = materials[data.uuid];
					}
				}
			}

			return materials;
		},

		parseAnimations(json) {
			const animations = [];

			for (let i = 0; i < json.length; i++) {
				const data = json[i];

				const clip = AnimationClip.parse(data);

				if (data.uuid !== undefined) clip.uuid = data.uuid;

				animations.push(clip);
			}

			return animations;
		},

		parseImages(json, onLoad) {
			const scope = this;
			const images = {};

			function loadImage(url) {
				scope.manager.itemStart(url);

				return loader.load(url, () => {
					scope.manager.itemEnd(url);
				}, undefined, () => {
					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				});
			}

			if (json !== undefined && json.length > 0) {
				const manager = new LoadingManager(onLoad);

				var loader = new ImageLoader(manager);
				loader.setCrossOrigin(this.crossOrigin);

				for (let i = 0, il = json.length; i < il; i++) {
					const image = json[i];
					const { url } = image;

					if (Array.isArray(url)) {
						// load array of images e.g CubeTexture

						images[image.uuid] = [];

						for (let j = 0, jl = url.length; j < jl; j++) {
							const currentUrl = url[j];

							var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl) ? currentUrl : scope.resourcePath + currentUrl;

							images[image.uuid].push(loadImage(path));
						}
					} else {
						// load single image

						var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.resourcePath + image.url;

						images[image.uuid] = loadImage(path);
					}
				}
			}

			return images;
		},

		parseTextures(json, images) {
			function parseConstant(value, type) {
				if (typeof value === 'number') return value;

				console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);

				return type[value];
			}

			const textures = {};

			if (json !== undefined) {
				for (let i = 0, l = json.length; i < l; i++) {
					const data = json[i];

					if (data.image === undefined) {
						console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
					}

					if (images[data.image] === undefined) {
						console.warn('THREE.ObjectLoader: Undefined image', data.image);
					}

					var texture;

					if (Array.isArray(images[data.image])) {
						texture = new CubeTexture(images[data.image]);
					} else {
						texture = new Texture(images[data.image]);
					}

					texture.needsUpdate = true;

					texture.uuid = data.uuid;

					if (data.name !== undefined) texture.name = data.name;

					if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);

					if (data.offset !== undefined) texture.offset.fromArray(data.offset);
					if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
					if (data.center !== undefined) texture.center.fromArray(data.center);
					if (data.rotation !== undefined) texture.rotation = data.rotation;

					if (data.wrap !== undefined) {
						texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
						texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
					}

					if (data.format !== undefined) texture.format = data.format;
					if (data.type !== undefined) texture.type = data.type;
					if (data.encoding !== undefined) texture.encoding = data.encoding;

					if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
					if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
					if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;

					if (data.flipY !== undefined) texture.flipY = data.flipY;

					if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
					if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;

					textures[data.uuid] = texture;
				}
			}

			return textures;
		},

		parseObject(data, geometries, materials) {
			let object;

			function getGeometry(name) {
				if (geometries[name] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined geometry', name);
				}

				return geometries[name];
			}

			function getMaterial(name) {
				if (name === undefined) return undefined;

				if (Array.isArray(name)) {
					const array = [];

					for (let i = 0, l = name.length; i < l; i++) {
						const uuid = name[i];

						if (materials[uuid] === undefined) {
							console.warn('THREE.ObjectLoader: Undefined material', uuid);
						}

						array.push(materials[uuid]);
					}

					return array;
				}

				if (materials[name] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined material', name);
				}

				return materials[name];
			}

			switch (data.type) {
			case 'Scene':

				object = new Scene();

				if (data.background !== undefined) {
					if (Number.isInteger(data.background)) {
						object.background = new Color(data.background);
					}
				}

				if (data.fog !== undefined) {
					if (data.fog.type === 'Fog') {
						object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
					} else if (data.fog.type === 'FogExp2') {
						object.fog = new FogExp2(data.fog.color, data.fog.density);
					}
				}

				break;

			case 'PerspectiveCamera':

				object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);

				if (data.focus !== undefined) object.focus = data.focus;
				if (data.zoom !== undefined) object.zoom = data.zoom;
				if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
				if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
				if (data.view !== undefined) object.view = { ...data.view };

				break;

			case 'OrthographicCamera':

				object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);

				if (data.zoom !== undefined) object.zoom = data.zoom;
				if (data.view !== undefined) object.view = { ...data.view };

				break;

			case 'AmbientLight':

				object = new AmbientLight(data.color, data.intensity);

				break;

			case 'DirectionalLight':

				object = new DirectionalLight(data.color, data.intensity);

				break;

			case 'PointLight':

				object = new PointLight(data.color, data.intensity, data.distance, data.decay);

				break;

			case 'RectAreaLight':

				object = new RectAreaLight(data.color, data.intensity, data.width, data.height);

				break;

			case 'SpotLight':

				object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);

				break;

			case 'HemisphereLight':

				object = new HemisphereLight(data.color, data.groundColor, data.intensity);

				break;

			case 'SkinnedMesh':

				console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');

			case 'Mesh':

				var geometry = getGeometry(data.geometry);
				var material = getMaterial(data.material);

				if (geometry.bones && geometry.bones.length > 0) {
					object = new SkinnedMesh(geometry, material);
				} else {
					object = new Mesh(geometry, material);
				}

				break;

			case 'LOD':

				object = new LOD();

				break;

			case 'Line':

				object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);

				break;

			case 'LineLoop':

				object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));

				break;

			case 'LineSegments':

				object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));

				break;

			case 'PointCloud':
			case 'Points':

				object = new Points(getGeometry(data.geometry), getMaterial(data.material));

				break;

			case 'Sprite':

				object = new Sprite(getMaterial(data.material));

				break;

			case 'Group':

				object = new Group();

				break;

			default:

				object = new Object3D();
			}

			object.uuid = data.uuid;

			if (data.name !== undefined) object.name = data.name;

			if (data.matrix !== undefined) {
				object.matrix.fromArray(data.matrix);

				if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
				if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
			} else {
				if (data.position !== undefined) object.position.fromArray(data.position);
				if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
				if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
				if (data.scale !== undefined) object.scale.fromArray(data.scale);
			}

			if (data.castShadow !== undefined) object.castShadow = data.castShadow;
			if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;

			if (data.shadow) {
				if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
				if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
				if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
				if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
			}

			if (data.visible !== undefined) object.visible = data.visible;
			if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
			if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
			if (data.userData !== undefined) object.userData = data.userData;
			if (data.layers !== undefined) object.layers.mask = data.layers;

			if (data.children !== undefined) {
				const { children } = data;

				for (let i = 0; i < children.length; i++) {
					object.add(this.parseObject(children[i], geometries, materials));
				}
			}

			if (data.type === 'LOD') {
				const { levels } = data;

				for (let l = 0; l < levels.length; l++) {
					const level = levels[l];
					const child = object.getObjectByProperty('uuid', level.object);

					if (child !== undefined) {
						object.addLevel(child, level.distance);
					}
				}
			}

			return object;
		},

	});

	var TEXTURE_MAPPING = {
		UVMapping,
		CubeReflectionMapping,
		CubeRefractionMapping,
		EquirectangularReflectionMapping,
		EquirectangularRefractionMapping,
		SphericalReflectionMapping,
		CubeUVReflectionMapping,
		CubeUVRefractionMapping,
	};

	var TEXTURE_WRAPPING = {
		RepeatWrapping,
		ClampToEdgeWrapping,
		MirroredRepeatWrapping,
	};

	var TEXTURE_FILTER = {
		NearestFilter,
		NearestMipMapNearestFilter,
		NearestMipMapLinearFilter,
		LinearFilter,
		LinearMipMapNearestFilter,
		LinearMipMapLinearFilter,
	};

	/**
	 * @author thespite / http://clicktorelease.com/
	 */


	function ImageBitmapLoader(manager) {
		if (typeof createImageBitmap === 'undefined') {
			console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
		}

		if (typeof fetch === 'undefined') {
			console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
		}

		this.manager = manager !== undefined ? manager : DefaultLoadingManager;
		this.options = undefined;
	}

	ImageBitmapLoader.prototype = {

		constructor: ImageBitmapLoader,

		setOptions: function setOptions(options) {
			this.options = options;

			return this;
		},

		load(url, onLoad, onProgress, onError) {
			if (url === undefined) url = '';

			if (this.path !== undefined) url = this.path + url;

			url = this.manager.resolveURL(url);

			const scope = this;

			const cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);

				setTimeout(() => {
					if (onLoad) onLoad(cached);

					scope.manager.itemEnd(url);
				}, 0);

				return cached;
			}

			fetch(url).then((res) => res.blob()).then((blob) => createImageBitmap(blob, scope.options)).then((imageBitmap) => {
				Cache.add(url, imageBitmap);

				if (onLoad) onLoad(imageBitmap);

				scope.manager.itemEnd(url);
			})
				.catch((e) => {
					if (onError) onError(e);

					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				});
		},

		setCrossOrigin(/* value */) {
			return this;
		},

		setPath(value) {
			this.path = value;
			return this;
		},

	};

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
	 * */

	function ShapePath() {
		this.type = 'ShapePath';

		this.color = new Color();

		this.subPaths = [];
		this.currentPath = null;
	}

	Object.assign(ShapePath.prototype, {

		moveTo(x, y) {
			this.currentPath = new Path();
			this.subPaths.push(this.currentPath);
			this.currentPath.moveTo(x, y);
		},

		lineTo(x, y) {
			this.currentPath.lineTo(x, y);
		},

		quadraticCurveTo(aCPx, aCPy, aX, aY) {
			this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
		},

		bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
			this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
		},

		splineThru(pts) {
			this.currentPath.splineThru(pts);
		},

		toShapes(isCCW, noHoles) {
			function toShapesNoHoles(inSubpaths) {
				const shapes = [];

				for (let i = 0, l = inSubpaths.length; i < l; i++) {
					const tmpPath = inSubpaths[i];

					const tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;

					shapes.push(tmpShape);
				}

				return shapes;
			}

			function isPointInsidePolygon(inPt, inPolygon) {
				const polyLen = inPolygon.length;

				// inPt on polygon contour => immediate success    or
				// toggling of inside/outside at every single! intersection point of an edge
				//  with the horizontal line through inPt, left of inPt
				//  not counting lowerY endpoints of edges and whole edges on that line
				let inside = false;
				for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
					let edgeLowPt = inPolygon[p];
					let edgeHighPt = inPolygon[q];

					let edgeDx = edgeHighPt.x - edgeLowPt.x;
					let edgeDy = edgeHighPt.y - edgeLowPt.y;

					if (Math.abs(edgeDy) > Number.EPSILON) {
						// not parallel
						if (edgeDy < 0) {
							edgeLowPt = inPolygon[q]; edgeDx = -edgeDx;
							edgeHighPt = inPolygon[p]; edgeDy = -edgeDy;
						}
						if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y)) 		continue;

						if (inPt.y === edgeLowPt.y) {
							if (inPt.x === edgeLowPt.x)		return	true;		// inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!
						} else {
							const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
							if (perpEdge === 0)				return	true;		// inPt is on contour ?
							if (perpEdge < 0) 				continue;
							inside = !inside;		// true intersection left of inPt
						}
					} else {
						// parallel or collinear
						if (inPt.y !== edgeLowPt.y) 		continue;			// parallel
						// edge lies on the same horizontal line as inPt
						if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x))
							 || ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x)))		return	true;	// inPt: Point on contour !
						// continue;
					}
				}

				return	inside;
			}

			const { isClockWise } = ShapeUtils;

			const { subPaths } = this;
			if (subPaths.length === 0) return [];

			if (noHoles === true)	return	toShapesNoHoles(subPaths);


			let solid; let tmpPath; let tmpShape; const
				shapes = [];

			if (subPaths.length === 1) {
				tmpPath = subPaths[0];
				tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push(tmpShape);
				return shapes;
			}

			let holesFirst = !isClockWise(subPaths[0].getPoints());
			holesFirst = isCCW ? !holesFirst : holesFirst;

			// console.log("Holes first", holesFirst);

			const betterShapeHoles = [];
			const newShapes = [];
			let newShapeHoles = [];
			let mainIdx = 0;
			let tmpPoints;

			newShapes[mainIdx] = undefined;
			newShapeHoles[mainIdx] = [];

			for (var i = 0, l = subPaths.length; i < l; i++) {
				tmpPath = subPaths[i];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise(tmpPoints);
				solid = isCCW ? !solid : solid;

				if (solid) {
					if ((!holesFirst) && (newShapes[mainIdx]))	mainIdx++;

					newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
					newShapes[mainIdx].s.curves = tmpPath.curves;

					if (holesFirst)	mainIdx++;
					newShapeHoles[mainIdx] = [];

					// console.log('cw', i);
				} else {
					newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });

					// console.log('ccw', i);
				}
			}

			// only Holes? -> probably all Shapes with wrong orientation
			if (!newShapes[0])	return	toShapesNoHoles(subPaths);


			if (newShapes.length > 1) {
				let ambiguous = false;
				const toChange = [];

				for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
					betterShapeHoles[sIdx] = [];
				}

				for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
					const sho = newShapeHoles[sIdx];

					for (let hIdx = 0; hIdx < sho.length; hIdx++) {
						const ho = sho[hIdx];
						let hole_unassigned = true;

						for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
							if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
								if (sIdx !== s2Idx)	toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
								if (hole_unassigned) {
									hole_unassigned = false;
									betterShapeHoles[s2Idx].push(ho);
								} else {
									ambiguous = true;
								}
							}
						}
						if (hole_unassigned) {
							betterShapeHoles[sIdx].push(ho);
						}
					}
				}
				// console.log("ambiguous: ", ambiguous);
				if (toChange.length > 0) {
					// console.log("to change: ", toChange);
					if (!ambiguous)	newShapeHoles = betterShapeHoles;
				}
			}

			let tmpHoles;

			for (var i = 0, il = newShapes.length; i < il; i++) {
				tmpShape = newShapes[i].s;
				shapes.push(tmpShape);
				tmpHoles = newShapeHoles[i];

				for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
					tmpShape.holes.push(tmpHoles[j].h);
				}
			}

			// console.log("shape", shapes);

			return shapes;
		},

	});

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author mrdoob / http://mrdoob.com/
	 */


	function Font(data) {
		this.type = 'Font';

		this.data = data;
	}

	Object.assign(Font.prototype, {

		isFont: true,

		generateShapes(text, size) {
			if (size === undefined) size = 100;

			const shapes = [];
			const paths = createPaths(text, size, this.data);

			for (let p = 0, pl = paths.length; p < pl; p++) {
				Array.prototype.push.apply(shapes, paths[p].toShapes());
			}

			return shapes;
		},

	});

	function createPaths(text, size, data) {
		const chars = Array.from ? Array.from(text) : String(text).split(''); // see #13988
		const scale = size / data.resolution;
		const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;

		const paths = [];

		let offsetX = 0; let
			offsetY = 0;

		for (let i = 0; i < chars.length; i++) {
			const char = chars[i];

			if (char === '\n') {
				offsetX = 0;
				offsetY -= line_height;
			} else {
				const ret = createPath(char, scale, offsetX, offsetY, data);
				offsetX += ret.offsetX;
				paths.push(ret.path);
			}
		}

		return paths;
	}

	function createPath(char, scale, offsetX, offsetY, data) {
		const glyph = data.glyphs[char] || data.glyphs['?'];

		if (!glyph) return;

		const path = new ShapePath();

		let x; let y; let cpx; let cpy; let cpx1; let cpy1; let cpx2; let
			cpy2;

		if (glyph.o) {
			const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

			for (let i = 0, l = outline.length; i < l;) {
				const action = outline[i++];

				switch (action) {
				case 'm': // moveTo

					x = outline[i++] * scale + offsetX;
					y = outline[i++] * scale + offsetY;

					path.moveTo(x, y);

					break;

				case 'l': // lineTo

					x = outline[i++] * scale + offsetX;
					y = outline[i++] * scale + offsetY;

					path.lineTo(x, y);

					break;

				case 'q': // quadraticCurveTo

					cpx = outline[i++] * scale + offsetX;
					cpy = outline[i++] * scale + offsetY;
					cpx1 = outline[i++] * scale + offsetX;
					cpy1 = outline[i++] * scale + offsetY;

					path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);

					break;

				case 'b': // bezierCurveTo

					cpx = outline[i++] * scale + offsetX;
					cpy = outline[i++] * scale + offsetY;
					cpx1 = outline[i++] * scale + offsetX;
					cpy1 = outline[i++] * scale + offsetY;
					cpx2 = outline[i++] * scale + offsetX;
					cpy2 = outline[i++] * scale + offsetY;

					path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);

					break;
				}
			}
		}

		return { offsetX: glyph.ha * scale, path };
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function FontLoader(manager) {
		this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
	}

	Object.assign(FontLoader.prototype, {

		load(url, onLoad, onProgress, onError) {
			const scope = this;

			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.load(url, (text) => {
				let json;

				try {
					json = JSON.parse(text);
				} catch (e) {
					console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
					json = JSON.parse(text.substring(65, text.length - 2));
				}

				const font = scope.parse(json);

				if (onLoad) onLoad(font);
			}, onProgress, onError);
		},

		parse(json) {
			return new Font(json);
		},

		setPath(value) {
			this.path = value;
			return this;
		},

	});

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Loader() {}

	Loader.Handlers = {

		handlers: [],

		add(regex, loader) {
			this.handlers.push(regex, loader);
		},

		get(file) {
			const { handlers } = this;

			for (let i = 0, l = handlers.length; i < l; i += 2) {
				const regex = handlers[i];
				const loader = handlers[i + 1];

				if (regex.test(file)) {
					return loader;
				}
			}

			return null;
		},

	};

	Object.assign(Loader.prototype, {

		crossOrigin: 'anonymous',

		onLoadStart() {},

		onLoadProgress() {},

		onLoadComplete() {},

		initMaterials(materials, texturePath, crossOrigin) {
			const array = [];

			for (let i = 0; i < materials.length; ++i) {
				array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
			}

			return array;
		},

		createMaterial: (function () {
			const BlendingMode = {
				NoBlending,
				NormalBlending,
				AdditiveBlending,
				SubtractiveBlending,
				MultiplyBlending,
				CustomBlending,
			};

			const color = new Color();
			const textureLoader = new TextureLoader();
			const materialLoader = new MaterialLoader();

			return function createMaterial(m, texturePath, crossOrigin) {
				// convert from old material format

				const textures = {};

				function loadTexture(path, repeat, offset, wrap, anisotropy) {
					const fullPath = texturePath + path;
					const loader = Loader.Handlers.get(fullPath);

					let texture;

					if (loader !== null) {
						texture = loader.load(fullPath);
					} else {
						textureLoader.setCrossOrigin(crossOrigin);
						texture = textureLoader.load(fullPath);
					}

					if (repeat !== undefined) {
						texture.repeat.fromArray(repeat);

						if (repeat[0] !== 1) texture.wrapS = RepeatWrapping;
						if (repeat[1] !== 1) texture.wrapT = RepeatWrapping;
					}

					if (offset !== undefined) {
						texture.offset.fromArray(offset);
					}

					if (wrap !== undefined) {
						if (wrap[0] === 'repeat') texture.wrapS = RepeatWrapping;
						if (wrap[0] === 'mirror') texture.wrapS = MirroredRepeatWrapping;

						if (wrap[1] === 'repeat') texture.wrapT = RepeatWrapping;
						if (wrap[1] === 'mirror') texture.wrapT = MirroredRepeatWrapping;
					}

					if (anisotropy !== undefined) {
						texture.anisotropy = anisotropy;
					}

					const uuid = _Math.generateUUID();

					textures[uuid] = texture;

					return uuid;
				}

				//

				const json = {
					uuid: _Math.generateUUID(),
					type: 'MeshLambertMaterial',
				};

				for (const name in m) {
					const value = m[name];

					switch (name) {
					case 'DbgColor':
					case 'DbgIndex':
					case 'opticalDensity':
					case 'illumination':
						break;
					case 'DbgName':
						json.name = value;
						break;
					case 'blending':
						json.blending = BlendingMode[value];
						break;
					case 'colorAmbient':
					case 'mapAmbient':
						console.warn('THREE.Loader.createMaterial:', name, 'is no longer supported.');
						break;
					case 'colorDiffuse':
						json.color = color.fromArray(value).getHex();
						break;
					case 'colorSpecular':
						json.specular = color.fromArray(value).getHex();
						break;
					case 'colorEmissive':
						json.emissive = color.fromArray(value).getHex();
						break;
					case 'specularCoef':
						json.shininess = value;
						break;
					case 'shading':
						if (value.toLowerCase() === 'basic') json.type = 'MeshBasicMaterial';
						if (value.toLowerCase() === 'phong') json.type = 'MeshPhongMaterial';
						if (value.toLowerCase() === 'standard') json.type = 'MeshStandardMaterial';
						break;
					case 'mapDiffuse':
						json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
						break;
					case 'mapDiffuseRepeat':
					case 'mapDiffuseOffset':
					case 'mapDiffuseWrap':
					case 'mapDiffuseAnisotropy':
						break;
					case 'mapEmissive':
						json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
						break;
					case 'mapEmissiveRepeat':
					case 'mapEmissiveOffset':
					case 'mapEmissiveWrap':
					case 'mapEmissiveAnisotropy':
						break;
					case 'mapLight':
						json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
						break;
					case 'mapLightRepeat':
					case 'mapLightOffset':
					case 'mapLightWrap':
					case 'mapLightAnisotropy':
						break;
					case 'mapAO':
						json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
						break;
					case 'mapAORepeat':
					case 'mapAOOffset':
					case 'mapAOWrap':
					case 'mapAOAnisotropy':
						break;
					case 'mapBump':
						json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
						break;
					case 'mapBumpScale':
						json.bumpScale = value;
						break;
					case 'mapBumpRepeat':
					case 'mapBumpOffset':
					case 'mapBumpWrap':
					case 'mapBumpAnisotropy':
						break;
					case 'mapNormal':
						json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
						break;
					case 'mapNormalFactor':
						json.normalScale = value;
						break;
					case 'mapNormalRepeat':
					case 'mapNormalOffset':
					case 'mapNormalWrap':
					case 'mapNormalAnisotropy':
						break;
					case 'mapSpecular':
						json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
						break;
					case 'mapSpecularRepeat':
					case 'mapSpecularOffset':
					case 'mapSpecularWrap':
					case 'mapSpecularAnisotropy':
						break;
					case 'mapMetalness':
						json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
						break;
					case 'mapMetalnessRepeat':
					case 'mapMetalnessOffset':
					case 'mapMetalnessWrap':
					case 'mapMetalnessAnisotropy':
						break;
					case 'mapRoughness':
						json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
						break;
					case 'mapRoughnessRepeat':
					case 'mapRoughnessOffset':
					case 'mapRoughnessWrap':
					case 'mapRoughnessAnisotropy':
						break;
					case 'mapAlpha':
						json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
						break;
					case 'mapAlphaRepeat':
					case 'mapAlphaOffset':
					case 'mapAlphaWrap':
					case 'mapAlphaAnisotropy':
						break;
					case 'flipSided':
						json.side = BackSide;
						break;
					case 'doubleSided':
						json.side = DoubleSide;
						break;
					case 'transparency':
						console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');
						json.opacity = value;
						break;
					case 'depthTest':
					case 'depthWrite':
					case 'colorWrite':
					case 'opacity':
					case 'reflectivity':
					case 'transparent':
					case 'visible':
					case 'wireframe':
						json[name] = value;
						break;
					case 'vertexColors':
						if (value === true) json.vertexColors = VertexColors;
						if (value === 'face') json.vertexColors = FaceColors;
						break;
					default:
						console.error('THREE.Loader.createMaterial: Unsupported', name, value);
						break;
					}
				}

				if (json.type === 'MeshBasicMaterial') delete json.emissive;
				if (json.type !== 'MeshPhongMaterial') delete json.specular;

				if (json.opacity < 1) json.transparent = true;

				materialLoader.setTextures(textures);

				return materialLoader.parse(json);
			};
		}()),

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	let context;

	const AudioContext = {

		getContext() {
			if (context === undefined) {
				context = new (window.AudioContext || window.webkitAudioContext)();
			}

			return context;
		},

		setContext(value) {
			context = value;
		},

	};

	/**
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */

	function AudioLoader(manager) {
		this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
	}

	Object.assign(AudioLoader.prototype, {

		load(url, onLoad, onProgress, onError) {
			const loader = new FileLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.setPath(this.path);
			loader.load(url, (buffer) => {
				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				const bufferCopy = buffer.slice(0);

				const context = AudioContext.getContext();
				context.decodeAudioData(bufferCopy, (audioBuffer) => {
					onLoad(audioBuffer);
				});
			}, onProgress, onError);
		},

		setPath(value) {
			this.path = value;
			return this;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function StereoCamera() {
		this.type = 'StereoCamera';

		this.aspect = 1;

		this.eyeSep = 0.064;

		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable(1);
		this.cameraL.matrixAutoUpdate = false;

		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable(2);
		this.cameraR.matrixAutoUpdate = false;
	}

	Object.assign(StereoCamera.prototype, {

		update: (function () {
			let instance; let focus; let fov; let aspect; let near; let far; let zoom; let
				eyeSep;

			const eyeRight = new Matrix4();
			const eyeLeft = new Matrix4();

			return function update(camera) {
				const needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov
													|| aspect !== camera.aspect * this.aspect || near !== camera.near
													|| far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;

				if (needsUpdate) {
					instance = this;
					focus = camera.focus;
					fov = camera.fov;
					aspect = camera.aspect * this.aspect;
					near = camera.near;
					far = camera.far;
					zoom = camera.zoom;

					// Off-axis stereoscopic effect based on
					// http://paulbourke.net/stereographics/stereorender/

					const projectionMatrix = camera.projectionMatrix.clone();
					eyeSep = this.eyeSep / 2;
					const eyeSepOnProjection = eyeSep * near / focus;
					const ymax = (near * Math.tan(_Math.DEG2RAD * fov * 0.5)) / zoom;
					let xmin; let
						xmax;

					// translate xOffset

					eyeLeft.elements[12] = -eyeSep;
					eyeRight.elements[12] = eyeSep;

					// for left eye

					xmin = -ymax * aspect + eyeSepOnProjection;
					xmax = ymax * aspect + eyeSepOnProjection;

					projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
					projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);

					this.cameraL.projectionMatrix.copy(projectionMatrix);

					// for right eye

					xmin = -ymax * aspect - eyeSepOnProjection;
					xmax = ymax * aspect - eyeSepOnProjection;

					projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
					projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);

					this.cameraR.projectionMatrix.copy(projectionMatrix);
				}

				this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);
				this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);
			};
		}()),

	});

	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */

	function CubeCamera(near, far, cubeResolution, options) {
		Object3D.call(this);

		this.type = 'CubeCamera';

		const fov = 90; const
			aspect = 1;

		const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
		cameraPX.up.set(0, -1, 0);
		cameraPX.lookAt(new Vector3(1, 0, 0));
		this.add(cameraPX);

		const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
		cameraNX.up.set(0, -1, 0);
		cameraNX.lookAt(new Vector3(-1, 0, 0));
		this.add(cameraNX);

		const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
		cameraPY.up.set(0, 0, 1);
		cameraPY.lookAt(new Vector3(0, 1, 0));
		this.add(cameraPY);

		const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
		cameraNY.up.set(0, 0, -1);
		cameraNY.lookAt(new Vector3(0, -1, 0));
		this.add(cameraNY);

		const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
		cameraPZ.up.set(0, -1, 0);
		cameraPZ.lookAt(new Vector3(0, 0, 1));
		this.add(cameraPZ);

		const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
		cameraNZ.up.set(0, -1, 0);
		cameraNZ.lookAt(new Vector3(0, 0, -1));
		this.add(cameraNZ);

		options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

		this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
		this.renderTarget.texture.name = 'CubeCamera';

		this.update = function (renderer, scene) {
			if (this.parent === null) this.updateMatrixWorld();

			const { renderTarget } = this;
			const { generateMipmaps } = renderTarget.texture;

			renderTarget.texture.generateMipmaps = false;

			renderTarget.activeCubeFace = 0;
			renderer.render(scene, cameraPX, renderTarget);

			renderTarget.activeCubeFace = 1;
			renderer.render(scene, cameraNX, renderTarget);

			renderTarget.activeCubeFace = 2;
			renderer.render(scene, cameraPY, renderTarget);

			renderTarget.activeCubeFace = 3;
			renderer.render(scene, cameraNY, renderTarget);

			renderTarget.activeCubeFace = 4;
			renderer.render(scene, cameraPZ, renderTarget);

			renderTarget.texture.generateMipmaps = generateMipmaps;

			renderTarget.activeCubeFace = 5;
			renderer.render(scene, cameraNZ, renderTarget);

			renderer.setRenderTarget(null);
		};

		this.clear = function (renderer, color, depth, stencil) {
			const { renderTarget } = this;

			for (let i = 0; i < 6; i++) {
				renderTarget.activeCubeFace = i;
				renderer.setRenderTarget(renderTarget);

				renderer.clear(color, depth, stencil);
			}

			renderer.setRenderTarget(null);
		};
	}

	CubeCamera.prototype = Object.create(Object3D.prototype);
	CubeCamera.prototype.constructor = CubeCamera;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Clock(autoStart) {
		this.autoStart = (autoStart !== undefined) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;
	}

	Object.assign(Clock.prototype, {

		start() {
			this.startTime = (typeof performance === 'undefined' ? Date : performance).now(); // see #10732

			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;
		},

		stop() {
			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;
		},

		getElapsedTime() {
			this.getDelta();
			return this.elapsedTime;
		},

		getDelta() {
			let diff = 0;

			if (this.autoStart && !this.running) {
				this.start();
				return 0;
			}

			if (this.running) {
				const newTime = (typeof performance === 'undefined' ? Date : performance).now();

				diff = (newTime - this.oldTime) / 1000;
				this.oldTime = newTime;

				this.elapsedTime += diff;
			}

			return diff;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AudioListener() {
		Object3D.call(this);

		this.type = 'AudioListener';

		this.context = AudioContext.getContext();

		this.gain = this.context.createGain();
		this.gain.connect(this.context.destination);

		this.filter = null;

		this.timeDelta = 0;
	}

	AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {

		constructor: AudioListener,

		getInput() {
			return this.gain;
		},

		removeFilter() {
			if (this.filter !== null) {
				this.gain.disconnect(this.filter);
				this.filter.disconnect(this.context.destination);
				this.gain.connect(this.context.destination);
				this.filter = null;
			}

			return this;
		},

		getFilter() {
			return this.filter;
		},

		setFilter(value) {
			if (this.filter !== null) {
				this.gain.disconnect(this.filter);
				this.filter.disconnect(this.context.destination);
			} else {
				this.gain.disconnect(this.context.destination);
			}

			this.filter = value;
			this.gain.connect(this.filter);
			this.filter.connect(this.context.destination);

			return this;
		},

		getMasterVolume() {
			return this.gain.gain.value;
		},

		setMasterVolume(value) {
			this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);

			return this;
		},

		updateMatrixWorld: (function () {
			const position = new Vector3();
			const quaternion = new Quaternion();
			const scale = new Vector3();

			const orientation = new Vector3();
			const clock = new Clock();

			return function updateMatrixWorld(force) {
				Object3D.prototype.updateMatrixWorld.call(this, force);

				const { listener } = this.context;
				const { up } = this;

				this.timeDelta = clock.getDelta();

				this.matrixWorld.decompose(position, quaternion, scale);

				orientation.set(0, 0, -1).applyQuaternion(quaternion);

				if (listener.positionX) {
					// code path for Chrome (see #14393)

					const endTime = this.context.currentTime + this.timeDelta;

					listener.positionX.linearRampToValueAtTime(position.x, endTime);
					listener.positionY.linearRampToValueAtTime(position.y, endTime);
					listener.positionZ.linearRampToValueAtTime(position.z, endTime);
					listener.forwardX.linearRampToValueAtTime(orientation.x, endTime);
					listener.forwardY.linearRampToValueAtTime(orientation.y, endTime);
					listener.forwardZ.linearRampToValueAtTime(orientation.z, endTime);
					listener.upX.linearRampToValueAtTime(up.x, endTime);
					listener.upY.linearRampToValueAtTime(up.y, endTime);
					listener.upZ.linearRampToValueAtTime(up.z, endTime);
				} else {
					listener.setPosition(position.x, position.y, position.z);
					listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
				}
			};
		}()),

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */

	function Audio(listener) {
		Object3D.call(this);

		this.type = 'Audio';

		this.listener = listener;
		this.context = listener.context;

		this.gain = this.context.createGain();
		this.gain.connect(listener.getInput());

		this.autoplay = false;

		this.buffer = null;
		this.detune = 0;
		this.loop = false;
		this.startTime = 0;
		this.offset = 0;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.sourceType = 'empty';

		this.filters = [];
	}

	Audio.prototype = Object.assign(Object.create(Object3D.prototype), {

		constructor: Audio,

		getOutput() {
			return this.gain;
		},

		setNodeSource(audioNode) {
			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();

			return this;
		},

		setMediaElementSource(mediaElement) {
			this.hasPlaybackControl = false;
			this.sourceType = 'mediaNode';
			this.source = this.context.createMediaElementSource(mediaElement);
			this.connect();

			return this;
		},

		setBuffer(audioBuffer) {
			this.buffer = audioBuffer;
			this.sourceType = 'buffer';

			if (this.autoplay) this.play();

			return this;
		},

		play() {
			if (this.isPlaying === true) {
				console.warn('THREE.Audio: Audio is already playing.');
				return;
			}

			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			const source = this.context.createBufferSource();

			source.buffer = this.buffer;
			source.detune.value = this.detune;
			source.loop = this.loop;
			source.onended = this.onEnded.bind(this);
			source.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
			this.startTime = this.context.currentTime;
			source.start(this.startTime, this.offset);

			this.isPlaying = true;

			this.source = source;

			return this.connect();
		},

		pause() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			if (this.isPlaying === true) {
				this.source.stop();
				this.source.onended = null;
				this.offset += (this.context.currentTime - this.startTime) * this.playbackRate;
				this.isPlaying = false;
			}

			return this;
		},

		stop() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this.source.stop();
			this.source.onended = null;
			this.offset = 0;
			this.isPlaying = false;

			return this;
		},

		connect() {
			if (this.filters.length > 0) {
				this.source.connect(this.filters[0]);

				for (let i = 1, l = this.filters.length; i < l; i++) {
					this.filters[i - 1].connect(this.filters[i]);
				}

				this.filters[this.filters.length - 1].connect(this.getOutput());
			} else {
				this.source.connect(this.getOutput());
			}

			return this;
		},

		disconnect() {
			if (this.filters.length > 0) {
				this.source.disconnect(this.filters[0]);

				for (let i = 1, l = this.filters.length; i < l; i++) {
					this.filters[i - 1].disconnect(this.filters[i]);
				}

				this.filters[this.filters.length - 1].disconnect(this.getOutput());
			} else {
				this.source.disconnect(this.getOutput());
			}

			return this;
		},

		getFilters() {
			return this.filters;
		},

		setFilters(value) {
			if (!value) value = [];

			if (this.isPlaying === true) {
				this.disconnect();
				this.filters = value;
				this.connect();
			} else {
				this.filters = value;
			}

			return this;
		},

		setDetune(value) {
			this.detune = value;

			if (this.isPlaying === true) {
				this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
			}

			return this;
		},

		getDetune() {
			return this.detune;
		},

		getFilter() {
			return this.getFilters()[0];
		},

		setFilter(filter) {
			return this.setFilters(filter ? [filter] : []);
		},

		setPlaybackRate(value) {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this.playbackRate = value;

			if (this.isPlaying === true) {
				this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
			}

			return this;
		},

		getPlaybackRate() {
			return this.playbackRate;
		},

		onEnded() {
			this.isPlaying = false;
		},

		getLoop() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return false;
			}

			return this.loop;
		},

		setLoop(value) {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this.loop = value;

			if (this.isPlaying === true) {
				this.source.loop = this.loop;
			}

			return this;
		},

		getVolume() {
			return this.gain.gain.value;
		},

		setVolume(value) {
			this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);

			return this;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function PositionalAudio(listener) {
		Audio.call(this, listener);

		this.panner = this.context.createPanner();
		this.panner.connect(this.gain);
	}

	PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {

		constructor: PositionalAudio,

		getOutput() {
			return this.panner;
		},

		getRefDistance() {
			return this.panner.refDistance;
		},

		setRefDistance(value) {
			this.panner.refDistance = value;

			return this;
		},

		getRolloffFactor() {
			return this.panner.rolloffFactor;
		},

		setRolloffFactor(value) {
			this.panner.rolloffFactor = value;

			return this;
		},

		getDistanceModel() {
			return this.panner.distanceModel;
		},

		setDistanceModel(value) {
			this.panner.distanceModel = value;

			return this;
		},

		getMaxDistance() {
			return this.panner.maxDistance;
		},

		setMaxDistance(value) {
			this.panner.maxDistance = value;

			return this;
		},

		setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
			this.panner.coneInnerAngle = coneInnerAngle;
			this.panner.coneOuterAngle = coneOuterAngle;
			this.panner.coneOuterGain = coneOuterGain;

			return this;
		},

		updateMatrixWorld: (function () {
			const position = new Vector3();
			const quaternion = new Quaternion();
			const scale = new Vector3();

			const orientation = new Vector3();

			return function updateMatrixWorld(force) {
				Object3D.prototype.updateMatrixWorld.call(this, force);

				if (this.isPlaying === false) return;

				this.matrixWorld.decompose(position, quaternion, scale);

				orientation.set(0, 0, 1).applyQuaternion(quaternion);

				const { panner } = this;

				if (panner.positionX) {
					// code path for Chrome and Firefox (see #14393)

					const endTime = this.context.currentTime + this.listener.timeDelta;

					panner.positionX.linearRampToValueAtTime(position.x, endTime);
					panner.positionY.linearRampToValueAtTime(position.y, endTime);
					panner.positionZ.linearRampToValueAtTime(position.z, endTime);
					panner.orientationX.linearRampToValueAtTime(orientation.x, endTime);
					panner.orientationY.linearRampToValueAtTime(orientation.y, endTime);
					panner.orientationZ.linearRampToValueAtTime(orientation.z, endTime);
				} else {
					panner.setPosition(position.x, position.y, position.z);
					panner.setOrientation(orientation.x, orientation.y, orientation.z);
				}
			};
		}()),


	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AudioAnalyser(audio, fftSize) {
		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

		this.data = new Uint8Array(this.analyser.frequencyBinCount);

		audio.getOutput().connect(this.analyser);
	}

	Object.assign(AudioAnalyser.prototype, {

		getFrequencyData() {
			this.analyser.getByteFrequencyData(this.data);

			return this.data;
		},

		getAverageFrequency() {
			let value = 0; const
				data = this.getFrequencyData();

			for (let i = 0; i < data.length; i++) {
				value += data[i];
			}

			return value / data.length;
		},

	});

	/**
	 *
	 * Buffered scene graph property that allows weighted accumulation.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function PropertyMixer(binding, typeName, valueSize) {
		this.binding = binding;
		this.valueSize = valueSize;

		let bufferType = Float64Array;
		let mixFunction;

		switch (typeName) {
		case 'quaternion':
			mixFunction = this._slerp;
			break;

		case 'string':
		case 'bool':
			bufferType = Array;
			mixFunction = this._select;
			break;

		default:
			mixFunction = this._lerp;
		}

		this.buffer = new bufferType(valueSize * 4);
		// layout: [ incoming | accu0 | accu1 | orig ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property

		this._mixBufferRegion = mixFunction;

		this.cumulativeWeight = 0;

		this.useCount = 0;
		this.referenceCount = 0;
	}

	Object.assign(PropertyMixer.prototype, {

		// accumulate data in the 'incoming' region into 'accu<i>'
		accumulate(accuIndex, weight) {
			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place

			const { buffer } = this;
			const stride = this.valueSize;
			const offset = accuIndex * stride + stride;

			let currentWeight = this.cumulativeWeight;

			if (currentWeight === 0) {
				// accuN := incoming * weight

				for (let i = 0; i !== stride; ++i) {
					buffer[offset + i] = buffer[i];
				}

				currentWeight = weight;
			} else {
				// accuN := accuN + incoming * weight

				currentWeight += weight;
				const mix = weight / currentWeight;
				this._mixBufferRegion(buffer, offset, 0, mix, stride);
			}

			this.cumulativeWeight = currentWeight;
		},

		// apply the state of 'accu<i>' to the binding when accus differ
		apply(accuIndex) {
			const stride = this.valueSize;
			const { buffer } = this;
			const offset = accuIndex * stride + stride;

			const weight = this.cumulativeWeight;

			const { binding } = this;

			this.cumulativeWeight = 0;

			if (weight < 1) {
				// accuN := accuN + original * ( 1 - cumulativeWeight )

				const originalValueOffset = stride * 3;

				this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride,
				);
			}

			for (let i = stride, e = stride + stride; i !== e; ++i) {
				if (buffer[i] !== buffer[i + stride]) {
					// value has changed -> update scene graph

					binding.setValue(buffer, offset);
					break;
				}
			}
		},

		// remember the state of the bound property and copy it to both accus
		saveOriginalState() {
			const { binding } = this;

			const { buffer } = this;
			const stride = this.valueSize;

			const originalValueOffset = stride * 3;

			binding.getValue(buffer, originalValueOffset);

			// accu[0..1] := orig -- initially detect changes against the original
			for (let i = stride, e = originalValueOffset; i !== e; ++i) {
				buffer[i] = buffer[originalValueOffset + (i % stride)];
			}

			this.cumulativeWeight = 0;
		},

		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState() {
			const originalValueOffset = this.valueSize * 3;
			this.binding.setValue(this.buffer, originalValueOffset);
		},


		// mix functions

		_select(buffer, dstOffset, srcOffset, t, stride) {
			if (t >= 0.5) {
				for (let i = 0; i !== stride; ++i) {
					buffer[dstOffset + i] = buffer[srcOffset + i];
				}
			}
		},

		_slerp(buffer, dstOffset, srcOffset, t) {
			Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
		},

		_lerp(buffer, dstOffset, srcOffset, t, stride) {
			const s = 1 - t;

			for (let i = 0; i !== stride; ++i) {
				const j = dstOffset + i;

				buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
			}
		},

	});

	/**
	 *
	 * A reference to a real property in the scene graph.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	// Characters [].:/ are reserved for track binding syntax.
	const RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

	function Composite(targetGroup, path, optionalParsedPath) {
		const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);

		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_(path, parsedPath);
	}

	Object.assign(Composite.prototype, {

		getValue(array, offset) {
			this.bind(); // bind all binding

			const firstValidIndex = this._targetGroup.nCachedObjects_;
			const binding = this._bindings[firstValidIndex];

			// and only call .getValue on the first
			if (binding !== undefined) binding.getValue(array, offset);
		},

		setValue(array, offset) {
			const bindings = this._bindings;

			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].setValue(array, offset);
			}
		},

		bind() {
			const bindings = this._bindings;

			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].bind();
			}
		},

		unbind() {
			const bindings = this._bindings;

			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].unbind();
			}
		},

	});


	function PropertyBinding(rootNode, path, parsedPath) {
		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);

		this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;

		this.rootNode = rootNode;
	}

	Object.assign(PropertyBinding, {

		Composite,

		create(root, path, parsedPath) {
			if (!(root && root.isAnimationObjectGroup)) {
				return new PropertyBinding(root, path, parsedPath);
			}
			return new PropertyBinding.Composite(root, path, parsedPath);
		},

		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param  {string} name Node name to be sanitized.
		 * @return {string}
		 */
		sanitizeNodeName: (function () {
			const reservedRe = new RegExp(`[${RESERVED_CHARS_RE}]`, 'g');

			return function sanitizeNodeName(name) {
				return name.replace(/\s/g, '_').replace(reservedRe, '');
			};
		}()),

		parseTrackName: (function () {
			// Attempts to allow node names from any language. ES5's `\w` regexp matches
			// only latin characters, and the unicode \p{L} is not yet supported. So
			// instead, we exclude reserved characters and match everything else.
			const wordChar = `[^${RESERVED_CHARS_RE}]`;
			const wordCharOrDot = `[^${RESERVED_CHARS_RE.replace('\\.', '')}]`;

			// Parent directories, delimited by '/' or ':'. Currently unused, but must
			// be matched to parse the rest of the track name.
			const directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', wordChar);

			// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
			const nodeRe = /(WCOD+)?/.source.replace('WCOD', wordCharOrDot);

			// Object on target node, and accessor. May not contain reserved
			// characters. Accessor may contain any character except closing bracket.
			const objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', wordChar);

			// Property and accessor. May not contain reserved characters. Accessor may
			// contain any non-bracket characters.
			const propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', wordChar);

			const trackRe = new RegExp(`${''
				+ '^'}${
				 directoryRe
				 }${nodeRe
				 }${objectRe
				 }${propertyRe
				 }$`);

			const supportedObjectNames = ['material', 'materials', 'bones'];

			return function parseTrackName(trackName) {
				const matches = trackRe.exec(trackName);

				if (!matches) {
					throw new Error(`PropertyBinding: Cannot parse trackName: ${trackName}`);
				}

				const results = {
					// directoryName: matches[ 1 ], // (tschw) currently unused
					nodeName: matches[2],
					objectName: matches[3],
					objectIndex: matches[4],
					propertyName: matches[5], // required
					propertyIndex: matches[6],
				};

				const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');

				if (lastDot !== undefined && lastDot !== -1) {
					const objectName = results.nodeName.substring(lastDot + 1);

					// Object names must be checked against a whitelist. Otherwise, there
					// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
					// 'bar' could be the objectName, or part of a nodeName (which can
					// include '.' characters).
					if (supportedObjectNames.indexOf(objectName) !== -1) {
						results.nodeName = results.nodeName.substring(0, lastDot);
						results.objectName = objectName;
					}
				}

				if (results.propertyName === null || results.propertyName.length === 0) {
					throw new Error(`PropertyBinding: can not parse propertyName from trackName: ${trackName}`);
				}

				return results;
			};
		}()),

		findNode(root, nodeName) {
			if (!nodeName || nodeName === '' || nodeName === 'root' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
				return root;
			}

			// search into skeleton bones.
			if (root.skeleton) {
				const bone = root.skeleton.getBoneByName(nodeName);

				if (bone !== undefined) {
					return bone;
				}
			}

			// search into node subtree.
			if (root.children) {
				var searchNodeSubtree = function (children) {
					for (let i = 0; i < children.length; i++) {
						const childNode = children[i];

						if (childNode.name === nodeName || childNode.uuid === nodeName) {
							return childNode;
						}

						const result = searchNodeSubtree(childNode.children);

						if (result) return result;
					}

					return null;
				};

				const subTreeNode = searchNodeSubtree(root.children);

				if (subTreeNode) {
					return subTreeNode;
				}
			}

			return null;
		},

	});

	Object.assign(PropertyBinding.prototype, { // prototype, continued

		// these are used to "bind" a nonexistent property
		_getValue_unavailable() {},
		_setValue_unavailable() {},

		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3,
		},

		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2,
		},

		GetterByBindingType: [

			function getValue_direct(buffer, offset) {
				buffer[offset] = this.node[this.propertyName];
			},

			function getValue_array(buffer, offset) {
				const source = this.resolvedProperty;

				for (let i = 0, n = source.length; i !== n; ++i) {
					buffer[offset++] = source[i];
				}
			},

			function getValue_arrayElement(buffer, offset) {
				buffer[offset] = this.resolvedProperty[this.propertyIndex];
			},

			function getValue_toArray(buffer, offset) {
				this.resolvedProperty.toArray(buffer, offset);
			},

		],

		SetterByBindingTypeAndVersioning: [

			[
				// Direct

				function setValue_direct(buffer, offset) {
					this.targetObject[this.propertyName] = buffer[offset];
				},

				function setValue_direct_setNeedsUpdate(buffer, offset) {
					this.targetObject[this.propertyName] = buffer[offset];
					this.targetObject.needsUpdate = true;
				},

				function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
					this.targetObject[this.propertyName] = buffer[offset];
					this.targetObject.matrixWorldNeedsUpdate = true;
				},

			], [

				// EntireArray

				function setValue_array(buffer, offset) {
					const dest = this.resolvedProperty;

					for (let i = 0, n = dest.length; i !== n; ++i) {
						dest[i] = buffer[offset++];
					}
				},

				function setValue_array_setNeedsUpdate(buffer, offset) {
					const dest = this.resolvedProperty;

					for (let i = 0, n = dest.length; i !== n; ++i) {
						dest[i] = buffer[offset++];
					}

					this.targetObject.needsUpdate = true;
				},

				function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
					const dest = this.resolvedProperty;

					for (let i = 0, n = dest.length; i !== n; ++i) {
						dest[i] = buffer[offset++];
					}

					this.targetObject.matrixWorldNeedsUpdate = true;
				},

			], [

				// ArrayElement

				function setValue_arrayElement(buffer, offset) {
					this.resolvedProperty[this.propertyIndex] = buffer[offset];
				},

				function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
					this.resolvedProperty[this.propertyIndex] = buffer[offset];
					this.targetObject.needsUpdate = true;
				},

				function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
					this.resolvedProperty[this.propertyIndex] = buffer[offset];
					this.targetObject.matrixWorldNeedsUpdate = true;
				},

			], [

				// HasToFromArray

				function setValue_fromArray(buffer, offset) {
					this.resolvedProperty.fromArray(buffer, offset);
				},

				function setValue_fromArray_setNeedsUpdate(buffer, offset) {
					this.resolvedProperty.fromArray(buffer, offset);
					this.targetObject.needsUpdate = true;
				},

				function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
					this.resolvedProperty.fromArray(buffer, offset);
					this.targetObject.matrixWorldNeedsUpdate = true;
				},

			],

		],

		getValue: function getValue_unbound(targetArray, offset) {
			this.bind();
			this.getValue(targetArray, offset);

			// Note: This class uses a State pattern on a per-method basis:
			// 'bind' sets 'this.getValue' / 'setValue' and shadows the
			// prototype version of these methods with one that represents
			// the bound state. When the property is not found, the methods
			// become no-ops.
		},

		setValue: function getValue_unbound(sourceArray, offset) {
			this.bind();
			this.setValue(sourceArray, offset);
		},

		// create getter / setter pair for a property in the scene graph
		bind() {
			let targetObject = this.node;
			const { parsedPath } = this;

			const { objectName } = parsedPath;
			const { propertyName } = parsedPath;
			let { propertyIndex } = parsedPath;

			if (!targetObject) {
				targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;

				this.node = targetObject;
			}

			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;

			// ensure there is a value node
			if (!targetObject) {
				console.error(`THREE.PropertyBinding: Trying to update node for track: ${this.path} but it wasn't found.`);
				return;
			}

			if (objectName) {
				let { objectIndex } = parsedPath;

				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch (objectName) {
				case 'materials':

					if (!targetObject.material) {
						console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
						return;
					}

					if (!targetObject.material.materials) {
						console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
						return;
					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if (!targetObject.skeleton) {
						console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
						return;
					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for (var i = 0; i < targetObject.length; i++) {
						if (targetObject[i].name === objectIndex) {
							objectIndex = i;
							break;
						}
					}

					break;

				default:

					if (targetObject[objectName] === undefined) {
						console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
						return;
					}

					targetObject = targetObject[objectName];
				}


				if (objectIndex !== undefined) {
					if (targetObject[objectIndex] === undefined) {
						console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
						return;
					}

					targetObject = targetObject[objectIndex];
				}
			}

			// resolve property
			const nodeProperty = targetObject[propertyName];

			if (nodeProperty === undefined) {
				const { nodeName } = parsedPath;

				console.error(`THREE.PropertyBinding: Trying to update property for track: ${nodeName
					 }.${propertyName} but it wasn't found.`, targetObject);
				return;
			}

			// determine versioning scheme
			let versioning = this.Versioning.None;

			this.targetObject = targetObject;

			if (targetObject.needsUpdate !== undefined) { // material
				versioning = this.Versioning.NeedsUpdate;
			} else if (targetObject.matrixWorldNeedsUpdate !== undefined) { // node transform
				versioning = this.Versioning.MatrixWorldNeedsUpdate;
			}

			// determine how the property gets bound
			let bindingType = this.BindingType.Direct;

			if (propertyIndex !== undefined) {
				// access a sub element of the property array (only primitives are supported right now)

				if (propertyName === 'morphTargetInfluences') {
					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

					// support resolving morphTarget names into indices.
					if (!targetObject.geometry) {
						console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
						return;
					}

					if (targetObject.geometry.isBufferGeometry) {
						if (!targetObject.geometry.morphAttributes) {
							console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
							return;
						}

						for (var i = 0; i < this.node.geometry.morphAttributes.position.length; i++) {
							if (targetObject.geometry.morphAttributes.position[i].name === propertyIndex) {
								propertyIndex = i;
								break;
							}
						}
					} else {
						if (!targetObject.geometry.morphTargets) {
							console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this);
							return;
						}

						for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
							if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
								propertyIndex = i;
								break;
							}
						}
					}
				}

				bindingType = this.BindingType.ArrayElement;

				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;
			} else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
				// must use copy for Object3D.Euler/Quaternion

				bindingType = this.BindingType.HasFromToArray;

				this.resolvedProperty = nodeProperty;
			} else if (Array.isArray(nodeProperty)) {
				bindingType = this.BindingType.EntireArray;

				this.resolvedProperty = nodeProperty;
			} else {
				this.propertyName = propertyName;
			}

			// select getter / setter
			this.getValue = this.GetterByBindingType[bindingType];
			this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
		},

		unbind() {
			this.node = null;

			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
		},

	});

	//! \ DECLARE ALIAS AFTER assign prototype !
	Object.assign(PropertyBinding.prototype, {

		// initial state of these methods that calls 'bind'
		_getValue_unbound: PropertyBinding.prototype.getValue,
		_setValue_unbound: PropertyBinding.prototype.setValue,

	});

	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 *  - Add objects you would otherwise pass as 'root' to the
	 *    constructor or the .clipAction method of AnimationMixer.
	 *
	 *  - Instead pass this object as 'root'.
	 *
	 *  - You can also add and remove objects later when the mixer
	 *    is running.
	 *
	 * Note:
	 *
	 *    Objects of this class appear as one object to the mixer,
	 *    so cache control of the individual objects must be done
	 *    on the group.
	 *
	 * Limitation:
	 *
	 *  - The animated properties must be compatible among the
	 *    all objects in the group.
	 *
	 *  - A single property can either be controlled through a
	 *    target group or directly, but not both.
	 *
	 * @author tschw
	 */

	function AnimationObjectGroup() {
		this.uuid = _Math.generateUUID();

		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call(arguments);

		this.nCachedObjects_ = 0; // threshold
		// note: read by PropertyBinding.Composite

		const indices = {};
		this._indicesByUUID = indices; // for bookkeeping

		for (let i = 0, n = arguments.length; i !== n; ++i) {
			indices[arguments[i].uuid] = i;
		}

		this._paths = []; // inside: string
		this._parsedPaths = []; // inside: { we don't care, here }
		this._bindings = []; // inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; // inside: indices in these arrays

		const scope = this;

		this.stats = {

			objects: {
				get total() {
					return scope._objects.length;
				},
				get inUse() {
					return this.total - scope.nCachedObjects_;
				},
			},
			get bindingsPerObject() {
				return scope._bindings.length;
			},

		};
	}

	Object.assign(AnimationObjectGroup.prototype, {

		isAnimationObjectGroup: true,

		add() {
			const objects = this._objects;
			let nObjects = objects.length;
			let nCachedObjects = this.nCachedObjects_;
			const indicesByUUID = this._indicesByUUID;
			const paths = this._paths;
			const parsedPaths = this._parsedPaths;
			const bindings = this._bindings;
			const nBindings = bindings.length;
			let knownObject;

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				const object = arguments[i];
				const { uuid } = object;
				let index = indicesByUUID[uuid];

				if (index === undefined) {
					// unknown object -> add it to the ACTIVE region

					index = nObjects++;
					indicesByUUID[uuid] = index;
					objects.push(object);

					// accounting is done, now do the same for all bindings

					for (var j = 0, m = nBindings; j !== m; ++j) {
						bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
					}
				} else if (index < nCachedObjects) {
					knownObject = objects[index];

					// move existing object to the ACTIVE region

					const firstActiveIndex = --nCachedObjects;
					const lastCachedObject = objects[firstActiveIndex];

					indicesByUUID[lastCachedObject.uuid] = index;
					objects[index] = lastCachedObject;

					indicesByUUID[uuid] = firstActiveIndex;
					objects[firstActiveIndex] = object;

					// accounting is done, now do the same for all bindings

					for (var j = 0, m = nBindings; j !== m; ++j) {
						const bindingsForPath = bindings[j];
						const lastCached = bindingsForPath[firstActiveIndex];
						let binding = bindingsForPath[index];

						bindingsForPath[index] = lastCached;

						if (binding === undefined) {
							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist

							binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
						}

						bindingsForPath[firstActiveIndex] = binding;
					}
				} else if (objects[index] !== knownObject) {
					console.error('THREE.AnimationObjectGroup: Different objects with the same UUID '
						+ 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
				} // else the object is already where we want it to be
			} // for arguments

			this.nCachedObjects_ = nCachedObjects;
		},

		remove() {
			const objects = this._objects;
			let nCachedObjects = this.nCachedObjects_;
			const indicesByUUID = this._indicesByUUID;
			const bindings = this._bindings;
			const nBindings = bindings.length;

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				const object = arguments[i];
				const { uuid } = object;
				const index = indicesByUUID[uuid];

				if (index !== undefined && index >= nCachedObjects) {
					// move existing object into the CACHED region

					const lastCachedIndex = nCachedObjects++;
					const firstActiveObject = objects[lastCachedIndex];

					indicesByUUID[firstActiveObject.uuid] = index;
					objects[index] = firstActiveObject;

					indicesByUUID[uuid] = lastCachedIndex;
					objects[lastCachedIndex] = object;

					// accounting is done, now do the same for all bindings

					for (let j = 0, m = nBindings; j !== m; ++j) {
						const bindingsForPath = bindings[j];
						const firstActive = bindingsForPath[lastCachedIndex];
						const binding = bindingsForPath[index];

						bindingsForPath[index] = firstActive;
						bindingsForPath[lastCachedIndex] = binding;
					}
				}
			} // for arguments

			this.nCachedObjects_ = nCachedObjects;
		},

		// remove & forget
		uncache() {
			const objects = this._objects;
			let nObjects = objects.length;
			let nCachedObjects = this.nCachedObjects_;
			const indicesByUUID = this._indicesByUUID;
			const bindings = this._bindings;
			const nBindings = bindings.length;

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				const object = arguments[i];
				const { uuid } = object;
				const index = indicesByUUID[uuid];

				if (index !== undefined) {
					delete indicesByUUID[uuid];

					if (index < nCachedObjects) {
						// object is cached, shrink the CACHED region

						const firstActiveIndex = --nCachedObjects;
						const lastCachedObject = objects[firstActiveIndex];
						var lastIndex = --nObjects;
						var lastObject = objects[lastIndex];

						// last cached object takes this object's place
						indicesByUUID[lastCachedObject.uuid] = index;
						objects[index] = lastCachedObject;

						// last object goes to the activated slot and pop
						indicesByUUID[lastObject.uuid] = firstActiveIndex;
						objects[firstActiveIndex] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for (var j = 0, m = nBindings; j !== m; ++j) {
							var bindingsForPath = bindings[j];
							const lastCached = bindingsForPath[firstActiveIndex];
							const last = bindingsForPath[lastIndex];

							bindingsForPath[index] = lastCached;
							bindingsForPath[firstActiveIndex] = last;
							bindingsForPath.pop();
						}
					} else {
						// object is active, just swap with the last and pop

						var lastIndex = --nObjects;
						var lastObject = objects[lastIndex];

						indicesByUUID[lastObject.uuid] = index;
						objects[index] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for (var j = 0, m = nBindings; j !== m; ++j) {
							var bindingsForPath = bindings[j];

							bindingsForPath[index] = bindingsForPath[lastIndex];
							bindingsForPath.pop();
						}
					} // cached or active
				} // if object is known
			} // for arguments

			this.nCachedObjects_ = nCachedObjects;
		},

		// Internal interface used by befriended PropertyBinding.Composite:

		subscribe_(path, parsedPath) {
			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group

			const indicesByPath = this._bindingsIndicesByPath;
			let index = indicesByPath[path];
			const bindings = this._bindings;

			if (index !== undefined) return bindings[index];

			const paths = this._paths;
			const parsedPaths = this._parsedPaths;
			const objects = this._objects;
			const nObjects = objects.length;
			const nCachedObjects = this.nCachedObjects_;
			const bindingsForPath = new Array(nObjects);

			index = bindings.length;

			indicesByPath[path] = index;

			paths.push(path);
			parsedPaths.push(parsedPath);
			bindings.push(bindingsForPath);

			for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
				const object = objects[i];
				bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
			}

			return bindingsForPath;
		},

		unsubscribe_(path) {
			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'

			const indicesByPath = this._bindingsIndicesByPath;
			const index = indicesByPath[path];

			if (index !== undefined) {
				const paths = this._paths;
				const parsedPaths = this._parsedPaths;
				const bindings = this._bindings;
				const lastBindingsIndex = bindings.length - 1;
				const lastBindings = bindings[lastBindingsIndex];
				const lastBindingsPath = path[lastBindingsIndex];

				indicesByPath[lastBindingsPath] = index;

				bindings[index] = lastBindings;
				bindings.pop();

				parsedPaths[index] = parsedPaths[lastBindingsIndex];
				parsedPaths.pop();

				paths[index] = paths[lastBindingsIndex];
				paths.pop();
			}
		},

	});

	/**
	 *
	 * Action provided by AnimationMixer for scheduling clip playback on specific
	 * objects.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 *
	 */

	function AnimationAction(mixer, clip, localRoot) {
		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot || null;

		const { tracks } = clip;
		const nTracks = tracks.length;
		const interpolants = new Array(nTracks);

		const interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding,
		};

		for (let i = 0; i !== nTracks; ++i) {
			const interpolant = tracks[i].createInterpolant(null);
			interpolants[i] = interpolant;
			interpolant.settings = interpolantSettings;
		}

		this._interpolantSettings = interpolantSettings;

		this._interpolants = interpolants; // bound by the mixer

		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array(nTracks);

		this._cacheIndex = null; // for the memory manager
		this._byClipCacheIndex = null; // for the memory manager

		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;

		this.loop = LoopRepeat;
		this._loopCount = -1;

		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;

		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;

		this.timeScale = 1;
		this._effectiveTimeScale = 1;

		this.weight = 1;
		this._effectiveWeight = 1;

		this.repetitions = Infinity; // no. of repetitions when looping

		this.paused = false; // true -> zero effective time scale
		this.enabled = true; // false -> zero effective weight

		this.clampWhenFinished = false;// keep feeding the last frame?

		this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd = true;// clips for start, loop and end
	}

	Object.assign(AnimationAction.prototype, {

		// State & Scheduling

		play() {
			this._mixer._activateAction(this);

			return this;
		},

		stop() {
			this._mixer._deactivateAction(this);

			return this.reset();
		},

		reset() {
			this.paused = false;
			this.enabled = true;

			this.time = 0; // restart clip
			this._loopCount = -1;// forget previous loops
			this._startTime = null;// forget scheduling

			return this.stopFading().stopWarping();
		},

		isRunning() {
			return this.enabled && !this.paused && this.timeScale !== 0
				&& this._startTime === null && this._mixer._isActiveAction(this);
		},

		// return true when play has been called
		isScheduled() {
			return this._mixer._isActiveAction(this);
		},

		startAt(time) {
			this._startTime = time;

			return this;
		},

		setLoop(mode, repetitions) {
			this.loop = mode;
			this.repetitions = repetitions;

			return this;
		},

		// Weight

		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		setEffectiveWeight(weight) {
			this.weight = weight;

			// note: same logic as when updated at runtime
			this._effectiveWeight = this.enabled ? weight : 0;

			return this.stopFading();
		},

		// return the weight considering fading and .enabled
		getEffectiveWeight() {
			return this._effectiveWeight;
		},

		fadeIn(duration) {
			return this._scheduleFading(duration, 0, 1);
		},

		fadeOut(duration) {
			return this._scheduleFading(duration, 1, 0);
		},

		crossFadeFrom(fadeOutAction, duration, warp) {
			fadeOutAction.fadeOut(duration);
			this.fadeIn(duration);

			if (warp) {
				const fadeInDuration = this._clip.duration;
				const fadeOutDuration = fadeOutAction._clip.duration;

				const startEndRatio = fadeOutDuration / fadeInDuration;
				const endStartRatio = fadeInDuration / fadeOutDuration;

				fadeOutAction.warp(1.0, startEndRatio, duration);
				this.warp(endStartRatio, 1.0, duration);
			}

			return this;
		},

		crossFadeTo(fadeInAction, duration, warp) {
			return fadeInAction.crossFadeFrom(this, duration, warp);
		},

		stopFading() {
			const weightInterpolant = this._weightInterpolant;

			if (weightInterpolant !== null) {
				this._weightInterpolant = null;
				this._mixer._takeBackControlInterpolant(weightInterpolant);
			}

			return this;
		},

		// Time Scale Control

		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		setEffectiveTimeScale(timeScale) {
			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;

			return this.stopWarping();
		},

		// return the time scale considering warping and .paused
		getEffectiveTimeScale() {
			return this._effectiveTimeScale;
		},

		setDuration(duration) {
			this.timeScale = this._clip.duration / duration;

			return this.stopWarping();
		},

		syncWith(action) {
			this.time = action.time;
			this.timeScale = action.timeScale;

			return this.stopWarping();
		},

		halt(duration) {
			return this.warp(this._effectiveTimeScale, 0, duration);
		},

		warp(startTimeScale, endTimeScale, duration) {
			const mixer = this._mixer; const now = mixer.time;
			let interpolant = this._timeScaleInterpolant;

			const { timeScale } = this;

			if (interpolant === null) {
				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;
			}

			const times = interpolant.parameterPositions;
			const values = interpolant.sampleValues;

			times[0] = now;
			times[1] = now + duration;

			values[0] = startTimeScale / timeScale;
			values[1] = endTimeScale / timeScale;

			return this;
		},

		stopWarping() {
			const timeScaleInterpolant = this._timeScaleInterpolant;

			if (timeScaleInterpolant !== null) {
				this._timeScaleInterpolant = null;
				this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
			}

			return this;
		},

		// Object Accessors

		getMixer() {
			return this._mixer;
		},

		getClip() {
			return this._clip;
		},

		getRoot() {
			return this._localRoot || this._mixer._root;
		},

		// Interna

		_update(time, deltaTime, timeDirection, accuIndex) {
			// called by the mixer

			if (!this.enabled) {
				// call ._updateWeight() to update ._effectiveWeight

				this._updateWeight(time);
				return;
			}

			const startTime = this._startTime;

			if (startTime !== null) {
				// check for scheduled start of action

				const timeRunning = (time - startTime) * timeDirection;
				if (timeRunning < 0 || timeDirection === 0) {
					return; // yet to come / don't decide when delta = 0
				}

				// start

				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;
			}

			// apply time scale and advance time

			deltaTime *= this._updateTimeScale(time);
			const clipTime = this._updateTime(deltaTime);

			// note: _updateTime may disable the action resulting in
			// an effective weight of 0

			const weight = this._updateWeight(time);

			if (weight > 0) {
				const interpolants = this._interpolants;
				const propertyMixers = this._propertyBindings;

				for (let j = 0, m = interpolants.length; j !== m; ++j) {
					interpolants[j].evaluate(clipTime);
					propertyMixers[j].accumulate(accuIndex, weight);
				}
			}
		},

		_updateWeight(time) {
			let weight = 0;

			if (this.enabled) {
				weight = this.weight;
				const interpolant = this._weightInterpolant;

				if (interpolant !== null) {
					const interpolantValue = interpolant.evaluate(time)[0];

					weight *= interpolantValue;

					if (time > interpolant.parameterPositions[1]) {
						this.stopFading();

						if (interpolantValue === 0) {
							// faded out, disable
							this.enabled = false;
						}
					}
				}
			}

			this._effectiveWeight = weight;
			return weight;
		},

		_updateTimeScale(time) {
			let timeScale = 0;

			if (!this.paused) {
				timeScale = this.timeScale;

				const interpolant = this._timeScaleInterpolant;

				if (interpolant !== null) {
					const interpolantValue = interpolant.evaluate(time)[0];

					timeScale *= interpolantValue;

					if (time > interpolant.parameterPositions[1]) {
						this.stopWarping();

						if (timeScale === 0) {
							// motion has halted, pause
							this.paused = true;
						} else {
							// warp done - apply final time scale
							this.timeScale = timeScale;
						}
					}
				}
			}

			this._effectiveTimeScale = timeScale;
			return timeScale;
		},

		_updateTime(deltaTime) {
			let time = this.time + deltaTime;
			const { duration } = this._clip;
			const { loop } = this;
			let loopCount = this._loopCount;

			const pingPong = (loop === LoopPingPong);

			if (deltaTime === 0) {
				if (loopCount === -1) return time;

				return (pingPong && (loopCount & 1) === 1) ? duration - time : time;
			}

			if (loop === LoopOnce) {
				if (loopCount === -1) {
					// just started

					this._loopCount = 0;
					this._setEndings(true, true, false);
				}

				handle_stop: {
					if (time >= duration) {
						time = duration;
					} else if (time < 0) {
						time = 0;
					} else break handle_stop;

					if (this.clampWhenFinished) this.paused = true;
					else this.enabled = false;

					this._mixer.dispatchEvent({
						type: 'finished',
						action: this,
						direction: deltaTime < 0 ? -1 : 1,
					});
				}
			} else { // repetitive Repeat or PingPong
				if (loopCount === -1) {
					// just started

					if (deltaTime >= 0) {
						loopCount = 0;

						this._setEndings(true, this.repetitions === 0, pingPong);
					} else {
						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1

						this._setEndings(this.repetitions === 0, true, pingPong);
					}
				}

				if (time >= duration || time < 0) {
					// wrap around

					const loopDelta = Math.floor(time / duration); // signed
					time -= duration * loopDelta;

					loopCount += Math.abs(loopDelta);

					const pending = this.repetitions - loopCount;

					if (pending <= 0) {
						// have to stop (switch state, clamp time, fire event)

						if (this.clampWhenFinished) this.paused = true;
						else this.enabled = false;

						time = deltaTime > 0 ? duration : 0;

						this._mixer.dispatchEvent({
							type: 'finished',
							action: this,
							direction: deltaTime > 0 ? 1 : -1,
						});
					} else {
						// keep running

						if (pending === 1) {
							// entering the last round

							const atStart = deltaTime < 0;
							this._setEndings(atStart, !atStart, pingPong);
						} else {
							this._setEndings(false, false, pingPong);
						}

						this._loopCount = loopCount;

						this._mixer.dispatchEvent({
							type: 'loop', action: this, loopDelta,
						});
					}
				}

				if (pingPong && (loopCount & 1) === 1) {
					// invert time for the "pong round"

					this.time = time;
					return duration - time;
				}
			}

			this.time = time;
			return time;
		},

		_setEndings(atStart, atEnd, pingPong) {
			const settings = this._interpolantSettings;

			if (pingPong) {
				settings.endingStart = ZeroSlopeEnding;
				settings.endingEnd = ZeroSlopeEnding;
			} else {
				// assuming for LoopOnce atStart == atEnd == true

				if (atStart) {
					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
				} else {
					settings.endingStart = WrapAroundEnding;
				}

				if (atEnd) {
					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
				} else {
					settings.endingEnd 	 = WrapAroundEnding;
				}
			}
		},

		_scheduleFading(duration, weightNow, weightThen) {
			const mixer = this._mixer; const now = mixer.time;
			let interpolant = this._weightInterpolant;

			if (interpolant === null) {
				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;
			}

			const times = interpolant.parameterPositions;
			const values = interpolant.sampleValues;

			times[0] = now;
			values[0] = weightNow;
			times[1] = now + duration;
			values[1] = weightThen;

			return this;
		},

	});

	/**
	 *
	 * Player for AnimationClips.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function AnimationMixer(root) {
		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;

		this.time = 0;

		this.timeScale = 1.0;
	}

	AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {

		constructor: AnimationMixer,

		_bindAction(action, prototypeAction) {
			const root = action._localRoot || this._root;
			const { tracks } = action._clip;
			const nTracks = tracks.length;
			const bindings = action._propertyBindings;
			const interpolants = action._interpolants;
			const rootUuid = root.uuid;
			const bindingsByRoot = this._bindingsByRootAndName;
			let bindingsByName = bindingsByRoot[rootUuid];

			if (bindingsByName === undefined) {
				bindingsByName = {};
				bindingsByRoot[rootUuid] = bindingsByName;
			}

			for (let i = 0; i !== nTracks; ++i) {
				const track = tracks[i];
				const trackName = track.name;
				let binding = bindingsByName[trackName];

				if (binding !== undefined) {
					bindings[i] = binding;
				} else {
					binding = bindings[i];

					if (binding !== undefined) {
						// existing binding, make sure the cache knows

						if (binding._cacheIndex === null) {
							++binding.referenceCount;
							this._addInactiveBinding(binding, rootUuid, trackName);
						}

						continue;
					}

					const path = prototypeAction && prototypeAction
						._propertyBindings[i].binding.parsedPath;

					binding = new PropertyMixer(
						PropertyBinding.create(root, trackName, path),
						track.ValueTypeName, track.getValueSize(),
					);

					++binding.referenceCount;
					this._addInactiveBinding(binding, rootUuid, trackName);

					bindings[i] = binding;
				}

				interpolants[i].resultBuffer = binding.buffer;
			}
		},

		_activateAction(action) {
			if (!this._isActiveAction(action)) {
				if (action._cacheIndex === null) {
					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind

					const rootUuid = (action._localRoot || this._root).uuid;
					const clipUuid = action._clip.uuid;
					const actionsForClip = this._actionsByClip[clipUuid];

					this._bindAction(action,
						actionsForClip && actionsForClip.knownActions[0]);

					this._addInactiveAction(action, clipUuid, rootUuid);
				}

				const bindings = action._propertyBindings;

				// increment reference counts / sort out state
				for (let i = 0, n = bindings.length; i !== n; ++i) {
					const binding = bindings[i];

					if (binding.useCount++ === 0) {
						this._lendBinding(binding);
						binding.saveOriginalState();
					}
				}

				this._lendAction(action);
			}
		},

		_deactivateAction(action) {
			if (this._isActiveAction(action)) {
				const bindings = action._propertyBindings;

				// decrement reference counts / sort out state
				for (let i = 0, n = bindings.length; i !== n; ++i) {
					const binding = bindings[i];

					if (--binding.useCount === 0) {
						binding.restoreOriginalState();
						this._takeBackBinding(binding);
					}
				}

				this._takeBackAction(action);
			}
		},

		// Memory manager

		_initMemoryManager() {
			this._actions = []; // 'nActiveActions' followed by inactive ones
			this._nActiveActions = 0;

			this._actionsByClip = {};
			// inside:
			// {
			// 	knownActions: Array< AnimationAction > - used as prototypes
			// 	actionByRoot: AnimationAction - lookup
			// }


			this._bindings = []; // 'nActiveBindings' followed by inactive ones
			this._nActiveBindings = 0;

			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


			this._controlInterpolants = []; // same game as above
			this._nActiveControlInterpolants = 0;

			const scope = this;

			this.stats = {

				actions: {
					get total() {
						return scope._actions.length;
					},
					get inUse() {
						return scope._nActiveActions;
					},
				},
				bindings: {
					get total() {
						return scope._bindings.length;
					},
					get inUse() {
						return scope._nActiveBindings;
					},
				},
				controlInterpolants: {
					get total() {
						return scope._controlInterpolants.length;
					},
					get inUse() {
						return scope._nActiveControlInterpolants;
					},
				},

			};
		},

		// Memory management for AnimationAction objects

		_isActiveAction(action) {
			const index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;
		},

		_addInactiveAction(action, clipUuid, rootUuid) {
			const actions = this._actions;
			const actionsByClip = this._actionsByClip;
			let actionsForClip = actionsByClip[clipUuid];

			if (actionsForClip === undefined) {
				actionsForClip = {

					knownActions: [action],
					actionByRoot: {},

				};

				action._byClipCacheIndex = 0;

				actionsByClip[clipUuid] = actionsForClip;
			} else {
				const { knownActions } = actionsForClip;

				action._byClipCacheIndex = knownActions.length;
				knownActions.push(action);
			}

			action._cacheIndex = actions.length;
			actions.push(action);

			actionsForClip.actionByRoot[rootUuid] = action;
		},

		_removeInactiveAction(action) {
			const actions = this._actions;
			const lastInactiveAction = actions[actions.length - 1];
			const cacheIndex = action._cacheIndex;

			lastInactiveAction._cacheIndex = cacheIndex;
			actions[cacheIndex] = lastInactiveAction;
			actions.pop();

			action._cacheIndex = null;


			const clipUuid = action._clip.uuid;
			const actionsByClip = this._actionsByClip;
			const actionsForClip = actionsByClip[clipUuid];
			const knownActionsForClip = actionsForClip.knownActions;

			const lastKnownAction =					knownActionsForClip[knownActionsForClip.length - 1];

			const byClipCacheIndex = action._byClipCacheIndex;

			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[byClipCacheIndex] = lastKnownAction;
			knownActionsForClip.pop();

			action._byClipCacheIndex = null;


			const { actionByRoot } = actionsForClip;
			const rootUuid = (action._localRoot || this._root).uuid;

			delete actionByRoot[rootUuid];

			if (knownActionsForClip.length === 0) {
				delete actionsByClip[clipUuid];
			}

			this._removeInactiveBindingsForAction(action);
		},

		_removeInactiveBindingsForAction(action) {
			const bindings = action._propertyBindings;
			for (let i = 0, n = bindings.length; i !== n; ++i) {
				const binding = bindings[i];

				if (--binding.referenceCount === 0) {
					this._removeInactiveBinding(binding);
				}
			}
		},

		_lendAction(action) {
			// [ active actions |  inactive actions  ]
			// [  active actions >| inactive actions ]
			//                 s        a
			//                  <-swap->
			//                 a        s

			const actions = this._actions;
			const prevIndex = action._cacheIndex;

			const lastActiveIndex = this._nActiveActions++;

			const firstInactiveAction = actions[lastActiveIndex];

			action._cacheIndex = lastActiveIndex;
			actions[lastActiveIndex] = action;

			firstInactiveAction._cacheIndex = prevIndex;
			actions[prevIndex] = firstInactiveAction;
		},

		_takeBackAction(action) {
			// [  active actions  | inactive actions ]
			// [ active actions |< inactive actions  ]
			//        a        s
			//         <-swap->
			//        s        a

			const actions = this._actions;
			const prevIndex = action._cacheIndex;

			const firstInactiveIndex = --this._nActiveActions;

			const lastActiveAction = actions[firstInactiveIndex];

			action._cacheIndex = firstInactiveIndex;
			actions[firstInactiveIndex] = action;

			lastActiveAction._cacheIndex = prevIndex;
			actions[prevIndex] = lastActiveAction;
		},

		// Memory management for PropertyMixer objects

		_addInactiveBinding(binding, rootUuid, trackName) {
			const bindingsByRoot = this._bindingsByRootAndName;
			let bindingByName = bindingsByRoot[rootUuid];

			const bindings = this._bindings;

			if (bindingByName === undefined) {
				bindingByName = {};
				bindingsByRoot[rootUuid] = bindingByName;
			}

			bindingByName[trackName] = binding;

			binding._cacheIndex = bindings.length;
			bindings.push(binding);
		},

		_removeInactiveBinding(binding) {
			const bindings = this._bindings;
			const propBinding = binding.binding;
			const rootUuid = propBinding.rootNode.uuid;
			const trackName = propBinding.path;
			const bindingsByRoot = this._bindingsByRootAndName;
			const bindingByName = bindingsByRoot[rootUuid];

			const lastInactiveBinding = bindings[bindings.length - 1];
			const cacheIndex = binding._cacheIndex;

			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[cacheIndex] = lastInactiveBinding;
			bindings.pop();

			delete bindingByName[trackName];

			remove_empty_map: {
				for (const _ in bindingByName) break remove_empty_map; // eslint-disable-line no-unused-vars

				delete bindingsByRoot[rootUuid];
			}
		},

		_lendBinding(binding) {
			const bindings = this._bindings;
			const prevIndex = binding._cacheIndex;

			const lastActiveIndex = this._nActiveBindings++;

			const firstInactiveBinding = bindings[lastActiveIndex];

			binding._cacheIndex = lastActiveIndex;
			bindings[lastActiveIndex] = binding;

			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[prevIndex] = firstInactiveBinding;
		},

		_takeBackBinding(binding) {
			const bindings = this._bindings;
			const prevIndex = binding._cacheIndex;

			const firstInactiveIndex = --this._nActiveBindings;

			const lastActiveBinding = bindings[firstInactiveIndex];

			binding._cacheIndex = firstInactiveIndex;
			bindings[firstInactiveIndex] = binding;

			lastActiveBinding._cacheIndex = prevIndex;
			bindings[prevIndex] = lastActiveBinding;
		},


		// Memory management of Interpolants for weight and time scale

		_lendControlInterpolant() {
			const interpolants = this._controlInterpolants;
			const lastActiveIndex = this._nActiveControlInterpolants++;
			let interpolant = interpolants[lastActiveIndex];

			if (interpolant === undefined) {
				interpolant = new LinearInterpolant(
					new Float32Array(2), new Float32Array(2),
					1, this._controlInterpolantsResultBuffer,
				);

				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[lastActiveIndex] = interpolant;
			}

			return interpolant;
		},

		_takeBackControlInterpolant(interpolant) {
			const interpolants = this._controlInterpolants;
			const prevIndex = interpolant.__cacheIndex;

			const firstInactiveIndex = --this._nActiveControlInterpolants;

			const lastActiveInterpolant = interpolants[firstInactiveIndex];

			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[firstInactiveIndex] = interpolant;

			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[prevIndex] = lastActiveInterpolant;
		},

		_controlInterpolantsResultBuffer: new Float32Array(1),

		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction(clip, optionalRoot) {
			const root = optionalRoot || this._root;
			const rootUuid = root.uuid;

			let clipObject = typeof clip === 'string'
				? AnimationClip.findByName(root, clip) : clip;

			const clipUuid = clipObject !== null ? clipObject.uuid : clip;

			const actionsForClip = this._actionsByClip[clipUuid];
			let prototypeAction = null;

			if (actionsForClip !== undefined) {
				const existingAction =						actionsForClip.actionByRoot[rootUuid];

				if (existingAction !== undefined) {
					return existingAction;
				}

				// we know the clip, so we don't have to parse all
				// the bindings again but can just copy
				prototypeAction = actionsForClip.knownActions[0];

				// also, take the clip from the prototype action
				if (clipObject === null) clipObject = prototypeAction._clip;
			}

			// clip must be known when specified via string
			if (clipObject === null) return null;

			// allocate all resources required to run it
			const newAction = new AnimationAction(this, clipObject, optionalRoot);

			this._bindAction(newAction, prototypeAction);

			// and make the action known to the memory manager
			this._addInactiveAction(newAction, clipUuid, rootUuid);

			return newAction;
		},

		// get an existing action
		existingAction(clip, optionalRoot) {
			const root = optionalRoot || this._root;
			const rootUuid = root.uuid;

			const clipObject = typeof clip === 'string'
				? AnimationClip.findByName(root, clip) : clip;

			const clipUuid = clipObject ? clipObject.uuid : clip;

			const actionsForClip = this._actionsByClip[clipUuid];

			if (actionsForClip !== undefined) {
				return actionsForClip.actionByRoot[rootUuid] || null;
			}

			return null;
		},

		// deactivates all previously scheduled actions
		stopAllAction() {
			const actions = this._actions;
			const nActions = this._nActiveActions;
			const bindings = this._bindings;
			const nBindings = this._nActiveBindings;

			this._nActiveActions = 0;
			this._nActiveBindings = 0;

			for (var i = 0; i !== nActions; ++i) {
				actions[i].reset();
			}

			for (var i = 0; i !== nBindings; ++i) {
				bindings[i].useCount = 0;
			}

			return this;
		},

		// advance the time and update apply the animation
		update(deltaTime) {
			deltaTime *= this.timeScale;

			const actions = this._actions;
			const nActions = this._nActiveActions;

			const time = this.time += deltaTime;
			const timeDirection = Math.sign(deltaTime);

			const accuIndex = this._accuIndex ^= 1;

			// run active actions

			for (var i = 0; i !== nActions; ++i) {
				const action = actions[i];

				action._update(time, deltaTime, timeDirection, accuIndex);
			}

			// update scene graph

			const bindings = this._bindings;
			const nBindings = this._nActiveBindings;

			for (var i = 0; i !== nBindings; ++i) {
				bindings[i].apply(accuIndex);
			}

			return this;
		},

		// return this mixer's root target object
		getRoot() {
			return this._root;
		},

		// free all resources specific to a particular clip
		uncacheClip(clip) {
			const actions = this._actions;
			const clipUuid = clip.uuid;
			const actionsByClip = this._actionsByClip;
			const actionsForClip = actionsByClip[clipUuid];

			if (actionsForClip !== undefined) {
				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away

				const actionsToRemove = actionsForClip.knownActions;

				for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
					const action = actionsToRemove[i];

					this._deactivateAction(action);

					const cacheIndex = action._cacheIndex;
					const lastInactiveAction = actions[actions.length - 1];

					action._cacheIndex = null;
					action._byClipCacheIndex = null;

					lastInactiveAction._cacheIndex = cacheIndex;
					actions[cacheIndex] = lastInactiveAction;
					actions.pop();

					this._removeInactiveBindingsForAction(action);
				}

				delete actionsByClip[clipUuid];
			}
		},

		// free all resources specific to a particular root target object
		uncacheRoot(root) {
			const rootUuid = root.uuid;
			const actionsByClip = this._actionsByClip;

			for (const clipUuid in actionsByClip) {
				const { actionByRoot } = actionsByClip[clipUuid];
				const action = actionByRoot[rootUuid];

				if (action !== undefined) {
					this._deactivateAction(action);
					this._removeInactiveAction(action);
				}
			}

			const bindingsByRoot = this._bindingsByRootAndName;
			const bindingByName = bindingsByRoot[rootUuid];

			if (bindingByName !== undefined) {
				for (const trackName in bindingByName) {
					const binding = bindingByName[trackName];
					binding.restoreOriginalState();
					this._removeInactiveBinding(binding);
				}
			}
		},

		// remove a targeted clip from the cache
		uncacheAction(clip, optionalRoot) {
			const action = this.existingAction(clip, optionalRoot);

			if (action !== null) {
				this._deactivateAction(action);
				this._removeInactiveAction(action);
			}
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Uniform(value) {
		if (typeof value === 'string') {
			console.warn('THREE.Uniform: Type parameter is no longer needed.');
			value = arguments[1];
		}

		this.value = value;
	}

	Uniform.prototype.clone = function () {
		return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
	};

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedBufferGeometry() {
		BufferGeometry.call(this);

		this.type = 'InstancedBufferGeometry';
		this.maxInstancedCount = undefined;
	}

	InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {

		constructor: InstancedBufferGeometry,

		isInstancedBufferGeometry: true,

		copy(source) {
			BufferGeometry.prototype.copy.call(this, source);

			this.maxInstancedCount = source.maxInstancedCount;

			return this;
		},

		clone() {
			return new this.constructor().copy(this);
		},

	});

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
		InterleavedBuffer.call(this, array, stride);

		this.meshPerAttribute = meshPerAttribute || 1;
	}

	InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {

		constructor: InstancedInterleavedBuffer,

		isInstancedInterleavedBuffer: true,

		copy(source) {
			InterleavedBuffer.prototype.copy.call(this, source);

			this.meshPerAttribute = source.meshPerAttribute;

			return this;
		},

	});

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
		if (typeof (normalized) === 'number') {
			meshPerAttribute = normalized;

			normalized = false;

			console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
		}

		BufferAttribute.call(this, array, itemSize, normalized);

		this.meshPerAttribute = meshPerAttribute || 1;
	}

	InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {

		constructor: InstancedBufferAttribute,

		isInstancedBufferAttribute: true,

		copy(source) {
			BufferAttribute.prototype.copy.call(this, source);

			this.meshPerAttribute = source.meshPerAttribute;

			return this;
		},

	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io/
	 * @author stephomi / http://stephaneginier.com/
	 */

	function Raycaster(origin, direction, near, far) {
		this.ray = new Ray(origin, direction);
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

		this.params = {
			Mesh: {},
			Line: {},
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {},
		};

		Object.defineProperties(this.params, {
			PointCloud: {
				get() {
					console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
					return this.Points;
				},
			},
		});
	}

	function ascSort(a, b) {
		return a.distance - b.distance;
	}

	function intersectObject(object, raycaster, intersects, recursive) {
		if (object.visible === false) return;

		object.raycast(raycaster, intersects);

		if (recursive === true) {
			const { children } = object;

			for (let i = 0, l = children.length; i < l; i++) {
				intersectObject(children[i], raycaster, intersects, true);
			}
		}
	}

	Object.assign(Raycaster.prototype, {

		linePrecision: 1,

		set(origin, direction) {
			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set(origin, direction);
		},

		setFromCamera(coords, camera) {
			if ((camera && camera.isPerspectiveCamera)) {
				this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
				this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
			} else if ((camera && camera.isOrthographicCamera)) {
				this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
				this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
			} else {
				console.error('THREE.Raycaster: Unsupported camera type.');
			}
		},

		intersectObject(object, recursive, optionalTarget) {
			const intersects = optionalTarget || [];

			intersectObject(object, this, intersects, recursive);

			intersects.sort(ascSort);

			return intersects;
		},

		intersectObjects(objects, recursive, optionalTarget) {
			const intersects = optionalTarget || [];

			if (Array.isArray(objects) === false) {
				console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
				return intersects;
			}

			for (let i = 0, l = objects.length; i < l; i++) {
				intersectObject(objects[i], this, intersects, recursive);
			}

			intersects.sort(ascSort);

			return intersects;
		},

	});

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axiz.
	 */

	function Spherical(radius, phi, theta) {
		this.radius = (radius !== undefined) ? radius : 1.0;
		this.phi = (phi !== undefined) ? phi : 0; // polar angle
		this.theta = (theta !== undefined) ? theta : 0; // azimuthal angle

		return this;
	}

	Object.assign(Spherical.prototype, {

		set(radius, phi, theta) {
			this.radius = radius;
			this.phi = phi;
			this.theta = theta;

			return this;
		},

		clone() {
			return new this.constructor().copy(this);
		},

		copy(other) {
			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;

			return this;
		},

		// restrict phi to be betwee EPS and PI-EPS
		makeSafe() {
			const EPS = 0.000001;
			this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));

			return this;
		},

		setFromVector3(v) {
			return this.setFromCartesianCoords(v.x, v.y, v.z);
		},

		setFromCartesianCoords(x, y, z) {
			this.radius = Math.sqrt(x * x + y * y + z * z);

			if (this.radius === 0) {
				this.theta = 0;
				this.phi = 0;
			} else {
				this.theta = Math.atan2(x, z);
				this.phi = Math.acos(_Math.clamp(y / this.radius, -1, 1));
			}

			return this;
		},

	});

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 *
	 */

	function Cylindrical(radius, theta, y) {
		this.radius = (radius !== undefined) ? radius : 1.0; // distance from the origin to a point in the x-z plane
		this.theta = (theta !== undefined) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = (y !== undefined) ? y : 0; // height above the x-z plane

		return this;
	}

	Object.assign(Cylindrical.prototype, {

		set(radius, theta, y) {
			this.radius = radius;
			this.theta = theta;
			this.y = y;

			return this;
		},

		clone() {
			return new this.constructor().copy(this);
		},

		copy(other) {
			this.radius = other.radius;
			this.theta = other.theta;
			this.y = other.y;

			return this;
		},

		setFromVector3(v) {
			return this.setFromCartesianCoords(v.x, v.y, v.z);
		},

		setFromCartesianCoords(x, y, z) {
			this.radius = Math.sqrt(x * x + z * z);
			this.theta = Math.atan2(x, z);
			this.y = y;

			return this;
		},

	});

	/**
	 * @author bhouston / http://clara.io
	 */

	function Box2(min, max) {
		this.min = (min !== undefined) ? min : new Vector2(+Infinity, +Infinity);
		this.max = (max !== undefined) ? max : new Vector2(-Infinity, -Infinity);
	}

	Object.assign(Box2.prototype, {

		set(min, max) {
			this.min.copy(min);
			this.max.copy(max);

			return this;
		},

		setFromPoints(points) {
			this.makeEmpty();

			for (let i = 0, il = points.length; i < il; i++) {
				this.expandByPoint(points[i]);
			}

			return this;
		},

		setFromCenterAndSize: (function () {
			const v1 = new Vector2();

			return function setFromCenterAndSize(center, size) {
				const halfSize = v1.copy(size).multiplyScalar(0.5);
				this.min.copy(center).sub(halfSize);
				this.max.copy(center).add(halfSize);

				return this;
			};
		}()),

		clone() {
			return new this.constructor().copy(this);
		},

		copy(box) {
			this.min.copy(box.min);
			this.max.copy(box.max);

			return this;
		},

		makeEmpty() {
			this.min.x = this.min.y = +Infinity;
			this.max.x = this.max.y = -Infinity;

			return this;
		},

		isEmpty() {
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return (this.max.x < this.min.x) || (this.max.y < this.min.y);
		},

		getCenter(target) {
			if (target === undefined) {
				console.warn('THREE.Box2: .getCenter() target is now required');
				target = new Vector2();
			}

			return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
		},

		getSize(target) {
			if (target === undefined) {
				console.warn('THREE.Box2: .getSize() target is now required');
				target = new Vector2();
			}

			return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
		},

		expandByPoint(point) {
			this.min.min(point);
			this.max.max(point);

			return this;
		},

		expandByVector(vector) {
			this.min.sub(vector);
			this.max.add(vector);

			return this;
		},

		expandByScalar(scalar) {
			this.min.addScalar(-scalar);
			this.max.addScalar(scalar);

			return this;
		},

		containsPoint(point) {
			return !(point.x < this.min.x || point.x > this.max.x
				|| point.y < this.min.y || point.y > this.max.y);
		},

		containsBox(box) {
			return this.min.x <= box.min.x && box.max.x <= this.max.x
				&& this.min.y <= box.min.y && box.max.y <= this.max.y;
		},

		getParameter(point, target) {
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			if (target === undefined) {
				console.warn('THREE.Box2: .getParameter() target is now required');
				target = new Vector2();
			}

			return target.set(
				(point.x - this.min.x) / (this.max.x - this.min.x),
				(point.y - this.min.y) / (this.max.y - this.min.y),
			);
		},

		intersectsBox(box) {
			// using 4 splitting planes to rule out intersections

			return !(box.max.x < this.min.x || box.min.x > this.max.x
				|| box.max.y < this.min.y || box.min.y > this.max.y);
		},

		clampPoint(point, target) {
			if (target === undefined) {
				console.warn('THREE.Box2: .clampPoint() target is now required');
				target = new Vector2();
			}

			return target.copy(point).clamp(this.min, this.max);
		},

		distanceToPoint: (function () {
			const v1 = new Vector2();

			return function distanceToPoint(point) {
				const clampedPoint = v1.copy(point).clamp(this.min, this.max);
				return clampedPoint.sub(point).length();
			};
		}()),

		intersect(box) {
			this.min.max(box.min);
			this.max.min(box.max);

			return this;
		},

		union(box) {
			this.min.min(box.min);
			this.max.max(box.max);

			return this;
		},

		translate(offset) {
			this.min.add(offset);
			this.max.add(offset);

			return this;
		},

		equals(box) {
			return box.min.equals(this.min) && box.max.equals(this.max);
		},

	});

	/**
	 * @author bhouston / http://clara.io
	 */

	function Line3(start, end) {
		this.start = (start !== undefined) ? start : new Vector3();
		this.end = (end !== undefined) ? end : new Vector3();
	}

	Object.assign(Line3.prototype, {

		set(start, end) {
			this.start.copy(start);
			this.end.copy(end);

			return this;
		},

		clone() {
			return new this.constructor().copy(this);
		},

		copy(line) {
			this.start.copy(line.start);
			this.end.copy(line.end);

			return this;
		},

		getCenter(target) {
			if (target === undefined) {
				console.warn('THREE.Line3: .getCenter() target is now required');
				target = new Vector3();
			}

			return target.addVectors(this.start, this.end).multiplyScalar(0.5);
		},

		delta(target) {
			if (target === undefined) {
				console.warn('THREE.Line3: .delta() target is now required');
				target = new Vector3();
			}

			return target.subVectors(this.end, this.start);
		},

		distanceSq() {
			return this.start.distanceToSquared(this.end);
		},

		distance() {
			return this.start.distanceTo(this.end);
		},

		at(t, target) {
			if (target === undefined) {
				console.warn('THREE.Line3: .at() target is now required');
				target = new Vector3();
			}

			return this.delta(target).multiplyScalar(t).add(this.start);
		},

		closestPointToPointParameter: (function () {
			const startP = new Vector3();
			const startEnd = new Vector3();

			return function closestPointToPointParameter(point, clampToLine) {
				startP.subVectors(point, this.start);
				startEnd.subVectors(this.end, this.start);

				const startEnd2 = startEnd.dot(startEnd);
				const startEnd_startP = startEnd.dot(startP);

				let t = startEnd_startP / startEnd2;

				if (clampToLine) {
					t = _Math.clamp(t, 0, 1);
				}

				return t;
			};
		}()),

		closestPointToPoint(point, clampToLine, target) {
			const t = this.closestPointToPointParameter(point, clampToLine);

			if (target === undefined) {
				console.warn('THREE.Line3: .closestPointToPoint() target is now required');
				target = new Vector3();
			}

			return this.delta(target).multiplyScalar(t).add(this.start);
		},

		applyMatrix4(matrix) {
			this.start.applyMatrix4(matrix);
			this.end.applyMatrix4(matrix);

			return this;
		},

		equals(line) {
			return line.start.equals(this.start) && line.end.equals(this.end);
		},

	});

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function ImmediateRenderObject(material) {
		Object3D.call(this);

		this.material = material;
		this.render = function (/* renderCallback */) {};
	}

	ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
	ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

	ImmediateRenderObject.prototype.isImmediateRenderObject = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function VertexNormalsHelper(object, size, hex, linewidth) {
		this.object = object;

		this.size = (size !== undefined) ? size : 1;

		const color = (hex !== undefined) ? hex : 0xff0000;

		const width = (linewidth !== undefined) ? linewidth : 1;

		//

		let nNormals = 0;

		const objGeometry = this.object.geometry;

		if (objGeometry && objGeometry.isGeometry) {
			nNormals = objGeometry.faces.length * 3;
		} else if (objGeometry && objGeometry.isBufferGeometry) {
			nNormals = objGeometry.attributes.normal.count;
		}

		//

		const geometry = new BufferGeometry();

		const positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);

		geometry.addAttribute('position', positions);

		LineSegments.call(this, geometry, new LineBasicMaterial({ color, linewidth: width }));

		//

		this.matrixAutoUpdate = false;

		this.update();
	}

	VertexNormalsHelper.prototype = Object.create(LineSegments.prototype);
	VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

	VertexNormalsHelper.prototype.update = (function () {
		const v1 = new Vector3();
		const v2 = new Vector3();
		const normalMatrix = new Matrix3();

		return function update() {
			const keys = ['a', 'b', 'c'];

			this.object.updateMatrixWorld(true);

			normalMatrix.getNormalMatrix(this.object.matrixWorld);

			const { matrixWorld } = this.object;

			const { position } = this.geometry.attributes;

			//

			const objGeometry = this.object.geometry;

			if (objGeometry && objGeometry.isGeometry) {
				const { vertices } = objGeometry;

				const { faces } = objGeometry;

				var idx = 0;

				for (let i = 0, l = faces.length; i < l; i++) {
					const face = faces[i];

					for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
						const vertex = vertices[face[keys[j]]];

						const normal = face.vertexNormals[j];

						v1.copy(vertex).applyMatrix4(matrixWorld);

						v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size)
							.add(v1);

						position.setXYZ(idx, v1.x, v1.y, v1.z);

						idx += 1;

						position.setXYZ(idx, v2.x, v2.y, v2.z);

						idx += 1;
					}
				}
			} else if (objGeometry && objGeometry.isBufferGeometry) {
				const objPos = objGeometry.attributes.position;

				const objNorm = objGeometry.attributes.normal;

				var idx = 0;

				// for simplicity, ignore index and drawcalls, and render every normal

				for (var j = 0, jl = objPos.count; j < jl; j++) {
					v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);

					v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));

					v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);

					position.setXYZ(idx, v1.x, v1.y, v1.z);

					idx += 1;

					position.setXYZ(idx, v2.x, v2.y, v2.z);

					idx += 1;
				}
			}

			position.needsUpdate = true;
		};
	}());

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function SpotLightHelper(light, color) {
		Object3D.call(this);

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		const geometry = new BufferGeometry();

		const positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	-1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, -1, 1,
		];

		for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
			const p1 = (i / l) * Math.PI * 2;
			const p2 = (j / l) * Math.PI * 2;

			positions.push(
				Math.cos(p1), Math.sin(p1), 1,
				Math.cos(p2), Math.sin(p2), 1,
			);
		}

		geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));

		const material = new LineBasicMaterial({ fog: false });

		this.cone = new LineSegments(geometry, material);
		this.add(this.cone);

		this.update();
	}

	SpotLightHelper.prototype = Object.create(Object3D.prototype);
	SpotLightHelper.prototype.constructor = SpotLightHelper;

	SpotLightHelper.prototype.dispose = function () {
		this.cone.geometry.dispose();
		this.cone.material.dispose();
	};

	SpotLightHelper.prototype.update = (function () {
		const vector = new Vector3();

		return function update() {
			this.light.updateMatrixWorld();

			const coneLength = this.light.distance ? this.light.distance : 1000;
			const coneWidth = coneLength * Math.tan(this.light.angle);

			this.cone.scale.set(coneWidth, coneWidth, coneLength);

			vector.setFromMatrixPosition(this.light.target.matrixWorld);

			this.cone.lookAt(vector);

			if (this.color !== undefined) {
				this.cone.material.color.set(this.color);
			} else {
				this.cone.material.color.copy(this.light.color);
			}
		};
	}());

	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function getBoneList(object) {
		const boneList = [];

		if (object && object.isBone) {
			boneList.push(object);
		}

		for (let i = 0; i < object.children.length; i++) {
			boneList.push.apply(boneList, getBoneList(object.children[i]));
		}

		return boneList;
	}

	function SkeletonHelper(object) {
		const bones = getBoneList(object);

		const geometry = new BufferGeometry();

		const vertices = [];
		const colors = [];

		const color1 = new Color(0, 0, 1);
		const color2 = new Color(0, 1, 0);

		for (let i = 0; i < bones.length; i++) {
			const bone = bones[i];

			if (bone.parent && bone.parent.isBone) {
				vertices.push(0, 0, 0);
				vertices.push(0, 0, 0);
				colors.push(color1.r, color1.g, color1.b);
				colors.push(color2.r, color2.g, color2.b);
			}
		}

		geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
		geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));

		const material = new LineBasicMaterial({
			vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true,
		});

		LineSegments.call(this, geometry, material);

		this.root = object;
		this.bones = bones;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	}

	SkeletonHelper.prototype = Object.create(LineSegments.prototype);
	SkeletonHelper.prototype.constructor = SkeletonHelper;

	SkeletonHelper.prototype.updateMatrixWorld = (function () {
		const vector = new Vector3();

		const boneMatrix = new Matrix4();
		const matrixWorldInv = new Matrix4();

		return function updateMatrixWorld(force) {
			const { bones } = this;

			const { geometry } = this;
			const position = geometry.getAttribute('position');

			matrixWorldInv.getInverse(this.root.matrixWorld);

			for (let i = 0, j = 0; i < bones.length; i++) {
				const bone = bones[i];

				if (bone.parent && bone.parent.isBone) {
					boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
					vector.setFromMatrixPosition(boneMatrix);
					position.setXYZ(j, vector.x, vector.y, vector.z);

					boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
					vector.setFromMatrixPosition(boneMatrix);
					position.setXYZ(j + 1, vector.x, vector.y, vector.z);

					j += 2;
				}
			}

			geometry.getAttribute('position').needsUpdate = true;

			Object3D.prototype.updateMatrixWorld.call(this, force);
		};
	}());

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function PointLightHelper(light, sphereSize, color) {
		this.light = light;
		this.light.updateMatrixWorld();

		this.color = color;

		const geometry = new SphereBufferGeometry(sphereSize, 4, 2);
		const material = new MeshBasicMaterial({ wireframe: true, fog: false });

		Mesh.call(this, geometry, material);

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();


		/*
		var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		var d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/
	}

	PointLightHelper.prototype = Object.create(Mesh.prototype);
	PointLightHelper.prototype.constructor = PointLightHelper;

	PointLightHelper.prototype.dispose = function () {
		this.geometry.dispose();
		this.material.dispose();
	};

	PointLightHelper.prototype.update = function () {
		if (this.color !== undefined) {
			this.material.color.set(this.color);
		} else {
			this.material.color.copy(this.light.color);
		}

		/*
		var d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/
	};

	/**
	 * @author abelnation / http://github.com/abelnation
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 *  This helper must be added as a child of the light
	 */

	function RectAreaLightHelper(light, color) {
		this.type = 'RectAreaLightHelper';

		this.light = light;

		this.color = color; // optional hardwired color for the helper

		const positions = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];

		const geometry = new BufferGeometry();
		geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));
		geometry.computeBoundingSphere();

		const material = new LineBasicMaterial({ fog: false });

		Line.call(this, geometry, material);

		//

		const positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];

		const geometry2 = new BufferGeometry();
		geometry2.addAttribute('position', new Float32BufferAttribute(positions2, 3));
		geometry2.computeBoundingSphere();

		this.add(new Mesh(geometry2, new MeshBasicMaterial({ side: THREE.BackSide, fog: false })));

		this.update();
	}

	RectAreaLightHelper.prototype = Object.create(Line.prototype);
	RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

	RectAreaLightHelper.prototype.update = function () {
		this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1);

		if (this.color !== undefined) {
			this.material.color.set(this.color);
			this.children[0].material.color.set(this.color);
		} else {
			this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);

			// prevent hue shift
			const c = this.material.color;
			const max = Math.max(c.r, c.g, c.b);
			if (max > 1) c.multiplyScalar(1 / max);

			this.children[0].material.color.copy(this.material.color);
		}
	};

	RectAreaLightHelper.prototype.dispose = function () {
		this.geometry.dispose();
		this.material.dispose();
		this.children[0].geometry.dispose();
		this.children[0].material.dispose();
	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function HemisphereLightHelper(light, size, color) {
		Object3D.call(this);

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		const geometry = new OctahedronBufferGeometry(size);
		geometry.rotateY(Math.PI * 0.5);

		this.material = new MeshBasicMaterial({ wireframe: true, fog: false });
		if (this.color === undefined) this.material.vertexColors = VertexColors;

		const position = geometry.getAttribute('position');
		const colors = new Float32Array(position.count * 3);

		geometry.addAttribute('color', new BufferAttribute(colors, 3));

		this.add(new Mesh(geometry, this.material));

		this.update();
	}

	HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
	HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

	HemisphereLightHelper.prototype.dispose = function () {
		this.children[0].geometry.dispose();
		this.children[0].material.dispose();
	};

	HemisphereLightHelper.prototype.update = (function () {
		const vector = new Vector3();

		const color1 = new Color();
		const color2 = new Color();

		return function update() {
			const mesh = this.children[0];

			if (this.color !== undefined) {
				this.material.color.set(this.color);
			} else {
				const colors = mesh.geometry.getAttribute('color');

				color1.copy(this.light.color);
				color2.copy(this.light.groundColor);

				for (let i = 0, l = colors.count; i < l; i++) {
					const color = (i < (l / 2)) ? color1 : color2;

					colors.setXYZ(i, color.r, color.g, color.b);
				}

				colors.needsUpdate = true;
			}

			mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
		};
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function GridHelper(size, divisions, color1, color2) {
		size = size || 10;
		divisions = divisions || 10;
		color1 = new Color(color1 !== undefined ? color1 : 0x444444);
		color2 = new Color(color2 !== undefined ? color2 : 0x888888);

		const center = divisions / 2;
		const step = size / divisions;
		const halfSize = size / 2;

		const vertices = []; const
			colors = [];

		for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
			vertices.push(-halfSize, 0, k, halfSize, 0, k);
			vertices.push(k, 0, -halfSize, k, 0, halfSize);

			const color = i === center ? color1 : color2;

			color.toArray(colors, j); j += 3;
			color.toArray(colors, j); j += 3;
			color.toArray(colors, j); j += 3;
			color.toArray(colors, j); j += 3;
		}

		const geometry = new BufferGeometry();
		geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
		geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));

		const material = new LineBasicMaterial({ vertexColors: VertexColors });

		LineSegments.call(this, geometry, material);
	}

	GridHelper.prototype = Object.create(LineSegments.prototype);
	GridHelper.prototype.constructor = GridHelper;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author Hectate / http://www.github.com/Hectate
	 */

	function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
		radius = radius || 10;
		radials = radials || 16;
		circles = circles || 8;
		divisions = divisions || 64;
		color1 = new Color(color1 !== undefined ? color1 : 0x444444);
		color2 = new Color(color2 !== undefined ? color2 : 0x888888);

		const vertices = [];
		const colors = [];

		let x; let
			z;
		let v; let i; let j; let r; let
			color;

		// create the radials

		for (i = 0; i <= radials; i++) {
			v = (i / radials) * (Math.PI * 2);

			x = Math.sin(v) * radius;
			z = Math.cos(v) * radius;

			vertices.push(0, 0, 0);
			vertices.push(x, 0, z);

			color = (i & 1) ? color1 : color2;

			colors.push(color.r, color.g, color.b);
			colors.push(color.r, color.g, color.b);
		}

		// create the circles

		for (i = 0; i <= circles; i++) {
			color = (i & 1) ? color1 : color2;

			r = radius - (radius / circles * i);

			for (j = 0; j < divisions; j++) {
				// first vertex

				v = (j / divisions) * (Math.PI * 2);

				x = Math.sin(v) * r;
				z = Math.cos(v) * r;

				vertices.push(x, 0, z);
				colors.push(color.r, color.g, color.b);

				// second vertex

				v = ((j + 1) / divisions) * (Math.PI * 2);

				x = Math.sin(v) * r;
				z = Math.cos(v) * r;

				vertices.push(x, 0, z);
				colors.push(color.r, color.g, color.b);
			}
		}

		const geometry = new BufferGeometry();
		geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
		geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));

		const material = new LineBasicMaterial({ vertexColors: VertexColors });

		LineSegments.call(this, geometry, material);
	}

	PolarGridHelper.prototype = Object.create(LineSegments.prototype);
	PolarGridHelper.prototype.constructor = PolarGridHelper;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function FaceNormalsHelper(object, size, hex, linewidth) {
		// FaceNormalsHelper only supports THREE.Geometry

		this.object = object;

		this.size = (size !== undefined) ? size : 1;

		const color = (hex !== undefined) ? hex : 0xffff00;

		const width = (linewidth !== undefined) ? linewidth : 1;

		//

		let nNormals = 0;

		const objGeometry = this.object.geometry;

		if (objGeometry && objGeometry.isGeometry) {
			nNormals = objGeometry.faces.length;
		} else {
			console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');
		}

		//

		const geometry = new BufferGeometry();

		const positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);

		geometry.addAttribute('position', positions);

		LineSegments.call(this, geometry, new LineBasicMaterial({ color, linewidth: width }));

		//

		this.matrixAutoUpdate = false;
		this.update();
	}

	FaceNormalsHelper.prototype = Object.create(LineSegments.prototype);
	FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

	FaceNormalsHelper.prototype.update = (function () {
		const v1 = new Vector3();
		const v2 = new Vector3();
		const normalMatrix = new Matrix3();

		return function update() {
			this.object.updateMatrixWorld(true);

			normalMatrix.getNormalMatrix(this.object.matrixWorld);

			const { matrixWorld } = this.object;

			const { position } = this.geometry.attributes;

			//

			const objGeometry = this.object.geometry;

			const { vertices } = objGeometry;

			const { faces } = objGeometry;

			let idx = 0;

			for (let i = 0, l = faces.length; i < l; i++) {
				const face = faces[i];

				const { normal } = face;

				v1.copy(vertices[face.a])
					.add(vertices[face.b])
					.add(vertices[face.c])
					.divideScalar(3)
					.applyMatrix4(matrixWorld);

				v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size)
					.add(v1);

				position.setXYZ(idx, v1.x, v1.y, v1.z);

				idx += 1;

				position.setXYZ(idx, v2.x, v2.y, v2.z);

				idx += 1;
			}

			position.needsUpdate = true;
		};
	}());

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function DirectionalLightHelper(light, size, color) {
		Object3D.call(this);

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		if (size === undefined) size = 1;

		let geometry = new BufferGeometry();
		geometry.addAttribute('position', new Float32BufferAttribute([
			-size, size, 0,
			size, size, 0,
			size, -size, 0,
			-size, -size, 0,
			-size, size, 0,
		], 3));

		const material = new LineBasicMaterial({ fog: false });

		this.lightPlane = new Line(geometry, material);
		this.add(this.lightPlane);

		geometry = new BufferGeometry();
		geometry.addAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));

		this.targetLine = new Line(geometry, material);
		this.add(this.targetLine);

		this.update();
	}

	DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
	DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

	DirectionalLightHelper.prototype.dispose = function () {
		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();
	};

	DirectionalLightHelper.prototype.update = (function () {
		const v1 = new Vector3();
		const v2 = new Vector3();
		const v3 = new Vector3();

		return function update() {
			v1.setFromMatrixPosition(this.light.matrixWorld);
			v2.setFromMatrixPosition(this.light.target.matrixWorld);
			v3.subVectors(v2, v1);

			this.lightPlane.lookAt(v2);

			if (this.color !== undefined) {
				this.lightPlane.material.color.set(this.color);
				this.targetLine.material.color.set(this.color);
			} else {
				this.lightPlane.material.color.copy(this.light.color);
				this.targetLine.material.color.copy(this.light.color);
			}

			this.targetLine.lookAt(v2);
			this.targetLine.scale.z = v3.length();
		};
	}());

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */

	function CameraHelper(camera) {
		const geometry = new BufferGeometry();
		const material = new LineBasicMaterial({ color: 0xffffff, vertexColors: FaceColors });

		const vertices = [];
		const colors = [];

		const pointMap = {};

		// colors

		const colorFrustum = new Color(0xffaa00);
		const colorCone = new Color(0xff0000);
		const colorUp = new Color(0x00aaff);
		const colorTarget = new Color(0xffffff);
		const colorCross = new Color(0x333333);

		// near

		addLine('n1', 'n2', colorFrustum);
		addLine('n2', 'n4', colorFrustum);
		addLine('n4', 'n3', colorFrustum);
		addLine('n3', 'n1', colorFrustum);

		// far

		addLine('f1', 'f2', colorFrustum);
		addLine('f2', 'f4', colorFrustum);
		addLine('f4', 'f3', colorFrustum);
		addLine('f3', 'f1', colorFrustum);

		// sides

		addLine('n1', 'f1', colorFrustum);
		addLine('n2', 'f2', colorFrustum);
		addLine('n3', 'f3', colorFrustum);
		addLine('n4', 'f4', colorFrustum);

		// cone

		addLine('p', 'n1', colorCone);
		addLine('p', 'n2', colorCone);
		addLine('p', 'n3', colorCone);
		addLine('p', 'n4', colorCone);

		// up

		addLine('u1', 'u2', colorUp);
		addLine('u2', 'u3', colorUp);
		addLine('u3', 'u1', colorUp);

		// target

		addLine('c', 't', colorTarget);
		addLine('p', 'c', colorCross);

		// cross

		addLine('cn1', 'cn2', colorCross);
		addLine('cn3', 'cn4', colorCross);

		addLine('cf1', 'cf2', colorCross);
		addLine('cf3', 'cf4', colorCross);

		function addLine(a, b, color) {
			addPoint(a, color);
			addPoint(b, color);
		}

		function addPoint(id, color) {
			vertices.push(0, 0, 0);
			colors.push(color.r, color.g, color.b);

			if (pointMap[id] === undefined) {
				pointMap[id] = [];
			}

			pointMap[id].push((vertices.length / 3) - 1);
		}

		geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
		geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));

		LineSegments.call(this, geometry, material);

		this.camera = camera;
		if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();
	}

	CameraHelper.prototype = Object.create(LineSegments.prototype);
	CameraHelper.prototype.constructor = CameraHelper;

	CameraHelper.prototype.update = (function () {
		let geometry; let
			pointMap;

		const vector = new Vector3();
		const camera = new Camera();

		function setPoint(point, x, y, z) {
			vector.set(x, y, z).unproject(camera);

			const points = pointMap[point];

			if (points !== undefined) {
				const position = geometry.getAttribute('position');

				for (let i = 0, l = points.length; i < l; i++) {
					position.setXYZ(points[i], vector.x, vector.y, vector.z);
				}
			}
		}

		return function update() {
			geometry = this.geometry;
			pointMap = this.pointMap;

			const w = 1; const
				h = 1;

			// we need just camera projection matrix
			// world matrix must be identity

			camera.projectionMatrix.copy(this.camera.projectionMatrix);

			// center / target

			setPoint('c', 0, 0, -1);
			setPoint('t', 0, 0, 1);

			// near

			setPoint('n1', -w, -h, -1);
			setPoint('n2', w, -h, -1);
			setPoint('n3', -w, h, -1);
			setPoint('n4', w, h, -1);

			// far

			setPoint('f1', -w, -h, 1);
			setPoint('f2', w, -h, 1);
			setPoint('f3', -w, h, 1);
			setPoint('f4', w, h, 1);

			// up

			setPoint('u1', w * 0.7, h * 1.1, -1);
			setPoint('u2', -w * 0.7, h * 1.1, -1);
			setPoint('u3', 0, h * 2, -1);

			// cross

			setPoint('cf1', -w, 0, 1);
			setPoint('cf2', w, 0, 1);
			setPoint('cf3', 0, -h, 1);
			setPoint('cf4', 0, h, 1);

			setPoint('cn1', -w, 0, -1);
			setPoint('cn2', w, 0, -1);
			setPoint('cn3', 0, -h, -1);
			setPoint('cn4', 0, h, -1);

			geometry.getAttribute('position').needsUpdate = true;
		};
	}());

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 */

	function BoxHelper(object, color) {
		this.object = object;

		if (color === undefined) color = 0xffff00;

		const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
		const positions = new Float32Array(8 * 3);

		const geometry = new BufferGeometry();
		geometry.setIndex(new BufferAttribute(indices, 1));
		geometry.addAttribute('position', new BufferAttribute(positions, 3));

		LineSegments.call(this, geometry, new LineBasicMaterial({ color }));

		this.matrixAutoUpdate = false;

		this.update();
	}

	BoxHelper.prototype = Object.create(LineSegments.prototype);
	BoxHelper.prototype.constructor = BoxHelper;

	BoxHelper.prototype.update = (function () {
		const box = new Box3();

		return function update(object) {
			if (object !== undefined) {
				console.warn('THREE.BoxHelper: .update() has no longer arguments.');
			}

			if (this.object !== undefined) {
				box.setFromObject(this.object);
			}

			if (box.isEmpty()) return;

			const { min } = box;
			const { max } = box;

			/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/

			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			const { position } = this.geometry.attributes;
			const { array } = position;

			array[0] = max.x; array[1] = max.y; array[2] = max.z;
			array[3] = min.x; array[4] = max.y; array[5] = max.z;
			array[6] = min.x; array[7] = min.y; array[8] = max.z;
			array[9] = max.x; array[10] = min.y; array[11] = max.z;
			array[12] = max.x; array[13] = max.y; array[14] = min.z;
			array[15] = min.x; array[16] = max.y; array[17] = min.z;
			array[18] = min.x; array[19] = min.y; array[20] = min.z;
			array[21] = max.x; array[22] = min.y; array[23] = min.z;

			position.needsUpdate = true;

			this.geometry.computeBoundingSphere();
		};
	}());

	BoxHelper.prototype.setFromObject = function (object) {
		this.object = object;
		this.update();

		return this;
	};

	BoxHelper.prototype.copy = function (source) {
		LineSegments.prototype.copy.call(this, source);

		this.object = source.object;

		return this;
	};

	BoxHelper.prototype.clone = function () {
		return new this.constructor().copy(this);
	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Box3Helper(box, hex) {
		this.type = 'Box3Helper';

		this.box = box;

		const color = (hex !== undefined) ? hex : 0xffff00;

		const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);

		const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];

		const geometry = new BufferGeometry();

		geometry.setIndex(new BufferAttribute(indices, 1));

		geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));

		LineSegments.call(this, geometry, new LineBasicMaterial({ color }));

		this.geometry.computeBoundingSphere();
	}

	Box3Helper.prototype = Object.create(LineSegments.prototype);
	Box3Helper.prototype.constructor = Box3Helper;

	Box3Helper.prototype.updateMatrixWorld = function (force) {
		const { box } = this;

		if (box.isEmpty()) return;

		box.getCenter(this.position);

		box.getSize(this.scale);

		this.scale.multiplyScalar(0.5);

		Object3D.prototype.updateMatrixWorld.call(this, force);
	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function PlaneHelper(plane, size, hex) {
		this.type = 'PlaneHelper';

		this.plane = plane;

		this.size = (size === undefined) ? 1 : size;

		const color = (hex !== undefined) ? hex : 0xffff00;

		const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];

		const geometry = new BufferGeometry();
		geometry.addAttribute('position', new Float32BufferAttribute(positions, 3));
		geometry.computeBoundingSphere();

		Line.call(this, geometry, new LineBasicMaterial({ color }));

		//

		const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];

		const geometry2 = new BufferGeometry();
		geometry2.addAttribute('position', new Float32BufferAttribute(positions2, 3));
		geometry2.computeBoundingSphere();

		this.add(new Mesh(geometry2, new MeshBasicMaterial({
			color, opacity: 0.2, transparent: true, depthWrite: false,
		})));
	}

	PlaneHelper.prototype = Object.create(Line.prototype);
	PlaneHelper.prototype.constructor = PlaneHelper;

	PlaneHelper.prototype.updateMatrixWorld = function (force) {
		let scale = -this.plane.constant;

		if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter

		this.scale.set(0.5 * this.size, 0.5 * this.size, scale);

		this.children[0].material.side = (scale < 0) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

		this.lookAt(this.plane.normal);

		Object3D.prototype.updateMatrixWorld.call(this, force);
	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://clara.io
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */

	let lineGeometry; let
		coneGeometry;

	function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
		// dir is assumed to be normalized

		Object3D.call(this);

		if (dir === undefined) dir = new THREE.Vector3(0, 0, 1);
		if (origin === undefined) origin = new THREE.Vector3(0, 0, 0);
		if (length === undefined) length = 1;
		if (color === undefined) color = 0xffff00;
		if (headLength === undefined) headLength = 0.2 * length;
		if (headWidth === undefined) headWidth = 0.2 * headLength;

		if (lineGeometry === undefined) {
			lineGeometry = new BufferGeometry();
			lineGeometry.addAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

			coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
			coneGeometry.translate(0, -0.5, 0);
		}

		this.position.copy(origin);

		this.line = new Line(lineGeometry, new LineBasicMaterial({ color }));
		this.line.matrixAutoUpdate = false;
		this.add(this.line);

		this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({ color }));
		this.cone.matrixAutoUpdate = false;
		this.add(this.cone);

		this.setDirection(dir);
		this.setLength(length, headLength, headWidth);
	}

	ArrowHelper.prototype = Object.create(Object3D.prototype);
	ArrowHelper.prototype.constructor = ArrowHelper;

	ArrowHelper.prototype.setDirection = (function () {
		const axis = new Vector3();
		let radians;

		return function setDirection(dir) {
			// dir is assumed to be normalized

			if (dir.y > 0.99999) {
				this.quaternion.set(0, 0, 0, 1);
			} else if (dir.y < -0.99999) {
				this.quaternion.set(1, 0, 0, 0);
			} else {
				axis.set(dir.z, 0, -dir.x).normalize();

				radians = Math.acos(dir.y);

				this.quaternion.setFromAxisAngle(axis, radians);
			}
		};
	}());

	ArrowHelper.prototype.setLength = function (length, headLength, headWidth) {
		if (headLength === undefined) headLength = 0.2 * length;
		if (headWidth === undefined) headWidth = 0.2 * headLength;

		this.line.scale.set(1, Math.max(0, length - headLength), 1);
		this.line.updateMatrix();

		this.cone.scale.set(headWidth, headLength, headWidth);
		this.cone.position.y = length;
		this.cone.updateMatrix();
	};

	ArrowHelper.prototype.setColor = function (color) {
		this.line.material.color.copy(color);
		this.cone.material.color.copy(color);
	};

	ArrowHelper.prototype.copy = function (source) {
		Object3D.prototype.copy.call(this, source, false);

		this.line.copy(source.line);
		this.cone.copy(source.cone);

		return this;
	};

	ArrowHelper.prototype.clone = function () {
		return new this.constructor().copy(this);
	};

	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AxesHelper(size) {
		size = size || 1;

		const vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size,
		];

		const colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1,
		];

		const geometry = new BufferGeometry();
		geometry.addAttribute('position', new Float32BufferAttribute(vertices, 3));
		geometry.addAttribute('color', new Float32BufferAttribute(colors, 3));

		const material = new LineBasicMaterial({ vertexColors: VertexColors });

		LineSegments.call(this, geometry, material);
	}

	AxesHelper.prototype = Object.create(LineSegments.prototype);
	AxesHelper.prototype.constructor = AxesHelper;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Face4(a, b, c, d, normal, color, materialIndex) {
		console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
		return new Face3(a, b, c, normal, color, materialIndex);
	}

	const LineStrip = 0;

	const LinePieces = 1;

	function MeshFaceMaterial(materials) {
		console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
		return materials;
	}

	function MultiMaterial(materials) {
		if (materials === undefined) materials = [];

		console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
		materials.isMultiMaterial = true;
		materials.materials = materials;
		materials.clone = function () {
			return materials.slice();
		};
		return materials;
	}

	function PointCloud(geometry, material) {
		console.warn('THREE.PointCloud has been renamed to THREE.Points.');
		return new Points(geometry, material);
	}

	function Particle(material) {
		console.warn('THREE.Particle has been renamed to THREE.Sprite.');
		return new Sprite(material);
	}

	function ParticleSystem(geometry, material) {
		console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
		return new Points(geometry, material);
	}

	function PointCloudMaterial(parameters) {
		console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}

	function ParticleBasicMaterial(parameters) {
		console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}

	function ParticleSystemMaterial(parameters) {
		console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}

	function Vertex(x, y, z) {
		console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
		return new Vector3(x, y, z);
	}

	//

	function DynamicBufferAttribute(array, itemSize) {
		console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');
		return new BufferAttribute(array, itemSize).setDynamic(true);
	}

	function Int8Attribute(array, itemSize) {
		console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
		return new Int8BufferAttribute(array, itemSize);
	}

	function Uint8Attribute(array, itemSize) {
		console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
		return new Uint8BufferAttribute(array, itemSize);
	}

	function Uint8ClampedAttribute(array, itemSize) {
		console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
		return new Uint8ClampedBufferAttribute(array, itemSize);
	}

	function Int16Attribute(array, itemSize) {
		console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
		return new Int16BufferAttribute(array, itemSize);
	}

	function Uint16Attribute(array, itemSize) {
		console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
		return new Uint16BufferAttribute(array, itemSize);
	}

	function Int32Attribute(array, itemSize) {
		console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
		return new Int32BufferAttribute(array, itemSize);
	}

	function Uint32Attribute(array, itemSize) {
		console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
		return new Uint32BufferAttribute(array, itemSize);
	}

	function Float32Attribute(array, itemSize) {
		console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
		return new Float32BufferAttribute(array, itemSize);
	}

	function Float64Attribute(array, itemSize) {
		console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
		return new Float64BufferAttribute(array, itemSize);
	}

	//

	Curve.create = function (construct, getPoint) {
		console.log('THREE.Curve.create() has been deprecated');

		construct.prototype = Object.create(Curve.prototype);
		construct.prototype.constructor = construct;
		construct.prototype.getPoint = getPoint;

		return construct;
	};

	//

	Object.assign(CurvePath.prototype, {

		createPointsGeometry(divisions) {
			console.warn('THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');

			// generate geometry from path points (for Line or Points objects)

			const pts = this.getPoints(divisions);
			return this.createGeometry(pts);
		},

		createSpacedPointsGeometry(divisions) {
			console.warn('THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');

			// generate geometry from equidistant sampling along the path

			const pts = this.getSpacedPoints(divisions);
			return this.createGeometry(pts);
		},

		createGeometry(points) {
			console.warn('THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');

			const geometry = new Geometry();

			for (let i = 0, l = points.length; i < l; i++) {
				const point = points[i];
				geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
			}

			return geometry;
		},

	});

	//

	Object.assign(Path.prototype, {

		fromPoints(points) {
			console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
			this.setFromPoints(points);
		},

	});

	//

	function ClosedSplineCurve3(points) {
		console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');

		CatmullRomCurve3.call(this, points);
		this.type = 'catmullrom';
		this.closed = true;
	}

	ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);

	//

	function SplineCurve3(points) {
		console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');

		CatmullRomCurve3.call(this, points);
		this.type = 'catmullrom';
	}

	SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);

	//

	function Spline(points) {
		console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');

		CatmullRomCurve3.call(this, points);
		this.type = 'catmullrom';
	}

	Spline.prototype = Object.create(CatmullRomCurve3.prototype);

	Object.assign(Spline.prototype, {

		initFromArray(/* a */) {
			console.error('THREE.Spline: .initFromArray() has been removed.');
		},
		getControlPointsArray(/* optionalTarget */) {
			console.error('THREE.Spline: .getControlPointsArray() has been removed.');
		},
		reparametrizeByArcLength(/* samplingCoef */) {
			console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');
		},

	});

	//

	function AxisHelper(size) {
		console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
		return new AxesHelper(size);
	}

	function BoundingBoxHelper(object, color) {
		console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
		return new BoxHelper(object, color);
	}

	function EdgesHelper(object, hex) {
		console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
		return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({ color: hex !== undefined ? hex : 0xffffff }));
	}

	GridHelper.prototype.setColors = function () {
		console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
	};

	SkeletonHelper.prototype.update = function () {
		console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
	};

	function WireframeHelper(object, hex) {
		console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
		return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({ color: hex !== undefined ? hex : 0xffffff }));
	}

	//

	Object.assign(Loader.prototype, {

		extractUrlBase(url) {
			console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
			return LoaderUtils.extractUrlBase(url);
		},

	});

	function XHRLoader(manager) {
		console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
		return new FileLoader(manager);
	}

	function BinaryTextureLoader(manager) {
		console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
		return new DataTextureLoader(manager);
	}

	Object.assign(ObjectLoader.prototype, {

		setTexturePath(value) {
			console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
			return this.setResourcePath(value);
		},

	});

	//

	Object.assign(Box2.prototype, {

		center(optionalTarget) {
			console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
			return this.getCenter(optionalTarget);
		},
		empty() {
			console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
			return this.isEmpty();
		},
		isIntersectionBox(box) {
			console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
			return this.intersectsBox(box);
		},
		size(optionalTarget) {
			console.warn('THREE.Box2: .size() has been renamed to .getSize().');
			return this.getSize(optionalTarget);
		},
	});

	Object.assign(Box3.prototype, {

		center(optionalTarget) {
			console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
			return this.getCenter(optionalTarget);
		},
		empty() {
			console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
			return this.isEmpty();
		},
		isIntersectionBox(box) {
			console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
			return this.intersectsBox(box);
		},
		isIntersectionSphere(sphere) {
			console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
			return this.intersectsSphere(sphere);
		},
		size(optionalTarget) {
			console.warn('THREE.Box3: .size() has been renamed to .getSize().');
			return this.getSize(optionalTarget);
		},
	});

	Line3.prototype.center = function (optionalTarget) {
		console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
		return this.getCenter(optionalTarget);
	};

	Object.assign(_Math, {

		random16() {
			console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');
			return Math.random();
		},

		nearestPowerOfTwo(value) {
			console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');
			return _Math.floorPowerOfTwo(value);
		},

		nextPowerOfTwo(value) {
			console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');
			return _Math.ceilPowerOfTwo(value);
		},

	});

	Object.assign(Matrix3.prototype, {

		flattenToArrayOffset(array, offset) {
			console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
			return this.toArray(array, offset);
		},
		multiplyVector3(vector) {
			console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
			return vector.applyMatrix3(this);
		},
		multiplyVector3Array(/* a */) {
			console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
		},
		applyToBuffer(buffer /* , offset, length */) {
			console.warn('THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');
			return this.applyToBufferAttribute(buffer);
		},
		applyToVector3Array(/* array, offset, length */) {
			console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
		},

	});

	Object.assign(Matrix4.prototype, {

		extractPosition(m) {
			console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
			return this.copyPosition(m);
		},
		flattenToArrayOffset(array, offset) {
			console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
			return this.toArray(array, offset);
		},
		getPosition: (function () {
			let v1;

			return function getPosition() {
				if (v1 === undefined) v1 = new Vector3();
				console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
				return v1.setFromMatrixColumn(this, 3);
			};
		}()),
		setRotationFromQuaternion(q) {
			console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
			return this.makeRotationFromQuaternion(q);
		},
		multiplyToArray() {
			console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
		},
		multiplyVector3(vector) {
			console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
			return vector.applyMatrix4(this);
		},
		multiplyVector4(vector) {
			console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
			return vector.applyMatrix4(this);
		},
		multiplyVector3Array(/* a */) {
			console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
		},
		rotateAxis(v) {
			console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
			v.transformDirection(this);
		},
		crossVector(vector) {
			console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
			return vector.applyMatrix4(this);
		},
		translate() {
			console.error('THREE.Matrix4: .translate() has been removed.');
		},
		rotateX() {
			console.error('THREE.Matrix4: .rotateX() has been removed.');
		},
		rotateY() {
			console.error('THREE.Matrix4: .rotateY() has been removed.');
		},
		rotateZ() {
			console.error('THREE.Matrix4: .rotateZ() has been removed.');
		},
		rotateByAxis() {
			console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
		},
		applyToBuffer(buffer /* , offset, length */) {
			console.warn('THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');
			return this.applyToBufferAttribute(buffer);
		},
		applyToVector3Array(/* array, offset, length */) {
			console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
		},
		makeFrustum(left, right, bottom, top, near, far) {
			console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
			return this.makePerspective(left, right, top, bottom, near, far);
		},

	});

	Plane.prototype.isIntersectionLine = function (line) {
		console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
		return this.intersectsLine(line);
	};

	Quaternion.prototype.multiplyVector3 = function (vector) {
		console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
		return vector.applyQuaternion(this);
	};

	Object.assign(Ray.prototype, {

		isIntersectionBox(box) {
			console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
			return this.intersectsBox(box);
		},
		isIntersectionPlane(plane) {
			console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
			return this.intersectsPlane(plane);
		},
		isIntersectionSphere(sphere) {
			console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
			return this.intersectsSphere(sphere);
		},

	});

	Object.assign(Triangle.prototype, {

		area() {
			console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
			return this.getArea();
		},
		barycoordFromPoint(point, target) {
			console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
			return this.getBarycoord(point, target);
		},
		midpoint(target) {
			console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
			return this.getMidpoint(target);
		},
		normal(target) {
			console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
			return this.getNormal(target);
		},
		plane(target) {
			console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
			return this.getPlane(target);
		},

	});

	Object.assign(Triangle, {

		barycoordFromPoint(point, a, b, c, target) {
			console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
			return Triangle.getBarycoord(point, a, b, c, target);
		},
		normal(a, b, c, target) {
			console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
			return Triangle.getNormal(a, b, c, target);
		},

	});

	Object.assign(Shape.prototype, {

		extractAllPoints(divisions) {
			console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
			return this.extractPoints(divisions);
		},
		extrude(options) {
			console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
			return new ExtrudeGeometry(this, options);
		},
		makeGeometry(options) {
			console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
			return new ShapeGeometry(this, options);
		},

	});

	Object.assign(Vector2.prototype, {

		fromAttribute(attribute, index, offset) {
			console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
			return this.fromBufferAttribute(attribute, index, offset);
		},
		distanceToManhattan(v) {
			console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
			return this.manhattanDistanceTo(v);
		},
		lengthManhattan() {
			console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
			return this.manhattanLength();
		},

	});

	Object.assign(Vector3.prototype, {

		setEulerFromRotationMatrix() {
			console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
		},
		setEulerFromQuaternion() {
			console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
		},
		getPositionFromMatrix(m) {
			console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
			return this.setFromMatrixPosition(m);
		},
		getScaleFromMatrix(m) {
			console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
			return this.setFromMatrixScale(m);
		},
		getColumnFromMatrix(index, matrix) {
			console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
			return this.setFromMatrixColumn(matrix, index);
		},
		applyProjection(m) {
			console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
			return this.applyMatrix4(m);
		},
		fromAttribute(attribute, index, offset) {
			console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
			return this.fromBufferAttribute(attribute, index, offset);
		},
		distanceToManhattan(v) {
			console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
			return this.manhattanDistanceTo(v);
		},
		lengthManhattan() {
			console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
			return this.manhattanLength();
		},

	});

	Object.assign(Vector4.prototype, {

		fromAttribute(attribute, index, offset) {
			console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
			return this.fromBufferAttribute(attribute, index, offset);
		},
		lengthManhattan() {
			console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
			return this.manhattanLength();
		},

	});

	//

	Object.assign(Geometry.prototype, {

		computeTangents() {
			console.error('THREE.Geometry: .computeTangents() has been removed.');
		},
		computeLineDistances() {
			console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');
		},

	});

	Object.assign(Object3D.prototype, {

		getChildByName(name) {
			console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
			return this.getObjectByName(name);
		},
		renderDepth() {
			console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
		},
		translate(distance, axis) {
			console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
			return this.translateOnAxis(axis, distance);
		},
		getWorldRotation() {
			console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
		},

	});

	Object.defineProperties(Object3D.prototype, {

		eulerOrder: {
			get() {
				console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
				return this.rotation.order;
			},
			set(value) {
				console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
				this.rotation.order = value;
			},
		},
		useQuaternion: {
			get() {
				console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
			},
			set() {
				console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
			},
		},

	});

	Object.defineProperties(LOD.prototype, {

		objects: {
			get() {
				console.warn('THREE.LOD: .objects has been renamed to .levels.');
				return this.levels;
			},
		},

	});

	Object.defineProperty(Skeleton.prototype, 'useVertexTexture', {

		get() {
			console.warn('THREE.Skeleton: useVertexTexture has been removed.');
		},
		set() {
			console.warn('THREE.Skeleton: useVertexTexture has been removed.');
		},

	});

	SkinnedMesh.prototype.initBones = function () {
		console.error('THREE.SkinnedMesh: initBones() has been removed.');
	};

	Object.defineProperty(Curve.prototype, '__arcLengthDivisions', {

		get() {
			console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
			return this.arcLengthDivisions;
		},
		set(value) {
			console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
			this.arcLengthDivisions = value;
		},

	});

	//

	PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
		console.warn('THREE.PerspectiveCamera.setLens is deprecated. '
				+ 'Use .setFocalLength and .filmGauge for a photographic setup.');

		if (filmGauge !== undefined) this.filmGauge = filmGauge;
		this.setFocalLength(focalLength);
	};

	//

	Object.defineProperties(Light.prototype, {
		onlyShadow: {
			set() {
				console.warn('THREE.Light: .onlyShadow has been removed.');
			},
		},
		shadowCameraFov: {
			set(value) {
				console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
				this.shadow.camera.fov = value;
			},
		},
		shadowCameraLeft: {
			set(value) {
				console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
				this.shadow.camera.left = value;
			},
		},
		shadowCameraRight: {
			set(value) {
				console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
				this.shadow.camera.right = value;
			},
		},
		shadowCameraTop: {
			set(value) {
				console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
				this.shadow.camera.top = value;
			},
		},
		shadowCameraBottom: {
			set(value) {
				console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
				this.shadow.camera.bottom = value;
			},
		},
		shadowCameraNear: {
			set(value) {
				console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
				this.shadow.camera.near = value;
			},
		},
		shadowCameraFar: {
			set(value) {
				console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
				this.shadow.camera.far = value;
			},
		},
		shadowCameraVisible: {
			set() {
				console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
			},
		},
		shadowBias: {
			set(value) {
				console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
				this.shadow.bias = value;
			},
		},
		shadowDarkness: {
			set() {
				console.warn('THREE.Light: .shadowDarkness has been removed.');
			},
		},
		shadowMapWidth: {
			set(value) {
				console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
				this.shadow.mapSize.width = value;
			},
		},
		shadowMapHeight: {
			set(value) {
				console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
				this.shadow.mapSize.height = value;
			},
		},
	});

	//

	Object.defineProperties(BufferAttribute.prototype, {

		length: {
			get() {
				console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
				return this.array.length;
			},
		},
		copyIndicesArray(/* indices */) {
			console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
		},

	});

	Object.assign(BufferGeometry.prototype, {

		addIndex(index) {
			console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
			this.setIndex(index);
		},
		addDrawCall(start, count, indexOffset) {
			if (indexOffset !== undefined) {
				console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
			}
			console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
			this.addGroup(start, count);
		},
		clearDrawCalls() {
			console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
			this.clearGroups();
		},
		computeTangents() {
			console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
		},
		computeOffsets() {
			console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
		},

	});

	Object.defineProperties(BufferGeometry.prototype, {

		drawcalls: {
			get() {
				console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
				return this.groups;
			},
		},
		offsets: {
			get() {
				console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
				return this.groups;
			},
		},

	});

	//

	Object.assign(ExtrudeBufferGeometry.prototype, {

		getArrays() {
			console.error('THREE.ExtrudeBufferGeometry: .getArrays() has been removed.');
		},

		addShapeList() {
			console.error('THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.');
		},

		addShape() {
			console.error('THREE.ExtrudeBufferGeometry: .addShape() has been removed.');
		},

	});

	//

	Object.defineProperties(Uniform.prototype, {

		dynamic: {
			set() {
				console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');
			},
		},
		onUpdate: {
			value() {
				console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
				return this;
			},
		},

	});

	//

	Object.defineProperties(Material.prototype, {

		wrapAround: {
			get() {
				console.warn('THREE.Material: .wrapAround has been removed.');
			},
			set() {
				console.warn('THREE.Material: .wrapAround has been removed.');
			},
		},

		overdraw: {
			get() {
				console.warn('THREE.Material: .overdraw has been removed.');
			},
			set() {
				console.warn('THREE.Material: .overdraw has been removed.');
			},
		},

		wrapRGB: {
			get() {
				console.warn('THREE.Material: .wrapRGB has been removed.');
				return new Color();
			},
		},

		shading: {
			get() {
				console.error(`THREE.${this.type}: .shading has been removed. Use the boolean .flatShading instead.`);
			},
			set(value) {
				console.warn(`THREE.${this.type}: .shading has been removed. Use the boolean .flatShading instead.`);
				this.flatShading = (value === FlatShading);
			},
		},

	});

	Object.defineProperties(MeshPhongMaterial.prototype, {

		metal: {
			get() {
				console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
				return false;
			},
			set() {
				console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
			},
		},

	});

	Object.defineProperties(ShaderMaterial.prototype, {

		derivatives: {
			get() {
				console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
				return this.extensions.derivatives;
			},
			set(value) {
				console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
				this.extensions.derivatives = value;
			},
		},

	});

	//

	Object.assign(WebGLRenderer.prototype, {

		clearTarget(renderTarget, color, depth, stencil) {
			console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
			this.setRenderTarget(renderTarget);
			this.clear(color, depth, stencil);
		},

		animate(callback) {
			console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
			this.setAnimationLoop(callback);
		},

		getCurrentRenderTarget() {
			console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
			return this.getRenderTarget();
		},

		getMaxAnisotropy() {
			console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
			return this.capabilities.getMaxAnisotropy();
		},

		getPrecision() {
			console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
			return this.capabilities.precision;
		},

		resetGLState() {
			console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
			return this.state.reset();
		},

		supportsFloatTextures() {
			console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
			return this.extensions.get('OES_texture_float');
		},
		supportsHalfFloatTextures() {
			console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
			return this.extensions.get('OES_texture_half_float');
		},
		supportsStandardDerivatives() {
			console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
			return this.extensions.get('OES_standard_derivatives');
		},
		supportsCompressedTextureS3TC() {
			console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
			return this.extensions.get('WEBGL_compressed_texture_s3tc');
		},
		supportsCompressedTexturePVRTC() {
			console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
			return this.extensions.get('WEBGL_compressed_texture_pvrtc');
		},
		supportsBlendMinMax() {
			console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
			return this.extensions.get('EXT_blend_minmax');
		},
		supportsVertexTextures() {
			console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
			return this.capabilities.vertexTextures;
		},
		supportsInstancedArrays() {
			console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
			return this.extensions.get('ANGLE_instanced_arrays');
		},
		enableScissorTest(boolean) {
			console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
			this.setScissorTest(boolean);
		},
		initMaterial() {
			console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
		},
		addPrePlugin() {
			console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
		},
		addPostPlugin() {
			console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
		},
		updateShadowMap() {
			console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
		},
		setFaceCulling() {
			console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
		},

	});

	Object.defineProperties(WebGLRenderer.prototype, {

		shadowMapEnabled: {
			get() {
				return this.shadowMap.enabled;
			},
			set(value) {
				console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
				this.shadowMap.enabled = value;
			},
		},
		shadowMapType: {
			get() {
				return this.shadowMap.type;
			},
			set(value) {
				console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
				this.shadowMap.type = value;
			},
		},
		shadowMapCullFace: {
			get() {
				console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set(/* value */) {
				console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
			},
		},
	});

	Object.defineProperties(WebGLShadowMap.prototype, {

		cullFace: {
			get() {
				console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set(/* cullFace */) {
				console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
			},
		},
		renderReverseSided: {
			get() {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set() {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
			},
		},
		renderSingleSided: {
			get() {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set() {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
			},
		},

	});

	//

	Object.defineProperties(WebGLRenderTarget.prototype, {

		wrapS: {
			get() {
				console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
				return this.texture.wrapS;
			},
			set(value) {
				console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
				this.texture.wrapS = value;
			},
		},
		wrapT: {
			get() {
				console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
				return this.texture.wrapT;
			},
			set(value) {
				console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
				this.texture.wrapT = value;
			},
		},
		magFilter: {
			get() {
				console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
				return this.texture.magFilter;
			},
			set(value) {
				console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
				this.texture.magFilter = value;
			},
		},
		minFilter: {
			get() {
				console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
				return this.texture.minFilter;
			},
			set(value) {
				console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
				this.texture.minFilter = value;
			},
		},
		anisotropy: {
			get() {
				console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
				return this.texture.anisotropy;
			},
			set(value) {
				console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
				this.texture.anisotropy = value;
			},
		},
		offset: {
			get() {
				console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
				return this.texture.offset;
			},
			set(value) {
				console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
				this.texture.offset = value;
			},
		},
		repeat: {
			get() {
				console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
				return this.texture.repeat;
			},
			set(value) {
				console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
				this.texture.repeat = value;
			},
		},
		format: {
			get() {
				console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
				return this.texture.format;
			},
			set(value) {
				console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
				this.texture.format = value;
			},
		},
		type: {
			get() {
				console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
				return this.texture.type;
			},
			set(value) {
				console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
				this.texture.type = value;
			},
		},
		generateMipmaps: {
			get() {
				console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
				return this.texture.generateMipmaps;
			},
			set(value) {
				console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
				this.texture.generateMipmaps = value;
			},
		},

	});

	//

	Object.defineProperties(WebVRManager.prototype, {

		standing: {
			set(/* value */) {
				console.warn('THREE.WebVRManager: .standing has been removed.');
			},
		},
		userHeight: {
			set(/* value */) {
				console.warn('THREE.WebVRManager: .userHeight has been removed.');
			},
		},

	});

	//

	Audio.prototype.load = function (file) {
		console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
		const scope = this;
		const audioLoader = new AudioLoader();
		audioLoader.load(file, (buffer) => {
			scope.setBuffer(buffer);
		});
		return this;
	};

	AudioAnalyser.prototype.getData = function () {
		console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
		return this.getFrequencyData();
	};

	//

	CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
		console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
		return this.update(renderer, scene);
	};

	//

	const GeometryUtils = {

		merge(geometry1, geometry2, materialIndexOffset) {
			console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
			let matrix;

			if (geometry2.isMesh) {
				geometry2.matrixAutoUpdate && geometry2.updateMatrix();

				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;
			}

			geometry1.merge(geometry2, matrix, materialIndexOffset);
		},

		center(geometry) {
			console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
			return geometry.center();
		},

	};

	ImageUtils.crossOrigin = undefined;

	ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
		console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');

		const loader = new TextureLoader();
		loader.setCrossOrigin(this.crossOrigin);

		const texture = loader.load(url, onLoad, undefined, onError);

		if (mapping) texture.mapping = mapping;

		return texture;
	};

	ImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {
		console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');

		const loader = new CubeTextureLoader();
		loader.setCrossOrigin(this.crossOrigin);

		const texture = loader.load(urls, onLoad, undefined, onError);

		if (mapping) texture.mapping = mapping;

		return texture;
	};

	ImageUtils.loadCompressedTexture = function () {
		console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
	};

	ImageUtils.loadCompressedTextureCube = function () {
		console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
	};

	//

	function Projector() {
		console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');

		this.projectVector = function (vector, camera) {
			console.warn('THREE.Projector: .projectVector() is now vector.project().');
			vector.project(camera);
		};

		this.unprojectVector = function (vector, camera) {
			console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');
			vector.unproject(camera);
		};

		this.pickingRay = function () {
			console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');
		};
	}

	//

	function CanvasRenderer() {
		console.error('THREE.CanvasRenderer has been removed');
	}

	//

	function JSONLoader() {
		console.error('THREE.JSONLoader has been removed.');
	}

	//

	const SceneUtils = {

		createMultiMaterialObject(/* geometry, materials */) {
			console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');
		},

		detach(/* child, parent, scene */) {
			console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');
		},

		attach(/* child, scene, parent */) {
			console.error('THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js');
		},

	};

	//

	function LensFlare() {
		console.error('THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js');
	}

	exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
	exports.WebGLRenderTarget = WebGLRenderTarget;
	exports.WebGLRenderer = WebGLRenderer;
	exports.ShaderLib = ShaderLib;
	exports.UniformsLib = UniformsLib;
	exports.UniformsUtils = UniformsUtils;
	exports.ShaderChunk = ShaderChunk;
	exports.FogExp2 = FogExp2;
	exports.Fog = Fog;
	exports.Scene = Scene;
	exports.Sprite = Sprite;
	exports.LOD = LOD;
	exports.SkinnedMesh = SkinnedMesh;
	exports.Skeleton = Skeleton;
	exports.Bone = Bone;
	exports.Mesh = Mesh;
	exports.LineSegments = LineSegments;
	exports.LineLoop = LineLoop;
	exports.Line = Line;
	exports.Points = Points;
	exports.Group = Group;
	exports.VideoTexture = VideoTexture;
	exports.DataTexture = DataTexture;
	exports.DataTexture3D = DataTexture3D;
	exports.CompressedTexture = CompressedTexture;
	exports.CubeTexture = CubeTexture;
	exports.CanvasTexture = CanvasTexture;
	exports.DepthTexture = DepthTexture;
	exports.Texture = Texture;
	exports.AnimationLoader = AnimationLoader;
	exports.CompressedTextureLoader = CompressedTextureLoader;
	exports.DataTextureLoader = DataTextureLoader;
	exports.CubeTextureLoader = CubeTextureLoader;
	exports.TextureLoader = TextureLoader;
	exports.ObjectLoader = ObjectLoader;
	exports.MaterialLoader = MaterialLoader;
	exports.BufferGeometryLoader = BufferGeometryLoader;
	exports.DefaultLoadingManager = DefaultLoadingManager;
	exports.LoadingManager = LoadingManager;
	exports.ImageLoader = ImageLoader;
	exports.ImageBitmapLoader = ImageBitmapLoader;
	exports.FontLoader = FontLoader;
	exports.FileLoader = FileLoader;
	exports.Loader = Loader;
	exports.LoaderUtils = LoaderUtils;
	exports.Cache = Cache;
	exports.AudioLoader = AudioLoader;
	exports.SpotLightShadow = SpotLightShadow;
	exports.SpotLight = SpotLight;
	exports.PointLight = PointLight;
	exports.RectAreaLight = RectAreaLight;
	exports.HemisphereLight = HemisphereLight;
	exports.DirectionalLightShadow = DirectionalLightShadow;
	exports.DirectionalLight = DirectionalLight;
	exports.AmbientLight = AmbientLight;
	exports.LightShadow = LightShadow;
	exports.Light = Light;
	exports.StereoCamera = StereoCamera;
	exports.PerspectiveCamera = PerspectiveCamera;
	exports.OrthographicCamera = OrthographicCamera;
	exports.CubeCamera = CubeCamera;
	exports.ArrayCamera = ArrayCamera;
	exports.Camera = Camera;
	exports.AudioListener = AudioListener;
	exports.PositionalAudio = PositionalAudio;
	exports.AudioContext = AudioContext;
	exports.AudioAnalyser = AudioAnalyser;
	exports.Audio = Audio;
	exports.VectorKeyframeTrack = VectorKeyframeTrack;
	exports.StringKeyframeTrack = StringKeyframeTrack;
	exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
	exports.NumberKeyframeTrack = NumberKeyframeTrack;
	exports.ColorKeyframeTrack = ColorKeyframeTrack;
	exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
	exports.PropertyMixer = PropertyMixer;
	exports.PropertyBinding = PropertyBinding;
	exports.KeyframeTrack = KeyframeTrack;
	exports.AnimationUtils = AnimationUtils;
	exports.AnimationObjectGroup = AnimationObjectGroup;
	exports.AnimationMixer = AnimationMixer;
	exports.AnimationClip = AnimationClip;
	exports.Uniform = Uniform;
	exports.InstancedBufferGeometry = InstancedBufferGeometry;
	exports.BufferGeometry = BufferGeometry;
	exports.Geometry = Geometry;
	exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
	exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
	exports.InterleavedBuffer = InterleavedBuffer;
	exports.InstancedBufferAttribute = InstancedBufferAttribute;
	exports.Face3 = Face3;
	exports.Object3D = Object3D;
	exports.Raycaster = Raycaster;
	exports.Layers = Layers;
	exports.EventDispatcher = EventDispatcher;
	exports.Clock = Clock;
	exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
	exports.LinearInterpolant = LinearInterpolant;
	exports.DiscreteInterpolant = DiscreteInterpolant;
	exports.CubicInterpolant = CubicInterpolant;
	exports.Interpolant = Interpolant;
	exports.Triangle = Triangle;
	exports.Math = _Math;
	exports.Spherical = Spherical;
	exports.Cylindrical = Cylindrical;
	exports.Plane = Plane;
	exports.Frustum = Frustum;
	exports.Sphere = Sphere;
	exports.Ray = Ray;
	exports.Matrix4 = Matrix4;
	exports.Matrix3 = Matrix3;
	exports.Box3 = Box3;
	exports.Box2 = Box2;
	exports.Line3 = Line3;
	exports.Euler = Euler;
	exports.Vector4 = Vector4;
	exports.Vector3 = Vector3;
	exports.Vector2 = Vector2;
	exports.Quaternion = Quaternion;
	exports.Color = Color;
	exports.ImmediateRenderObject = ImmediateRenderObject;
	exports.VertexNormalsHelper = VertexNormalsHelper;
	exports.SpotLightHelper = SpotLightHelper;
	exports.SkeletonHelper = SkeletonHelper;
	exports.PointLightHelper = PointLightHelper;
	exports.RectAreaLightHelper = RectAreaLightHelper;
	exports.HemisphereLightHelper = HemisphereLightHelper;
	exports.GridHelper = GridHelper;
	exports.PolarGridHelper = PolarGridHelper;
	exports.FaceNormalsHelper = FaceNormalsHelper;
	exports.DirectionalLightHelper = DirectionalLightHelper;
	exports.CameraHelper = CameraHelper;
	exports.BoxHelper = BoxHelper;
	exports.Box3Helper = Box3Helper;
	exports.PlaneHelper = PlaneHelper;
	exports.ArrowHelper = ArrowHelper;
	exports.AxesHelper = AxesHelper;
	exports.Shape = Shape;
	exports.Path = Path;
	exports.ShapePath = ShapePath;
	exports.Font = Font;
	exports.CurvePath = CurvePath;
	exports.Curve = Curve;
	exports.ImageUtils = ImageUtils;
	exports.ShapeUtils = ShapeUtils;
	exports.WebGLUtils = WebGLUtils;
	exports.WireframeGeometry = WireframeGeometry;
	exports.ParametricGeometry = ParametricGeometry;
	exports.ParametricBufferGeometry = ParametricBufferGeometry;
	exports.TetrahedronGeometry = TetrahedronGeometry;
	exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
	exports.OctahedronGeometry = OctahedronGeometry;
	exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
	exports.IcosahedronGeometry = IcosahedronGeometry;
	exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
	exports.DodecahedronGeometry = DodecahedronGeometry;
	exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
	exports.PolyhedronGeometry = PolyhedronGeometry;
	exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
	exports.TubeGeometry = TubeGeometry;
	exports.TubeBufferGeometry = TubeBufferGeometry;
	exports.TorusKnotGeometry = TorusKnotGeometry;
	exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
	exports.TorusGeometry = TorusGeometry;
	exports.TorusBufferGeometry = TorusBufferGeometry;
	exports.TextGeometry = TextGeometry;
	exports.TextBufferGeometry = TextBufferGeometry;
	exports.SphereGeometry = SphereGeometry;
	exports.SphereBufferGeometry = SphereBufferGeometry;
	exports.RingGeometry = RingGeometry;
	exports.RingBufferGeometry = RingBufferGeometry;
	exports.PlaneGeometry = PlaneGeometry;
	exports.PlaneBufferGeometry = PlaneBufferGeometry;
	exports.LatheGeometry = LatheGeometry;
	exports.LatheBufferGeometry = LatheBufferGeometry;
	exports.ShapeGeometry = ShapeGeometry;
	exports.ShapeBufferGeometry = ShapeBufferGeometry;
	exports.ExtrudeGeometry = ExtrudeGeometry;
	exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
	exports.EdgesGeometry = EdgesGeometry;
	exports.ConeGeometry = ConeGeometry;
	exports.ConeBufferGeometry = ConeBufferGeometry;
	exports.CylinderGeometry = CylinderGeometry;
	exports.CylinderBufferGeometry = CylinderBufferGeometry;
	exports.CircleGeometry = CircleGeometry;
	exports.CircleBufferGeometry = CircleBufferGeometry;
	exports.BoxGeometry = BoxGeometry;
	exports.BoxBufferGeometry = BoxBufferGeometry;
	exports.ShadowMaterial = ShadowMaterial;
	exports.SpriteMaterial = SpriteMaterial;
	exports.RawShaderMaterial = RawShaderMaterial;
	exports.ShaderMaterial = ShaderMaterial;
	exports.PointsMaterial = PointsMaterial;
	exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
	exports.MeshStandardMaterial = MeshStandardMaterial;
	exports.MeshPhongMaterial = MeshPhongMaterial;
	exports.MeshToonMaterial = MeshToonMaterial;
	exports.MeshNormalMaterial = MeshNormalMaterial;
	exports.MeshLambertMaterial = MeshLambertMaterial;
	exports.MeshDepthMaterial = MeshDepthMaterial;
	exports.MeshDistanceMaterial = MeshDistanceMaterial;
	exports.MeshBasicMaterial = MeshBasicMaterial;
	exports.MeshMatcapMaterial = MeshMatcapMaterial;
	exports.LineDashedMaterial = LineDashedMaterial;
	exports.LineBasicMaterial = LineBasicMaterial;
	exports.Material = Material;
	exports.Float64BufferAttribute = Float64BufferAttribute;
	exports.Float32BufferAttribute = Float32BufferAttribute;
	exports.Uint32BufferAttribute = Uint32BufferAttribute;
	exports.Int32BufferAttribute = Int32BufferAttribute;
	exports.Uint16BufferAttribute = Uint16BufferAttribute;
	exports.Int16BufferAttribute = Int16BufferAttribute;
	exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
	exports.Uint8BufferAttribute = Uint8BufferAttribute;
	exports.Int8BufferAttribute = Int8BufferAttribute;
	exports.BufferAttribute = BufferAttribute;
	exports.ArcCurve = ArcCurve;
	exports.CatmullRomCurve3 = CatmullRomCurve3;
	exports.CubicBezierCurve = CubicBezierCurve;
	exports.CubicBezierCurve3 = CubicBezierCurve3;
	exports.EllipseCurve = EllipseCurve;
	exports.LineCurve = LineCurve;
	exports.LineCurve3 = LineCurve3;
	exports.QuadraticBezierCurve = QuadraticBezierCurve;
	exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
	exports.SplineCurve = SplineCurve;
	exports.REVISION = REVISION;
	exports.MOUSE = MOUSE;
	exports.CullFaceNone = CullFaceNone;
	exports.CullFaceBack = CullFaceBack;
	exports.CullFaceFront = CullFaceFront;
	exports.CullFaceFrontBack = CullFaceFrontBack;
	exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
	exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
	exports.BasicShadowMap = BasicShadowMap;
	exports.PCFShadowMap = PCFShadowMap;
	exports.PCFSoftShadowMap = PCFSoftShadowMap;
	exports.FrontSide = FrontSide;
	exports.BackSide = BackSide;
	exports.DoubleSide = DoubleSide;
	exports.FlatShading = FlatShading;
	exports.SmoothShading = SmoothShading;
	exports.NoColors = NoColors;
	exports.FaceColors = FaceColors;
	exports.VertexColors = VertexColors;
	exports.NoBlending = NoBlending;
	exports.NormalBlending = NormalBlending;
	exports.AdditiveBlending = AdditiveBlending;
	exports.SubtractiveBlending = SubtractiveBlending;
	exports.MultiplyBlending = MultiplyBlending;
	exports.CustomBlending = CustomBlending;
	exports.AddEquation = AddEquation;
	exports.SubtractEquation = SubtractEquation;
	exports.ReverseSubtractEquation = ReverseSubtractEquation;
	exports.MinEquation = MinEquation;
	exports.MaxEquation = MaxEquation;
	exports.ZeroFactor = ZeroFactor;
	exports.OneFactor = OneFactor;
	exports.SrcColorFactor = SrcColorFactor;
	exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
	exports.SrcAlphaFactor = SrcAlphaFactor;
	exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
	exports.DstAlphaFactor = DstAlphaFactor;
	exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
	exports.DstColorFactor = DstColorFactor;
	exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
	exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
	exports.NeverDepth = NeverDepth;
	exports.AlwaysDepth = AlwaysDepth;
	exports.LessDepth = LessDepth;
	exports.LessEqualDepth = LessEqualDepth;
	exports.EqualDepth = EqualDepth;
	exports.GreaterEqualDepth = GreaterEqualDepth;
	exports.GreaterDepth = GreaterDepth;
	exports.NotEqualDepth = NotEqualDepth;
	exports.MultiplyOperation = MultiplyOperation;
	exports.MixOperation = MixOperation;
	exports.AddOperation = AddOperation;
	exports.NoToneMapping = NoToneMapping;
	exports.LinearToneMapping = LinearToneMapping;
	exports.ReinhardToneMapping = ReinhardToneMapping;
	exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
	exports.CineonToneMapping = CineonToneMapping;
	exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
	exports.UVMapping = UVMapping;
	exports.CubeReflectionMapping = CubeReflectionMapping;
	exports.CubeRefractionMapping = CubeRefractionMapping;
	exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
	exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
	exports.SphericalReflectionMapping = SphericalReflectionMapping;
	exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
	exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
	exports.RepeatWrapping = RepeatWrapping;
	exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
	exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
	exports.NearestFilter = NearestFilter;
	exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
	exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
	exports.LinearFilter = LinearFilter;
	exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
	exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
	exports.UnsignedByteType = UnsignedByteType;
	exports.ByteType = ByteType;
	exports.ShortType = ShortType;
	exports.UnsignedShortType = UnsignedShortType;
	exports.IntType = IntType;
	exports.UnsignedIntType = UnsignedIntType;
	exports.FloatType = FloatType;
	exports.HalfFloatType = HalfFloatType;
	exports.UnsignedShort4444Type = UnsignedShort4444Type;
	exports.UnsignedShort5551Type = UnsignedShort5551Type;
	exports.UnsignedShort565Type = UnsignedShort565Type;
	exports.UnsignedInt248Type = UnsignedInt248Type;
	exports.AlphaFormat = AlphaFormat;
	exports.RGBFormat = RGBFormat;
	exports.RGBAFormat = RGBAFormat;
	exports.LuminanceFormat = LuminanceFormat;
	exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
	exports.RGBEFormat = RGBEFormat;
	exports.DepthFormat = DepthFormat;
	exports.DepthStencilFormat = DepthStencilFormat;
	exports.RedFormat = RedFormat;
	exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
	exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
	exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
	exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
	exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
	exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
	exports.RGB_ETC1_Format = RGB_ETC1_Format;
	exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
	exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
	exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
	exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
	exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
	exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
	exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
	exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
	exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
	exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
	exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
	exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
	exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
	exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
	exports.LoopOnce = LoopOnce;
	exports.LoopRepeat = LoopRepeat;
	exports.LoopPingPong = LoopPingPong;
	exports.InterpolateDiscrete = InterpolateDiscrete;
	exports.InterpolateLinear = InterpolateLinear;
	exports.InterpolateSmooth = InterpolateSmooth;
	exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
	exports.ZeroSlopeEnding = ZeroSlopeEnding;
	exports.WrapAroundEnding = WrapAroundEnding;
	exports.TrianglesDrawMode = TrianglesDrawMode;
	exports.TriangleStripDrawMode = TriangleStripDrawMode;
	exports.TriangleFanDrawMode = TriangleFanDrawMode;
	exports.LinearEncoding = LinearEncoding;
	exports.sRGBEncoding = sRGBEncoding;
	exports.GammaEncoding = GammaEncoding;
	exports.RGBEEncoding = RGBEEncoding;
	exports.LogLuvEncoding = LogLuvEncoding;
	exports.RGBM7Encoding = RGBM7Encoding;
	exports.RGBM16Encoding = RGBM16Encoding;
	exports.RGBDEncoding = RGBDEncoding;
	exports.BasicDepthPacking = BasicDepthPacking;
	exports.RGBADepthPacking = RGBADepthPacking;
	exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
	exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
	exports.CubeGeometry = BoxGeometry;
	exports.Face4 = Face4;
	exports.LineStrip = LineStrip;
	exports.LinePieces = LinePieces;
	exports.MeshFaceMaterial = MeshFaceMaterial;
	exports.MultiMaterial = MultiMaterial;
	exports.PointCloud = PointCloud;
	exports.Particle = Particle;
	exports.ParticleSystem = ParticleSystem;
	exports.PointCloudMaterial = PointCloudMaterial;
	exports.ParticleBasicMaterial = ParticleBasicMaterial;
	exports.ParticleSystemMaterial = ParticleSystemMaterial;
	exports.Vertex = Vertex;
	exports.DynamicBufferAttribute = DynamicBufferAttribute;
	exports.Int8Attribute = Int8Attribute;
	exports.Uint8Attribute = Uint8Attribute;
	exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
	exports.Int16Attribute = Int16Attribute;
	exports.Uint16Attribute = Uint16Attribute;
	exports.Int32Attribute = Int32Attribute;
	exports.Uint32Attribute = Uint32Attribute;
	exports.Float32Attribute = Float32Attribute;
	exports.Float64Attribute = Float64Attribute;
	exports.ClosedSplineCurve3 = ClosedSplineCurve3;
	exports.SplineCurve3 = SplineCurve3;
	exports.Spline = Spline;
	exports.AxisHelper = AxisHelper;
	exports.BoundingBoxHelper = BoundingBoxHelper;
	exports.EdgesHelper = EdgesHelper;
	exports.WireframeHelper = WireframeHelper;
	exports.XHRLoader = XHRLoader;
	exports.BinaryTextureLoader = BinaryTextureLoader;
	exports.GeometryUtils = GeometryUtils;
	exports.Projector = Projector;
	exports.CanvasRenderer = CanvasRenderer;
	exports.JSONLoader = JSONLoader;
	exports.SceneUtils = SceneUtils;
	exports.LensFlare = LensFlare;

	Object.defineProperty(exports, '__esModule', { value: true });
})));
